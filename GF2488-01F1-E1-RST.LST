C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE GF2488_01F1_E1_RST
OBJECT MODULE PLACED IN GF2488-01F1-E1-RST.OBJ
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE GF2488-01F1-E1-RST.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND T
                    -ABS(2)

line level    source

   1          /******************************************************************
   2          ** 文件名：STAND.C
   3          ** Copyright (c) 2002 烽火通信传输产品部BCT软件组
   4          ** 创建人：翁益晖
   5          ** 文件编号：
   6          ** 描　述：标准模版程序
   7          **         
   8          ** 日　期：2002.6.28
   9          ** 修改人：
  10          ** 日　期：
  11          ** 文件编号：
  12          ** 描　述：
  13          **
  14          **
  15          ** 编译器：Keil C51 V5.5 或 MCC68K V4.4
  16          ** 公共库：NewLib9.LIB for Mcs51
  17          **         或 NewLib1.LIB for Mc68302
  18          ** 版  本：1.0
  19          ********************************************************************/
  20          //#define  NEED_LP_RFI   /**  !!! 单盘起不来了  */
  21          #define AIS_CONDITIONS      /** 与 AIS_CONDITIONS_AUTO 二选一  */
  22          //#define AIS_CONDITIONS_AUTO
  23          #define SKIP_DEBUG_CHECK
  24          
  25          #define UASNUM    63        //要计算误码的线路数63//
  26          #define LINENUM   64        /*告警线路数为64*/
  27          #ifdef NEED_LP_RFI
                #define ALMNUM      822     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
                #define ALMTYPENUM      16      /*16种告警类型*/
              #else
  31            #define ALMNUM      759     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
  32            #define ALMTYPENUM      15      /*15种告警类型*/
  33          #endif
  34          
  35          #define PMNUM   441         /*总共63*PMTYPENUM个性能*/
  36          
  37          #define PMTYPENUM       7       /*7种性能类型*/
  38          #define CONFLEN   2560  /*配置数据长度为2560*/
  39          #define STATELEN  338   /*状态数据长度为338*/
  40          #define BOARDCODE 0x96  /*盘代码*/
  41          #define WGS21891A 0xB000
  42          
  43          #define SW1021  0xB000    //TODO：confirm
  44          
  45          #define SW1021_CHIP_ADDR(num)  (SW1021 + 0x1000*(num))
  46          #define CHIPS_ON_BOARD          3
  47          
  48          
  49          #include "commvar9.h"
  50          #include "uasE63.h"
  51          
  52          #include "sw1021.h"
  53          
  54          char code SysName[]="GF2488-01F";
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 2   

  55          char code BoardName[]="E1-63A";
  56          char code BoardSn[]="WKE2.170.609R1B";
  57          char code SoftVer[]="R170609R1B/01F    ";
  58          
  59          char code PcbSn[]="WKE7.822.828R1B";
  60          char code PcbTime[]="2004 05 02";
  61          
  62          char code BoardSoftVer[]="RP0100            ";
  63          
  64          char code SoftDate[]=__DATE__;
  65          char code SoftTime[]=__TIME__;
  66          
  67          extern int sprintf(char *, const char *, ...);
  68          
  69          #define RSTB IO0
  70          #define TUALMO IO2
  71          #define TUXAB IO5 //TUXAB为主备交叉时钟盘XCU有效指示信号,主用XCU有效时TUXAB=0,备用XCU有效TUXAB=1
  72          #define WP IO6     //E1-63A盘在正常槽位时WP=1,在保护槽位时WP=0//
  73          #define TUSWTI IO7 //本盘almnumber大于一定值时,TUALMO=1,XCU盘收到TUALMO=1时,产生TUSWTI=0//
  74          #define P2V5 IO8
  75          #define P5VI1 IO9
  76          #define P5VI2 IO10
  77          #define DZBI1 IO11
  78          #define DZBI2 IO12
  79          extern unsigned char g_AllClrFlag;
  80          extern unsigned char g_LampEn;
  81          unsigned int ulEsLimit,ulSesLimit;
  82          //unsigned int WGS21891,wgs21891reg0[4],wgs21891reg1[4];
  83          unsigned int sw1021Chip;
  84          unsigned int N1000[63],BIP[63],BIP_2_1S[63],BIP_2_1000S[63];
  85          unsigned char actnumber,almnumber,first_conf;
  86          unsigned char g_haveTux;
  87          /*
  88          code unsigned char slot[64]={1,22,43,4,25,46,7,
  89          28,49,10,31,52,13,34,
  90          55,16,37,58,19,40,61,
  91          
  92          2,23,44,5,26,47,8,
  93          29,50,11,32,53,14,35,
  94          56,17,38,59,20,41,62,
  95          
  96          3,24,45,6,27,48,9,
  97          30,51,12,33,54,15,36,
  98          57,18,39,60,21,42,63,0};
  99              */
 100          /*
 101          code unsigned char slot[64]={0x00,0x20,0x40,0x01,0x21,0x41,0x02,
 102                               0x22,0x42,0x03,0x23,0x43,0x04,0x24,
 103                               0x44,0x05,0x25,0x45,0x06,0x26,0x46,
 104          
 105                               0x07,0x27,0x47,0x08,0x28,0x48,0x09,
 106                               0x29,0x49,0x0a,0x2a,0x4a,0x0b,0x2b,
 107                               0x4b,0x0c,0x2c,0x4c,0x0d,0x2d,0x4d,
 108          
 109                               0x0e,0x2e,0x4e,0x0f,0x2f,0x4f,0x10,
 110                               0x30,0x50,0x11,0x31,0x51,0x12,0x32,
 111                               0x52,0x13,0x33,0x53,0x14,0x34,0x54,
 112                               0
 113                          };    
 114          */
 115          code unsigned char slot[64]={0x00,0x07,0x0e,0x01,0x08,0x0f,0x02,
 116                               0x09,0x10,0x03,0x0a,0x11,0x04,0x0b,
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 3   

 117                               0x12,0x05,0x0c,0x13,0x06,0x0d,0x14,
 118          
 119                               0x20,0x27,0x2e,0x21,0x28,0x2f,0x22,
 120                               0x29,0x30,0x23,0x2a,0x31,0x24,0x2b,
 121                               0x32,0x25,0x2c,0x33,0x26,0x2d,0x34,
 122          
 123                               0x40,0x47,0x4e,0x41,0x48,0x4f,0x42,
 124                               0x49,0x50,0x43,0x4a,0x51,0x44,0x4b,
 125                               0x52,0x45,0x4c,0x53,0x46,0x4d,0x54,
 126                               0
 127                          };
 128          
 129              
 130          static void writeTxJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 131          {
 132   1        int copOk = 0;
 133   1        int busBase = A_BUS_BASE;
 134   1        int i = 5;
 135   1        if(busB)
 136   1          busBase = B_BUS_BASE;
 137   1        // write  Tx J2 data
 138   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_DATA_REG(busBase)] = j2;
 139   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_WHICH_REG(busBase)] = witchJ2;
 140   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_SLOT_REG(busBase)] = RW_SEL | Slot;
 141   1        while(!copOk){
 142   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_RAM_STATUS_REG(busBase)] & 0x01;
 143   2          i--;
 144   2          if(i == 0)
 145   2            break;
 146   2          //Delay(1);
 147   2        }
 148   1      }
 149          
 150          static void writeExpectJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 151          {
 152   1        int copOk = 0;
 153   1        int busBase = A_BUS_BASE;
 154   1        int i = 5;
 155   1        if(busB) 
 156   1          busBase = B_BUS_BASE;
 157   1        // write  Tx J2 data
 158   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)] = j2;
 159   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = EXPECT_J2 |  witchJ2;
 160   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] = RW_SEL | Slot;
 161   1        while(!copOk){
 162   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 163   2          i--;
 164   2          if(i == 0)
 165   2            break;
 166   2          //Delay(1);
 167   2        }
 168   1      }
 169          
 170          /*****************************************************************
 171          ** 函数名:GETDATA
 172          ** 输　入: 无
 173          ** 输　出: 无
 174          ** 功能描述：采集单盘告警和性能
 175          ** 全局变量：无
 176          ** 调用模块：无
 177          ** 作　者：翁益晖
 178          ** 日　期：2002.5.25
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 4   

 179          ** 修　改：
 180          ** 日　期：
 181          ** 版  本：1.0
 182          ****************************************************************/
 183          void GetData()          
 184          {
 185   1        unsigned char i,m,n,mi,ni,tmp,tmpi,ADCLK,PPILOS,TULOP,LPSLM,LPTIM,LPTIU,LPRDI,LPRFI,LPUNEQ,TUAIS,PPIAIS,
 186   1        LOOP,LOOPL,tv5;
 187   1        unsigned int  LPFEBE,HDB3;
 188   1        unsigned char lopCnt = 0;
 189   1        actnumber=0;
 190   1        almnumber=0;
 191   1        sw1021Chip = SW1021;
 192   1        for(i=0;i<(LINENUM-1);i++)
 193   1        {          
 194   2          
 195   2          if(g_ucState[78+i]==0)
 196   2          {
 197   3            g_ucLineMask[i]=1;
 198   3            // ADCLK 告警 (A 路下行时钟告警 )
 199   3            ADCLK=XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC; 
 200   3      
 201   3          }
 202   2          else   
 203   2          {
 204   3            m=i/21;
 205   3            n=i%21;
 206   3            mi=i/8;
 207   3            ni=i%8;
 208   3            
 209   3            sw1021Chip = SW1021_CHIP_ADDR(m);
 210   3            
 211   3            if(TULOP||TUAIS)
 212   3              g_ucLofFlag[i]=1;      //有TULOP,TUAIS,PPILOS告警之一时上报UAS
 213   3            else
 214   3              g_ucLofFlag[i]=0;
 215   3            
 216   3            actnumber=actnumber+g_ucConfData[64+i];
 217   3            
 218   3            ADCLK = XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC;
 219   3            tmp = XBYTE[sw1021Chip+PORT_E1_ALARM_REG(n)];
 220   3            PPIAIS = tmp & E1AIS;
 221   3            PPILOS = tmp & E1LOS;
 222   3          /*
 223   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 224   3            TULOP = tmp & LOPI;
 225   3            TUAIS = tmp & AISI;
 226   3            LPSLM = tmp & PLMI;
 227   3            LPTIM = tmp & RTIMI;
 228   3            LPTIU = tmp & RTIUI;
 229   3            LPRDI = tmp & RDII;
 230   3            LPRFI = tmp & RFII;
 231   3            LPUNEQ = tmp & UNEQI;
 232   3          */
 233   3            
 234   3            tmpi = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 235   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG(A_BUS_BASE, n)] | tmpi;
 236   3            TULOP = tmp & LOPV;
 237   3            TUAIS = tmp & AISV;
 238   3            LPSLM = tmp & PLMV;
 239   3            LPTIM = tmp & RTIMV;
 240   3            LPTIU = tmp & RTIUV;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 5   

 241   3            LPRDI = tmp & RDIV;
 242   3            LPRFI = tmp & RFIV;
 243   3            LPUNEQ = tmp & UNEQV;
 244   3            
 245   3            if(TULOP) lopCnt++;
 246   3            
 247   3          #ifdef AIS_CONDITIONS 
 248   3            /** 方法1： 手动 */
 249   3            //AIS 产生条件 ---add by caijun.Li
 250   3            if(((g_ucConfData[2531] & 0x80) && LPTIM) || ((g_ucConfData[2531] & 0x40) && LPUNEQ ) || ((g_ucConfData
             -[2531] & 0x20) && LPSLM ) /* || ((g_ucConfData[2531] & 0x10) && LPSD )*/ ){
 251   4              // 下插AIS
 252   4              XBYTE[sw1021Chip + PORT_CFG_REG(n)] |= RAISEN;
 253   4            }else{
 254   4              // 停止下插AIS
 255   4              XBYTE[sw1021Chip + PORT_CFG_REG(n)] &= ~RAISEN;
 256   4            }
 257   3              
 258   3          #endif
 259   3            
 260   3            
 261   3            //must be write BIPERR_COUNTER_REG ; see manual
 262   3            XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 263   3            g_liError1s[i].ulDatlong += XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+BIP
             -ERR_COUNTER_REG(A_BUS_BASE, n) + 1] * 256);   // BIP错误计数值
 264   3            //must be write REI_COUNTER_REG ; see manual
 265   3            XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 266   3            LPFEBE = XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BAS
             -E, n) + 1] * 256); //REI(FEBE)计数值
 267   3            
 268   3            tmp = XBYTE[sw1021Chip + PORT_TEST_REG(n)];
 269   3                  
 270   3            LOOPL =  tmp & E1LBK;
 271   3            LOOP =   tmp & LnLBK;
 272   3            
 273   3            if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 274   3            {
 275   4              g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;
 276   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)].ucState=1;           
 277   4              else                                              //E1输入口有信号时/// 
 278   4              {
 279   5                if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==1)  //如果还存在PPILOS告警//
 280   5                if(WP==1)                        //非保护盘位时//
 281   5                {
 282   6                  // 向第i通道上话方向插短时间的伪随机码
 283   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 284   6                  g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS//
 285   6          
 286   6                  Delay(10);
 287   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &=  ~(PRBSEN | PRBST); //停插伪随机码
 288   6      
 289   6                }
 290   5                else g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS////保护盘位时//
 291   5              }
 292   4      
 293   4            }
 294   3            else
 295   3            {
 296   4              g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;
 297   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;               
 298   4              else  g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=1;
 299   4            }              
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 6   

 300   3            //if(PPIAIS) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;               
 301   3            //else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 302   3            if(TULOP) g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=1;              
 303   3            else g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=0;  
 304   3            if(TUAIS) g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=1;              
 305   3            else g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=0;
 306   3            if(TULOP||TUAIS)
 307   3            {
 308   4              g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 309   4              g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 310   4              g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 311   4              #ifdef NEED_LP_RFI
                      g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
                      #endif
 314   4              g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0; 
 315   4            }
 316   3            else
 317   3            {
 318   4              if(LPSLM) g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=1;              
 319   4              else g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 320   4              if(LPRDI) g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=1;              
 321   4              else g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 322   4              if(LPUNEQ) g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=1;               
 323   4              else g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 324   4      
 325   4              /* 烽火老设备未使用RFI,不使用时将下面两句屏蔽 */
 326   4      #ifdef NEED_LP_RFI
                       if(LPRFI) g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=1;              
                       else g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
              #endif
 330   4              
 331   4              if(LPTIM) g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=1;              
 332   4              else g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0;  
 333   4            }
 334   3            if(LOOPL) g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=1;               
 335   3            else g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=0;
 336   3            if(LOOP) g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=1;              
 337   3            else g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=0;
 338   3            if(g_stuPm[i*PMTYPENUM+3].Value.usint>=(0xffff-LPFEBE)) g_stuPm[i*PMTYPENUM+3].Value.usint=0xffff;     
             -  
 339   3            else g_stuPm[i*PMTYPENUM+3].Value.usint+=LPFEBE;   //REI(FEBE)性能值                    
 340   3            if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==0)                               //无PPI_LOS告警时
 341   3            {
 342   4               //HDB3编码违例计数值
 343   4              HDB3 = XBYTE[sw1021Chip + HDB3_CV_REG(n)];
 344   4              
 345   4              if(g_stuPm[i*PMTYPENUM+4].Value.usint>=(0xffff-HDB3)) g_stuPm[i*PMTYPENUM+4].Value.usint=0xffff;     
 346   4              else g_stuPm[i*PMTYPENUM+4].Value.usint+=HDB3;      // HDB3性能值         //g_stuPm[i][4]=HDB3CV
 347   4            }           
 348   3      
 349   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState)
 350   3            almnumber=almnumber+1;
 351   3            
 352   3            tv5 = XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)];
 353   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3
             -)+4].ucState)
 354   3            { //如果TUAIS,TULOP,LPUNEQ之一为"1" 则向上插VC12=AIS,LPRDI,向下插AIS
 355   4                if((tv5 & RDI_CNF) != RDI_CNF)
 356   4                  XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 | RDI_CNF;
 357   4            }
 358   3            else
 359   3            {
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 7   

 360   4              if((tv5 & RDI_CNF) == RDI_CNF)
 361   4                XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 & (~RDI_CNF);
 362   4            }
 363   3          }
 364   2        }
 365   1      
 366   1        for(i=0;i<(LINENUM-1);i++)
 367   1        {
 368   2          m=i/21;
 369   2          n=i%21;
 370   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 371   2          // 获取N2 和 K4 值
 372   2          //TODO: get N2
 373   2          //g_ucState[204+2*i]=XBYTE[WGS21891+0x0100+0x10*n+0x0C]; 
 374   2          g_ucState[205+2*i]=XBYTE[sw1021Chip + RX_K4_REG(A_BUS_BASE,n)];
 375   2          
 376   2          
 377   2          mi=i/8;
 378   2          ni=i%8;
 379   2          if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 380   2            g_ucState[330+mi]&=(~(0x01<<ni));
 381   2      
 382   2          else
 383   2            g_ucState[330+mi]|=(0x01<<ni);    
 384   2      
 385   2          //  tv5=XBYTE[WGS21891+0x0100+0x10*n+0x00];
 386   2      
 387   2        }
 388   1      
 389   1         
 390   1      
 391   1        if(TUXAB) g_ucState[77]=0;
 392   1        else g_ucState[77]=1;
 393   1                           
 394   1             
 395   1        if((WP==0) && (TUSWTI==0))   //保护盘位时,如果没有倒换ACT灯慢闪//     
 396   1        {
 397   2          g_ucState[76]=0;
 398   2          g_LampEn=0;        
 399   2          if(g_stuSysClock.ucSecond%2==0) ACT=ON;
 400   2          else ACT=OFF;
 401   2          for(i=0;i<(LINENUM-1);i++)
 402   2          {
 403   3            g_ucLineMask[i]=1;
 404   3            g_ucState[141+i]=1;
 405   3          }
 406   2        }
 407   1        else if(g_ucState[76]==0)
 408   1        {                           
 409   2          for(i=0;i<(LINENUM-1);i++)
 410   2          {
 411   3            if((g_ucConfData[64+i]==0)||(g_ucConfData[137+i]==01))
 412   3            {    
 413   4              g_ucLineMask[i]=1;
 414   4              g_ucState[141+i]=1;  
 415   4            }   
 416   3            else
 417   3            {
 418   4              g_ucLineMask[i]=0;  
 419   4              g_ucState[141+i]=0;
 420   4            }
 421   3          }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 8   

 422   2          g_ucState[76]=1;     
 423   2          g_LampEn=1;
 424   2          WROUTPORT;           
 425   2        }
 426   1             
 427   1        UasClear();
 428   1      
 429   1      
 430   1        if(g_AllClrFlag)                //清性能
 431   1        {   
 432   2          g_bClearUas=1; 
 433   2          g_AllClrFlag=0;
 434   2        }
 435   1      
 436   1        if(g_SecondFlag)                   //秒标识，1：进入新的一秒
 437   1        {
 438   2          CalUas(ulSesLmt);           //uas计算        
 439   2      
 440   2          for(i=0; i<(LINENUM-1); i++)
 441   2          {
 442   3            g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];         //bbe_lp性能的采集
 443   3            g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];        //es_lp性能的采集
 444   3            g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];       //ses_lp性能的采集
 445   3            if(g_usiEs[i]>=ulEsLimit) 
 446   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=1;    //curalm[i][8]=es_limit
 447   3            else 
 448   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=0;
 449   3            // if(g_usiSes[i]>=ulSesLimit) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;    //curalm[i][9]=ses_limit
 450   3            // else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 451   3            g_stuPm[i*PMTYPENUM+5].Value.usint=g_usiUas[i];             //UAS_LP性能的采集
 452   3            g_stuPm[i*PMTYPENUM+6].Value.usint=g_usiCses[i];            //cses_lp性能的采集
 453   3      
 454   3      
 455   3            /******************************************************************************/
 456   3            if(g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3)+1].ucState)
 457   3            {
 458   4              g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 459   4              BIP[i]=0;
 460   4            }
 461   3            else
 462   3            {
 463   4              BIP_2_1S[i]=BIP[i];
 464   4              BIP_2_1000S[i]+=BIP[i];  
 465   4              BIP[i]=0;
 466   4              switch(g_ucConfData[129])
 467   4              {
 468   5                case 0x04:
 469   5                if(BIP_2_1S[i]>=217) 
 470   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 471   5                else if(BIP_2_1S[i]<=23) 
 472   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 473   5                break;
 474   5      
 475   5                case 0x05:
 476   5                if(BIP_2_1S[i]>=22) 
 477   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 478   5                else if(BIP_2_1S[i]<=3) 
 479   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 480   5                break;
 481   5      
 482   5                case 0x06:
 483   5      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 9   

 484   5      
 485   5                if((N1000[i]>=10)&&(N1000[i]<100))
 486   5                {
 487   6                  if(BIP_2_1000S[i]>=22) 
 488   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 489   6                  else if(BIP_2_1000S[i]<=3) 
 490   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 491   6                  N1000[i]=0;
 492   6                  BIP_2_1000S[i]=0;
 493   6                }
 494   5                else N1000[i]++;
 495   5      
 496   5                break;
 497   5      
 498   5                case 0x07:
 499   5      
 500   5      
 501   5                if((N1000[i]>=100)&&(N1000[i]<1000))
 502   5                {
 503   6                  if(BIP_2_1000S[i]>=22) 
 504   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 505   6                  else if(BIP_2_1000S[i]<=3) 
 506   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 507   6                  N1000[i]=0;
 508   6                  BIP_2_1000S[i]=0;
 509   6                }
 510   5                else N1000[i]++;
 511   5                break;
 512   5      
 513   5                case 0x08:
 514   5      
 515   5      
 516   5                if(N1000[i]>=1000)
 517   5                {
 518   6                  if(BIP_2_1000S[i]>=22) 
 519   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 520   6                  else if(BIP_2_1000S[i]<=3) 
 521   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 522   6                  N1000[i]=0;
 523   6                  BIP_2_1000S[i]=0;
 524   6                }
 525   5                else 
 526   5                  N1000[i]++;
 527   5                break;
 528   5              }
 529   4            }
 530   3      
 531   3          /********************************************************************************/
 532   3      
 533   3          }
 534   2      
 535   2          g_SecondFlag=0;      //秒标识清?
 536   2      
 537   2        }     
 538   1      
 539   1        //IO8=1;
 540   1        // WRHIO;
 541   1        //RDHIO;    
 542   1        //IO9=1;
 543   1        // WRHIO;
 544   1        //RDHIO;
 545   1        //IO10=1;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 10  

 546   1        // WRHIO;
 547   1        //RDHIO;
 548   1        //IO11=1;
 549   1        // WRHIO;
 550   1        //RDHIO;
 551   1        //IO12=1;
 552   1        // WRHIO;
 553   1        RDHIO;
 554   1      
 555   1         
 556   1             
 557   1        if(ADCLK||(P2V5==0)||(first_conf==0)) 
 558   1          TUALMO=1; //如果工作支路中全部有告警或2.5V//
 559   1        else 
 560   1          TUALMO=0; //电源有告警或下配置前TUALMO=1,否则TUALMO=0//
 561   1        if((P5VI1==0)&&(DZBI1==0)) 
 562   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=1;
 563   1        else    
 564   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=0;               
 565   1        if((P5VI2==0)&&(DZBI2==0)) 
 566   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=1;
 567   1        else    
 568   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=0;       
 569   1        if(P2V5==0) 
 570   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=1;
 571   1        else    
 572   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=0;                     
 573   1       
 574   1      }
 575          
 576          /*****************************************************************
 577          ** 函数名:USERFUN
 578          ** 输　入: 无
 579          ** 输　出: 无
 580          ** 功能描述：用户实时处理函数，10毫秒被调用一次
 581          ** 全局变量：无
 582          ** 调用模块：无
 583          ** 作　者：翁益晖
 584          ** 日　期：2002.5.25
 585          ** 修　改：
 586          ** 日　期：
 587          ** 版  本：1.0
 588          ****************************************************************/
 589          void UserFunc() using 1
 590          {
 591   1        int i,j;
 592   1        int tmp;
 593   1        unsigned int chip  = SW1021;
 594   1        static int docnt = 0;
 595   1        if(g_haveTux){
 596   2          if(docnt > 10){
 597   3            docnt = 0;
 598   3            g_haveTux = 0;
 599   3          }
 600   2          for(i=0; i<CHIPS_ON_BOARD; i++){
 601   3            for(j=0; j< 21; j++){
 602   4              tmp = XBYTE[chip+PORT_E1_ALARM_REG(j)];
 603   4              if((tmp & RFFERR) == 0){
 604   5                continue;
 605   5              }else{
 606   5                //XBYTE[SW1021_CHIP_ADDR(k) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
 607   5                XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 11  

 608   5                XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
 609   5                
 610   5                XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
 611   5                XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
 612   5                
 613   5                XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
 614   5                XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
 615   5              
 616   5                g_haveTux = 0;
 617   5                docnt = 0;
 618   5                return;
 619   5              }
 620   4            }
 621   3            chip+=0x1000;
 622   3          }
 623   2          docnt++;
 624   2        }
 625   1        
 626   1        return;
 627   1      }
 628          
 629          
 630          //static void ChecktuxAB (void) interrupt 9 using 3
 631          static void ChecktuxAB (void) interrupt 9
 632          {
 633   1      
 634   1        EX3 = 0;
 635   1        EXIF &= 0xDF;
 636   1        g_haveTux = 1;
 637   1      
 638   1      
 639   1        EX3 = 1;
 640   1        return;
 641   1      }
 642          
 643          
 644          /*****************************************************************
 645          ** 函数名:CONF_SET
 646          ** 输　入: 无
 647          ** 输　出: 无
 648          ** 功能描述：单盘配置
 649          ** 全局变量：无
 650          ** 调用模块：无
 651          ** 作　者：caijun.Li
 652          ** 日　期：2016.3.19
 653          ** 修　改：
 654          ** 日　期：
 655          ** 版  本：1.0
 656          ****************************************************************/
 657          void ConfSet(void)
 658          {
 659   1          /*Process ALMMASK*/
 660   1          /*Process PMMASK*/
 661   1        unsigned char i,j,ilong,m,n,temp;
 662   1      
 663   1        g_ucState[69]=g_ucConfData[5];
 664   1        g_ucState[70]=g_ucConfData[6];
 665   1        g_ucState[71]=g_ucConfData[7];
 666   1        g_ucState[72]=g_ucConfData[8];
 667   1        g_ucState[73]=g_ucConfData[9];
 668   1        g_ucState[74]=g_ucConfData[10];
 669   1        g_ucState[75]=g_ucConfData[11];
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 12  

 670   1        for(i=0;i<(LINENUM-1);i++){
 671   2          m=i/21;
 672   2          n=i%21;
 673   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 674   2        
 675   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 676   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 677   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 678   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 679   2      
 680   2          if(g_ucConfData[64+i]==0){  // 支路关闭
 681   3            // 上下话强发AIS
 682   3            //XBYTE[sw1021Chip + TX_CTRL_REG(B_BUS_BASE,n)] = AIS_EN; 
 683   3            temp = XBYTE[sw1021Chip + PORT_CFG_REG(n)];
 684   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = temp | TAISEN | RAISEN; 
 685   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = 0x00;
 686   3                  
 687   3            g_ucState[78+i]=0;     
 688   3            g_ucLineMask[i]=1;
 689   3            g_ucState[141+i]=1;
 690   3          }else{  // 支路打开
 691   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = A_UP_DOWN | RnEN;
 692   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = (0x02 << 1);  // 注意信号标记值得配置
 693   3            if(g_ucState[78+i]==0)//刚打开支路开关时插伪随机码
 694   3            {
 695   4              //TODO: 启动误码计数器
 696   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 697   4              Delay(5);
 698   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= ~(PRBSEN | PRBST);
 699   4              g_ucState[78+i]=1;
 700   4              g_ucLineMask[i]=0; 
 701   4              g_ucState[141+i]=0;
 702   4            }         
 703   3          }
 704   2          XBYTE[sw1021Chip + TX_K4_REG(A_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 705   2          XBYTE[sw1021Chip + TX_K4_REG(B_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 706   2          // TODO: N2 发
 707   2          //XBYTE[WGS21891+0x0100+0x10*n+0x01]=g_ucConfData[263+4*i];                 // N2 发
 708   2        
 709   2        #ifdef AIS_CONDITIONS_AUTO
                  if((g_ucConfData[2531] & 0x80)){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }else{
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }
                  if(g_ucConfData[2531] & 0x40){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= UNEQAISE;
                  }
                  if(g_ucConfData[2531] & 0x20){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= PLMAISE;
                  }
                #endif
 722   2        
 723   2          // J2 发 和 期望收
 724   2          for(j=0;j<16;j++)
 725   2          {
 726   3            if(j==0) temp=0x80;
 727   3            else temp=0;
 728   3            
 729   3            // A 
 730   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 0);
 731   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 0);
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 13  

 732   3            // B
 733   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 1);
 734   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 1);
 735   3          }
 736   2          
 737   2          if(g_ucConfData[137+i]==0)   //confdata[137+i]==0不屏蔽支路i告警/否则屏蔽支路i告警//
 738   2          {
 739   3            g_ucLineMask[i]=0;
 740   3            g_ucState[141+i]=0;
 741   3          }
 742   2          else
 743   2          {
 744   3            g_ucLineMask[i]=1;
 745   3            g_ucState[141+i]=1;
 746   3          }
 747   2        //if(g_ucConfData[200+i]==0)     //confdata[200+i]==1支路i装载/否则不装载//
 748   2        //XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x00;
 749   2        // else  XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x04;
 750   2      
 751   2        }
 752   1      
 753   1      
 754   1      
 755   1        for(j=0;j<ALMTYPENUM;j++) 
 756   1        {
 757   2           
 758   2           for(ilong=29;ilong<(29+ALMTYPENUM);ilong++)
 759   2           {    
 760   3              if(g_ucConfData[ilong]==g_ucAlmCode[j])   //从网管设告警屏蔽//
 761   3              {
 762   4               g_ucAlmMask[j]=1;                              
 763   4               break;     
 764   4              }
 765   3              else
 766   3              g_ucAlmMask[j]=0;
 767   3      
 768   3           }
 769   2        }      
 770   1                          
 771   1        for(j=0;j<PMTYPENUM;j++)  
 772   1        {
 773   2      
 774   2          for(ilong=54;ilong<(54+PMTYPENUM);ilong++)
 775   2          {   
 776   3            if(g_ucConfData[ilong]==g_ucPmCode[j])   //从网管设性能屏蔽//
 777   3            {
 778   4              g_ucPmMask[j]=1;                              
 779   4              break;    
 780   4            }
 781   3            else
 782   3              g_ucPmMask[j]=0;
 783   3          }
 784   2        }        
 785   1      
 786   1        ulEsLimit=256*g_ucConfData[131]+g_ucConfData[132];    //从网管设ulEsLimit门限//
 787   1        ulSesLimit=256*g_ucConfData[134]+g_ucConfData[135];   //从网管设ulSesLimit门限//
 788   1      
 789   1      
 790   1        //if((g_ucConfData[136]==0)&&TUALMO&&WP) TUALMO=0;  //IO2=TUALMO  confdata[108]=盘保护模式不保护
 791   1      
 792   1      
 793   1        // g_ucConfChange=0;                          
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 14  

 794   1              
 795   1      
 796   1        if(first_conf==0) first_conf=1; 
 797   1      }
 798          
 799          
 800          /*****************************************************************
 801          ** 函数名:UserHdlc
 802          ** 输　入: 无
 803          ** 输　出: 无
 804          ** 功能描述：单盘特殊命令处理
 805          ** 全局变量：无
 806          ** 调用模块：无
 807          ** 作　者：caijun.Li
 808          ** 日　期：2016.3.19
 809          ** 修　改：
 810          ** 日　期：
 811          ** 版  本：1.0
 812          ****************************************************************/
 813          void UserHdlc(void)
 814          {
 815   1        unsigned char i,m,n,temp;
 816   1        unsigned int addr;
 817   1      
 818   1        if (g_ucHdlcBuf[CMD_TYPE]==COMM_CATA)
 819   1        {
 820   2          if (g_ucHdlcBuf[CMD_CODE]==RTRV_OCONF)
 821   2          {
 822   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;
 823   3          }
 824   2          else if (g_ucHdlcBuf[CMD_CODE]==SET_OCONF)
 825   2          {
 826   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;                                               
 827   3          }
 828   2        }
 829   1      
 830   1      
 831   1        switch(g_ucHdlcBuf[5])
 832   1        {
 833   2          case 0x00:    /*SET_LOOP*/
 834   2            if(g_ucHdlcBuf[6]==0x34)
 835   2            { // 设备环回
 836   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 837   3                g_ucHdlcBuf[10]=0x80; 
 838   3              else                
 839   3                for(i=0;i<(g_usRxDataLen);i++)
 840   3                {
 841   4                  temp=g_ucHdlcBuf[14+i]-1;
 842   4                  m=temp/21;
 843   4                  n=temp%21;
 844   4      
 845   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 846   4                  if(g_ucHdlcBuf[7]==0x01){
 847   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
 848   5                  }else{
 849   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
 850   5                  }
 851   4                  g_ucHdlcBuf[10]=0x00;
 852   4                }
 853   3            }
 854   2            else if(g_ucHdlcBuf[6]==0x33)       /*SET_LOOPL*/
 855   2            { // 线路环回 
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 15  

 856   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 857   3                g_ucHdlcBuf[10]=0x80; 
 858   3              else                  
 859   3                for(i=0;i<(g_usRxDataLen);i++)
 860   3                {
 861   4                  temp=g_ucHdlcBuf[14+i]-1;
 862   4                  m=temp/21;
 863   4                  n=temp%21;
 864   4                  
 865   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 866   4                  if(g_ucHdlcBuf[7]==0x01){
 867   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= E1LBK;
 868   5                  }else{
 869   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~E1LBK);
 870   5                  }
 871   4                  g_ucHdlcBuf[10]=0x00;
 872   4                }
 873   3            }
 874   2      
 875   2            break;
 876   2      
 877   2          case 0x77:                /**透明帧命令**/
 878   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];  // commbuf[14]，commbuf[15]所存放 的 地址
 879   2            g_ucHdlcBuf[10]=0x00;
 880   2            g_ucHdlcBuf[11]=0x00;
 881   2            g_ucHdlcBuf[12]=0x00;
 882   2            g_ucHdlcBuf[13]=0x11;
 883   2            //读16个字节//  addr 地址开始读取16个字节数据//
 884   2            for(i=0;i<16;i++) 
 885   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; 
 886   2            g_ucHdlcBuf[30]=P1;
 887   2            break;                   
 888   2          
 889   2          case 0x88:
 890   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];
 891   2            XBYTE[addr]=g_ucHdlcBuf[16];       //将commbuf[16]存放的数据送入commbuf[14]，//
 892   2            g_ucHdlcBuf[10]=0x00;              //commbuf[15]所存放的WGS21891的地址单元中//
 893   2            g_ucHdlcBuf[11]=0x00;
 894   2            g_ucHdlcBuf[12]=0x00;
 895   2            g_ucHdlcBuf[13]=0x10;              //读16个字节//
 896   2            for(i=0;i<16;i++) 
 897   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; //从commbuf[14]，commbuf[15]的地址开始读取16个字节数据//
 898   2            break;
 899   2      
 900   2          case 0X99:
 901   2            while(1)
 902   2            {;}
 903   2            if((g_usRxDataLen==0)||(g_usRxDataLen>63)) 
 904   2              g_ucHdlcBuf[10]=0x80; 
 905   2            else                
 906   2              for(i=0;i<(g_usRxDataLen);i++)
 907   2              {
 908   3                temp=g_ucHdlcBuf[14+i]-1;
 909   3                m=temp/21;
 910   3                n=temp%21;
 911   3                sw1021Chip = SW1021_CHIP_ADDR(m);
 912   3                          
 913   3                g_ucHdlcBuf[17]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
 914   3                g_ucHdlcBuf[18]=0xbb;
 915   3                
 916   3                if(g_ucHdlcBuf[7]==0x01)
 917   3                {
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 16  

 918   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
 919   4                  if(n<8)
 920   4                    g_ucHdlcBuf[18]=0xff;
 921   4                }
 922   3                else
 923   3                {
 924   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
 925   4                }
 926   3                    
 927   3              }
 928   2            g_ucHdlcBuf[10]=0x00;
 929   2            g_ucHdlcBuf[13]=6;
 930   2            g_ucHdlcBuf[14]=0xaa;
 931   2            g_ucHdlcBuf[15]=m;
 932   2            g_ucHdlcBuf[16]=n;
 933   2            g_ucHdlcBuf[19]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
 934   2            
 935   2            break;
 936   2            
 937   2      
 938   2        }
 939   1      
 940   1      }
 941          
 942          /*****************************************************************
 943          ** 函数名:SELF_CONF
 944          ** 输　入: 无
 945          ** 输　出: 无
 946          ** 功能描述：单盘上电默认配置
 947          ** 全局变量：g_ucConfData[]
 948          ** 调用模块：无
 949          ** 作　者：翁益晖
 950          ** 日　期：2002.5.25
 951          ** 修　改：
 952          ** 日　期：
 953          ** 版  本：1.0
 954          ** 注  意：所有告警和性能的初始化需安线路号顺序
 955          ****************************************************************/
 956          void SelfConf()
 957          {
 958   1      
 959   1        unsigned int i,j;
 960   1        char ctt[18];
 961   1        unsigned char ucii;
 962   1        //  first_conf=0;
 963   1        g_ucConfData[22]=BOARDCODE;/*BDINF5*/
 964   1        g_ucConfData[0]=0xfe;
 965   1      
 966   1      
 967   1        sprintf(ctt,BoardSn);
 968   1        for(ucii=0;ucii<15;ucii++) g_ucState[ucii]=ctt[ucii];  /*盘号*/
 969   1      
 970   1        sprintf(ctt,PcbSn);   
 971   1        for(ucii=0;ucii<15;ucii++) g_ucState[15+ucii]=ctt[ucii]; /*板号*/
 972   1      
 973   1        sprintf(ctt,PcbTime);   
 974   1        for(ucii=0;ucii<10;ucii++) g_ucState[30+ucii]=ctt[ucii]; /*制板时间*/
 975   1      
 976   1        for(ucii=0;ucii<18;ucii++) ctt[ucii]=0;    /*版本号buf清零*/
 977   1        //sprintf(ctt,"R170609R1B/01F    "); 
 978   1        //for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
 979   1        sprintf(ctt,BoardSoftVer); 
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 17  

 980   1        for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
 981   1        sprintf(ctt,__DATE__);   
 982   1        for(ucii=0;ucii<11;ucii++) g_ucState[58+ucii]=ctt[ucii]; /*编程时间*/
 983   1      
 984   1        //g_ucState[69]=0x07;
 985   1        //g_ucState[70]=0xD1;
 986   1        //g_ucState[71]=0x06;
 987   1        //g_ucState[72]=0x01;
 988   1        //g_ucState[73]=0x08;
 989   1        //g_ucState[74]=0x00;
 990   1        //g_ucState[75]=0x00;
 991   1        g_ucState[76]=0x01;
 992   1        //g_ucState[77]=0x01;
 993   1      
 994   1      
 995   1      
 996   1        for(i=0;i<LINENUM;i++)           /*linecode=1..63*/
 997   1          g_ucLineCode[i]=i+1;
 998   1        for(i=0;i<LINENUM;i++)
 999   1        {
1000   2          g_ucLineMask[i]=0;          
1001   2      
1002   2        }
1003   1      
1004   1      
1005   1      
1006   1        /*for(i=0;i<LINENUM;i++)
1007   1        for(j=0;j<PMNUM;j++) linepmmask[i][j]=0;*/         
1008   1      
1009   1      
1010   1        actnumber=63;             
1011   1        almnumber=0;     
1012   1      
1013   1        ulEsLimit=0xff;
1014   1        ulSesLimit=0xff;
1015   1      
1016   1        g_ucAlmCode[0]=0x03;                        /*PPI_LOS*/
1017   1        g_ucAlmCode[1]=0x27;                        /*TU_LOP*/
1018   1        g_ucAlmCode[2]=0x22;                        /*LP_SLM*/
1019   1        g_ucAlmCode[3]=0x20;                        /*LP_RDI*/
1020   1        g_ucAlmCode[4]=0x24;                        /*LP_UNEQ*/
1021   1        //g_ucAlmCode[8]=0x04;                        /*PPI_AIS*/
1022   1        g_ucAlmCode[5]=0x02;                        /*TU_AIS*/
1023   1      #ifdef NEED_LP_RFI
                g_ucAlmCode[15]=0x0c;                        /*LP_RFI*/
              #endif
1026   1        g_ucAlmCode[7]=0x51;                        /*ES_LIMIT*/
1027   1        //g_ucAlmCode[8]=0x52;      /*SES _LIMIT*/
1028   1        g_ucAlmCode[9]=0x28;                       /*LP_TIM*/
1029   1        g_ucAlmCode[10]=0x4f;                       /*LOOPL*/
1030   1        g_ucAlmCode[11]=0x55;     /*LOOP*/
1031   1        g_ucAlmCode[12]=0x01;                       //2V5电源故障告警//
1032   1        g_ucAlmCode[13]=0x05;                       //5VI1电源故障告警//
1033   1        g_ucAlmCode[14]=0x06;                       //5VI2电源故障告警//
1034   1        g_ucAlmCode[6]=0x07;                 //trafic-onload//
1035   1        g_ucAlmCode[8]=0x08;                /*LP_SD*/
1036   1      
1037   1        g_ucPmCode[0]=0x08;                   /*BBE_LP*/
1038   1        g_ucPmCode[1]=0x02;                   /*ES_LP*/
1039   1        g_ucPmCode[2]=0x03;                   /*SES_LP*/
1040   1        g_ucPmCode[3]=0x07;                   /*REI_LP*/
1041   1        g_ucPmCode[4]=0x0b;                   /*HDB3CV*/
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 18  

1042   1        //g_ucPmCode[5]=0x06;                 /*UAS_LP*/
1043   1        g_ucPmCode[5]=0x0c;                   /*UAS_LP*/
1044   1        g_ucPmCode[6]=0xa2;                   /*CSES_LP*/
1045   1      
1046   1        g_ucAlmType[0]=0;   /*almtype：0急告；4非急告；8状态量*/
1047   1        g_ucAlmType[1]=0;
1048   1        g_ucAlmType[2]=0;
1049   1        g_ucAlmType[3]=4;
1050   1        g_ucAlmType[4]=4;
1051   1        g_ucAlmType[5]=4;
1052   1        g_ucAlmType[6]=8;
1053   1        g_ucAlmType[7]=4;
1054   1        g_ucAlmType[8]=4;
1055   1        g_ucAlmType[9]=0;      /*LP_TIM*/
1056   1        g_ucAlmType[10]=8;         
1057   1        g_ucAlmType[11]=8;  
1058   1        g_ucAlmType[12]=0;
1059   1        g_ucAlmType[13]=0;
1060   1        g_ucAlmType[14]=0;
1061   1        
1062   1      #ifdef NEED_LP_RFI
                g_ucAlmType[15]=4;
              #endif
1065   1      
1066   1        for(j=0;j<(LINENUM-1);j++)
1067   1        {
1068   2          for(i=0;i<(ALMTYPENUM-3);i++)
1069   2          {
1070   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucLineIndex=j;
1071   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucAlmIndex=i;
1072   3          }
1073   2        }
1074   1      
1075   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucLineIndex=63;
1076   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucAlmIndex=12;
1077   1      
1078   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucLineIndex=63;
1079   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucAlmIndex=13;
1080   1      
1081   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucLineIndex=63;
1082   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucAlmIndex=14;
1083   1      
1084   1      
1085   1        for(j=0;j<(LINENUM-1);j++)
1086   1        {
1087   2          for(i=0;i<PMTYPENUM;i++)
1088   2          {
1089   3            g_stuPm[j*PMTYPENUM+i].ucLineIndex=j;
1090   3            g_stuPm[j*PMTYPENUM+i].ucPmIndex=i;
1091   3          }
1092   2        }
1093   1      
1094   1        for(i=0;i<UASNUM;i++)
1095   1        {
1096   2          g_liError1s[i].ulDatlong=0;
1097   2          ulSesLmt[i]=700; //若某一秒内误码个数大于等于ulSesLmt[i]时,该秒是严重误码秒//
1098   2        }                  
1099   1      }
1100          
1101          
1102          
1103          /*****************************************************************
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 19  

1104          ** 函数名:InitioSw1021
1105          ** 输　入: 无
1106          ** 输　出: 无
1107          ** 功能描述：SW1021初始化
1108          ** 全局变量：
1109          ** 调用模块：
1110          ** 作　者：caijun.Li
1111          ** 日　期：2016.3.18
1112          ** 修　改：
1113          ** 日　期：
1114          ** 版  本：1.0
1115          ****************************************************************/
1116          void InitioSw1021()
1117          {
1118   1      
1119   1        unsigned int i,j;
1120   1        unsigned char m,n;
1121   1        first_conf=0;
1122   1      
1123   1        for(i=0; i<CHIPS_ON_BOARD; i++)
1124   1        {
1125   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
1126   2          Delay(1);
1127   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = RST_CANCLE;
1128   2          
1129   2          // TODO: 并行总线时钟选择
1130   2          // SW1021只支持19.44Mbit/s 的传输速率
1131   2          
1132   2          
1133   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时  + V5 期望
             - 0x02
1134   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时
1135   2          
1136   2          XBYTE[SW1021_CHIP_ADDR(i) + SOMESET_REG(A_BUS_BASE)] = BLKBIP_BLOCK;  // BIP-2按块进行校验并计数
1137   2          
1138   2          XBYTE[SW1021_CHIP_ADDR(i) + RDI_RFI_CTRL_REG(A_BUS_BASE)] = MREI_AUTO | AISV_RDIEN | LOPV_RDIEN | LOMV_R
             -DIEN | UNEQV_RDIEN | PLMV_RDIEN | RTIMV_RDIEN | RTIUV_RDIEN;
1139   2          
1140   2          // 上下话数据总线均选择偶校验
1141   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)] = UP_DELAY_2;
1142   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)] = UP_DELAY_2;   
1143   2          
1144   2          // 21个端口从A总线上下话, 使用 +- HDB3模式
1145   2          for(j=0; j<21; j++){
1146   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)] = A_UP_DOWN | RnEN;
1147   3            // 关闭线路环回和系统环回
1148   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_TEST_REG(j)] = 0x00;
1149   3            // TODO: 上下话交叉状态选择 ： 不交叉
1150   3            
1151   3            // TODO: TU通道LOP\AIS告警检测设置： EN_TUAIS  使能TU-AIS 中断
1152   3            //                             EN_TULOP  使能TU-LOP 中断
1153   3            //                             
1154   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_E1_ALARM_INTERRPUT_MASK_REG(j)] = E1AISE | E1LOCE; //??
1155   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(A_BUS_BASE,j)] = LOPE | AISE;  
1156   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(B_BUS_BASE,j)] = LOPE | AISE;  
1157   3            //TODO： 读清中断指示
1158   3            
1159   3            //TODO: 不启动随机码测试； 启动误码计数
1160   3            
1161   3            //TODO: 上话V5-TX2 设置 LP-REI
1162   3            XBYTE[SW1021_CHIP_ADDR(i) + TX_V5_REG(A_BUS_BASE,j)] = (0x02 << 1);
1163   3            
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 20  

1164   3            //TODO： 上下话通道号编码
1165   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1166   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1167   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1168   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1169   3            
1170   3            
1171   3          }
1172   2          // TODO:上下话时钟数据同相
1173   2          XBYTE[SW1021_CHIP_ADDR(i) + E1_CTRL_REG] = TRZSEL | RRZSEL;
1174   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_IF_CLK_REG] = 0x00;
1175   2      
1176   2        }
1177   1        
1178   1        // 填充所有支路的J2字节（初始化清0）
1179   1        for(i=0;i<63;i++)            
1180   1        {
1181   2          m=i/21;
1182   2          n=i%21;
1183   2          for(j=0;j<16;j++)
1184   2          {
1185   3            if(j==0)
1186   3            { // A 
1187   4              writeTxJ2(m, j, slot[i],  0x80, 0);
1188   4              writeExpectJ2(m, j, slot[i],  0x80, 0);
1189   4              // B
1190   4              writeTxJ2(m, j, slot[i],  0x80, 1);
1191   4              writeExpectJ2(m, j, slot[i],  0x80, 1);           
1192   4            }
1193   3            else
1194   3            {
1195   4              // A 
1196   4              writeTxJ2(m, j, slot[i],  0x00, 0);
1197   4              writeExpectJ2(m, j, slot[i],  0x00, 0);
1198   4              // B
1199   4              writeTxJ2(m, j, slot[i],  0x00, 1);
1200   4              writeExpectJ2(m, j, slot[i],  0x00, 1); 
1201   4            }
1202   3          }
1203   2        }
1204   1      
1205   1         IO8=1;
1206   1         IO9=1;
1207   1         IO10=1;
1208   1         IO11=1;
1209   1         IO12=1;
1210   1         WRHIO;
1211   1      
1212   1      }
1213          /*****************************************************************
1214          ** 函数名:checkSW1021Init
1215          ** 输　入: 无
1216          ** 输　出: 无
1217          ** 功能描述：检查SW1021初始化成功
1218          ** 全局变量：
1219          ** 调用模块：
1220          ** 作　者：caijun.Li
1221          ** 日　期：2016.3.18
1222          ** 修　改：
1223          ** 日　期：
1224          ** 版  本：1.0
1225          ****************************************************************/
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 21  

1226          static int checkSW1021Init(void)
1227          {
1228   1        int ret = 0;
1229   1        int i,j;
1230   1        unsigned int reg;
1231   1        for(i=0;i<CHIPS_ON_BOARD;i++)
1232   1        {
1233   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)];
1234   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1235   3            ret = -1;
1236   3            break;
1237   3          }
1238   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)];
1239   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1240   3            ret = -1;
1241   3            break;
1242   3          }
1243   2          
1244   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)];
1245   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1246   3            ret = -1;
1247   3            break;
1248   3          }
1249   2          
1250   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)];
1251   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1252   3            ret = -1;
1253   3            break;
1254   3          }
1255   2          
1256   2          for(j=0; j<21; j++){
1257   3            reg = XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)];
1258   3            if((reg & (A_UP_DOWN | RnEN)) != (A_UP_DOWN | RnEN)){
1259   4              ret = -1;
1260   4              goto quit;
1261   4            }
1262   3          }
1263   2      
1264   2        }
1265   1      quit:
1266   1        return ret;
1267   1      }
1268          
1269          /*****************************************************************
1270          ** 函数名:MAIN
1271          ** 输　入: 无
1272          ** 输　出: 无
1273          ** 功能描述：主函数
1274          ** 全局变量：g_QuarterFlag
1275          ** 调用模块：SelfConf(),GetData(),ProcHisData(),Debug();
1276          ** 作　者：caijun.Li
1277          ** 日　期：2016.3.18
1278          ** 修　改：
1279          ** 日　期：
1280          ** 版  本：1.0
1281          ****************************************************************/
1282          void main()
1283          {   
1284   1        unsigned char i;  
1285   1        int ret = 0;
1286   1        //Delay(50);
1287   1      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 22  

1288   1        SelfConf(); 
1289   1        
1290   1        ret = checkSW1021Init();
1291   1        if(ret != 0)
1292   1          InitioSw1021();
1293   1        
1294   1        // 使能外部中断3
1295   1        EX3 = 1;
1296   1        PX3 = 0;  // 低优先级
1297   1      
1298   1        while (1)
1299   1        {
1300   2          #ifdef SKIP_DEBUG_CHECK
1301   2            #ifdef NEED_LP_RFI        
                        XBYTE[0x7fe5] = 1;
                    #else
1304   2              //  XBYTE[0x7b74] = 1;
1305   2                XBYTE[0x7b79] = 1;
1306   2            #endif
1307   2          #endif
1308   2          
1309   2          //ACT = ~ACT;
1310   2          //RED = ~RED;
1311   2          //YELLOW = ~YELLOW;
1312   2              
1313   2          
1314   2          ret = checkSW1021Init();
1315   2          if(ret != 0){ 
1316   3            SelfConf(); 
1317   3            InitioSw1021();
1318   3            ConfSet();  
1319   3          }
1320   2        
1321   2          GetData();
1322   2          ProcAlmData();  
1323   2      
1324   2          if (g_QuarterFlag) 
1325   2          {
1326   3            UasQuarter();
1327   3            for(i=0;i<LINENUM;i++)
1328   3            {
1329   4              g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];
1330   4              g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];
1331   4              g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];
1332   4            }
1333   3            ProcHisData();  //将当前告警和性能数据存为历史数据//
1334   3            g_QuarterFlag=0;
1335   3          }
1336   2          
1337   2          Debug();
1338   2        }
1339   1      }
1340          
*** WARNING C294 IN LINE 903 OF GF2488-01F1-E1-RST.C: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  11625    ----
   CONSTANT SIZE    =    250    ----
   XDATA SIZE       =  22241      92
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/17/2016 11:14:00 PAGE 23  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
