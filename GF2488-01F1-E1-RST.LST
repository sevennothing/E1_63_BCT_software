C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE GF2488_01F1_E1_RST
OBJECT MODULE PLACED IN GF2488-01F1-E1-RST.OBJ
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE GF2488-01F1-E1-RST.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND T
                    -ABS(2)

line level    source

   1          /******************************************************************
   2          ** 文件名：STAND.C
   3          ** Copyright (c) 2002 烽火通信传输产品部BCT软件组
   4          ** 创建人：翁益晖
   5          ** 文件编号：
   6          ** 描　述：标准模版程序
   7          **         
   8          ** 日　期：2002.6.28
   9          ** 修改人：
  10          ** 日　期：
  11          ** 文件编号：
  12          ** 描　述：
  13          **
  14          **
  15          ** 编译器：Keil C51 V5.5 或 MCC68K V4.4
  16          ** 公共库：NewLib9.LIB for Mcs51
  17          **         或 NewLib1.LIB for Mc68302
  18          ** 版  本：1.0
  19          ********************************************************************/
  20          //#define  NEED_LP_RFI   /**  !!! 单盘起不来了  */
  21          //#define AIS_CONDITIONS      /** 与 AIS_CONDITIONS_AUTO 二选一  */
  22          //#define AIS_CONDITIONS_AUTO
  23          //#define SKIP_DEBUG_CHECK
  24          #define PPIAIS_SUPPORT
  25          
  26          #define UASNUM    63        //要计算误码的线路数63//
  27          #define LINENUM   64        /*告警线路数为64*/
  28          #ifdef NEED_LP_RFI
                #define ALMNUM      822     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
                #define ALMTYPENUM      16      /*16种告警类型*/
              #else
  32            #define ALMNUM      759     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
  33            #define ALMTYPENUM      15      /*15种告警类型*/
  34          #endif
  35          
  36          #define PMNUM   441         /*总共63*PMTYPENUM个性能*/
  37          
  38          #define PMTYPENUM       7       /*7种性能类型*/
  39          #define CONFLEN   2560  /*配置数据长度为2560*/
  40          #define STATELEN  338   /*状态数据长度为338*/
  41          #define BOARDCODE 0x96  /*盘代码*/
  42          #define WGS21891A 0xB000
  43          
  44          #define SW1021  0xB000    //TODO：confirm
  45          
  46          #define SW1021_CHIP_ADDR(num)  (SW1021 + 0x1000*(num))
  47          #define CHIPS_ON_BOARD          3
  48          
  49          
  50          #include "commvar9.h"
  51          #include "uasE63.h"
  52          
  53          #include "sw1021.h"
  54          
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 2   

  55          char code SysName[]="GF2488-01F";
  56          char code BoardName[]="E1-63A";
  57          char code BoardSn[]="WKE2.202.202R1A";
  58          char code SoftVer[]="R202202R1A/01F    ";
  59          
  60          char code PcbSn[]="WKE7.201.546R1A";
  61          char code PcbTime[]="2016 05 20";
  62          
  63          char code BoardSoftVer[]="RP0100            ";
  64          
  65          char code SoftDate[]=__DATE__;
  66          char code SoftTime[]=__TIME__;
  67          
  68          extern int sprintf(char *, const char *, ...);
  69          
  70          #define RSTB IO0
  71          #define TUALMO IO2
  72          #define HAPPAN_SWITCH IO4   // 外部中断2,上升沿中断
  73          #define TUXAB IO5 //TUXAB为主备交叉时钟盘XCU有效指示信号,主用XCU有效时TUXAB=0,备用XCU有效TUXAB=1
  74          #define WP IO6     //E1-63A盘在正常槽位时WP=1,在保护槽位时WP=0//
  75          #define TUSWTI IO7 //本盘almnumber大于一定值时,TUALMO=1,XCU盘收到TUALMO=1时,产生TUSWTI=0//
  76          #define P2V5 IO8
  77          #define P5VI1 IO9
  78          #define P5VI2 IO10
  79          #define DZBI1 IO11
  80          #define DZBI2 IO12
  81          
  82          // 仅用于调试（解决全部线路环回缺陷问题）
  83          #define ALERT_LOOPL IO3
  84          
  85          extern unsigned char g_AllClrFlag;
  86          extern unsigned char g_LampEn;
  87          unsigned int ulEsLimit,ulSesLimit;
  88          //unsigned int WGS21891,wgs21891reg0[4],wgs21891reg1[4];
  89          unsigned int sw1021Chip;
  90          unsigned int N1000[63],BIP[63],BIP_2_1S[63],BIP_2_1000S[63];
  91          unsigned char actnumber,almnumber,first_conf;
  92          //unsigned char g_haveTux;
  93          /*
  94          code unsigned char slot[64]={1,22,43,4,25,46,7,
  95          28,49,10,31,52,13,34,
  96          55,16,37,58,19,40,61,
  97          
  98          2,23,44,5,26,47,8,
  99          29,50,11,32,53,14,35,
 100          56,17,38,59,20,41,62,
 101          
 102          3,24,45,6,27,48,9,
 103          30,51,12,33,54,15,36,
 104          57,18,39,60,21,42,63,0};
 105              */
 106          /*
 107          code unsigned char slot[64]={0x00,0x20,0x40,0x01,0x21,0x41,0x02,
 108                               0x22,0x42,0x03,0x23,0x43,0x04,0x24,
 109                               0x44,0x05,0x25,0x45,0x06,0x26,0x46,
 110          
 111                               0x07,0x27,0x47,0x08,0x28,0x48,0x09,
 112                               0x29,0x49,0x0a,0x2a,0x4a,0x0b,0x2b,
 113                               0x4b,0x0c,0x2c,0x4c,0x0d,0x2d,0x4d,
 114          
 115                               0x0e,0x2e,0x4e,0x0f,0x2f,0x4f,0x10,
 116                               0x30,0x50,0x11,0x31,0x51,0x12,0x32,
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 3   

 117                               0x52,0x13,0x33,0x53,0x14,0x34,0x54,
 118                               0
 119                          };    
 120          */
 121          code unsigned char slot[64]={0x00,0x07,0x0e,0x01,0x08,0x0f,0x02,
 122                               0x09,0x10,0x03,0x0a,0x11,0x04,0x0b,
 123                               0x12,0x05,0x0c,0x13,0x06,0x0d,0x14,
 124          
 125                               0x20,0x27,0x2e,0x21,0x28,0x2f,0x22,
 126                               0x29,0x30,0x23,0x2a,0x31,0x24,0x2b,
 127                               0x32,0x25,0x2c,0x33,0x26,0x2d,0x34,
 128          
 129                               0x40,0x47,0x4e,0x41,0x48,0x4f,0x42,
 130                               0x49,0x50,0x43,0x4a,0x51,0x44,0x4b,
 131                               0x52,0x45,0x4c,0x53,0x46,0x4d,0x54,
 132                               0
 133                          };
 134          
 135              
 136          //void do_rst_fifo(int trib);
 137                          
 138          static void writeTxJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 139          {
 140   1        int copOk = 0;
 141   1        int busBase = A_BUS_BASE;
 142   1        int i = 5;
 143   1        if(busB)
 144   1          busBase = B_BUS_BASE;
 145   1        // write  Tx J2 data
 146   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_DATA_REG(busBase)] = j2;
 147   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_WHICH_REG(busBase)] = witchJ2;
 148   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_SLOT_REG(busBase)] = RW_SEL | Slot;
 149   1        while(!copOk){
 150   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_RAM_STATUS_REG(busBase)] & 0x01;
 151   2          i--;
 152   2          if(i == 0)
 153   2            break;
 154   2          //Delay(1);
 155   2        }
 156   1      }
 157          
 158          static void writeExpectJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 159          {
 160   1        int copOk = 0;
 161   1        int busBase = A_BUS_BASE;
 162   1        int i = 5;
 163   1        if(busB) 
 164   1          busBase = B_BUS_BASE;
 165   1        // write  Tx J2 data
 166   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)] = j2;
 167   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = EXPECT_J2 |  witchJ2;
 168   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] = RW_SEL | Slot;
 169   1        while(!copOk){
 170   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 171   2          i--;
 172   2          if(i == 0)
 173   2            break;
 174   2          //Delay(1);
 175   2        }
 176   1      }
 177          
 178          static void readRxJ2(char chip, char witchJ2, char Slot, char *j2, char busB)
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 4   

 179          {
 180   1        int copOk = 0;
 181   1        int busBase = A_BUS_BASE;
 182   1        int i = 5;
 183   1        if(busB) 
 184   1          busBase = B_BUS_BASE;
 185   1        
 186   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = RECEV_J2 |  witchJ2;
 187   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] =  Slot;
 188   1        while(!copOk){
 189   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 190   2          i--;
 191   2          if(i == 0)
 192   2            break;
 193   2          //Delay(1);
 194   2        }
 195   1        if(copOk){
 196   2          *j2 = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)];
 197   2        }else{
 198   2          *j2 = -1;
 199   2        }
 200   1        
 201   1      }
 202          
 203          /*****************************************************************
 204          ** 函数名:GETDATA
 205          ** 输　入: 无
 206          ** 输　出: 无
 207          ** 功能描述：采集单盘告警和性能
 208          ** 全局变量：无
 209          ** 调用模块：无
 210          ** 作　者：翁益晖
 211          ** 日　期：2002.5.25
 212          ** 修　改：
 213          ** 日　期：
 214          ** 版  本：1.0
 215          ****************************************************************/
 216          void GetData()          
 217          {
 218   1        unsigned char i,m,n,mi,ni,tmp,tmpi,ADCLK,PPILOS,TULOP,LPSLM,LPTIM,LPTIU,LPRDI,LPRFI,LPUNEQ,TUAIS,PPIAIS,
 219   1        LOOP,LOOPL,tv5;
 220   1        unsigned int  LPFEBE,HDB3;
 221   1        unsigned char lopCnt = 0;
 222   1        actnumber=0;
 223   1        almnumber=0;
 224   1        sw1021Chip = SW1021;
 225   1        for(i=0;i<(LINENUM-1);i++)
 226   1        {          
 227   2          
 228   2          if(g_ucState[78+i]==0)
 229   2          {
 230   3            g_ucLineMask[i]=1;
 231   3            // ADCLK 告警 (A 路下行时钟告警 )
 232   3            ADCLK=XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC; 
 233   3      
 234   3          }
 235   2          else   
 236   2          {
 237   3            m=i/21;
 238   3            n=i%21;
 239   3            mi=i/8;
 240   3            ni=i%8;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 5   

 241   3            
 242   3            sw1021Chip = SW1021_CHIP_ADDR(m);
 243   3            
 244   3            if(TULOP||TUAIS)
 245   3              g_ucLofFlag[i]=1;      //有TULOP,TUAIS,PPILOS告警之一时上报UAS
 246   3            else
 247   3              g_ucLofFlag[i]=0;
 248   3            
 249   3            actnumber=actnumber+g_ucConfData[64+i];
 250   3            
 251   3            ADCLK = XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC;
 252   3            tmp = XBYTE[sw1021Chip+PORT_E1_ALARM_REG(n)];
 253   3            PPIAIS = tmp & E1AIS;
 254   3            PPILOS = tmp & E1LOS;
 255   3          /*
 256   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 257   3            TULOP = tmp & LOPI;
 258   3            TUAIS = tmp & AISI;
 259   3            LPSLM = tmp & PLMI;
 260   3            LPTIM = tmp & RTIMI;
 261   3            LPTIU = tmp & RTIUI;
 262   3            LPRDI = tmp & RDII;
 263   3            LPRFI = tmp & RFII;
 264   3            LPUNEQ = tmp & UNEQI;
 265   3          */
 266   3            
 267   3            tmpi = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 268   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG(A_BUS_BASE, n)] | tmpi;
 269   3            TULOP = tmp & LOPV;
 270   3            TUAIS = tmp & AISV;
 271   3            LPSLM = tmp & PLMV;
 272   3            LPTIM = tmp & RTIMV;
 273   3            LPTIU = tmp & RTIUV;
 274   3            LPRDI = tmp & RDIV;
 275   3            LPRFI = tmp & RFIV;
 276   3            LPUNEQ = tmp & UNEQV;
 277   3            
 278   3            if(TULOP) lopCnt++;
 279   3            
 280   3          #ifdef AIS_CONDITIONS 
                    /** 方法1： 手动 */
                    //AIS 产生条件 ---add by caijun.Li
                    if(((g_ucConfData[2531] & 0x80) && LPTIM) || ((g_ucConfData[2531] & 0x40) && LPUNEQ ) || ((g_ucConfData
             -[2531] & 0x20) && LPSLM ) /* || ((g_ucConfData[2531] & 0x10) && LPSD )*/ ){
                      // 下插AIS
                      XBYTE[sw1021Chip + PORT_CFG_REG(n)] |= RAISEN;
                    }else{
                      // 停止下插AIS
                      XBYTE[sw1021Chip + PORT_CFG_REG(n)] &= ~RAISEN;
                    }
                      
                  #endif
 292   3            
 293   3            
 294   3            //must be write BIPERR_COUNTER_REG ; see manual
 295   3            XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 296   3            g_liError1s[i].ulDatlong += XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+BIP
             -ERR_COUNTER_REG(A_BUS_BASE, n) + 1] * 256);   // BIP错误计数值
 297   3            //must be write REI_COUNTER_REG ; see manual
 298   3            XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 299   3            LPFEBE = XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BAS
             -E, n) + 1] * 256); //REI(FEBE)计数值
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 6   

 300   3            
 301   3            
 302   3            tmp = XBYTE[sw1021Chip + PORT_TEST_REG(n)]; 
 303   3            LOOP =   tmp & LnLBK;
 304   3            if(ALERT_LOOPL == 0){
 305   4              LOOPL = 1;
 306   4            }else{
 307   4              LOOPL =  tmp & E1LBK;
 308   4            }
 309   3            
 310   3            if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 311   3            {
 312   4              g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;
 313   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)].ucState=1;           
 314   4              else                                              //E1输入口有信号时/// 
 315   4              {
 316   5                if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==1)  //如果还存在PPILOS告警//
 317   5                if(WP==1)                        //非保护盘位时//
 318   5                {
 319   6                  // 向第i通道上话方向插短时间的伪随机码
 320   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 321   6                  g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS//
 322   6          
 323   6                  Delay(10);
 324   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &=  ~(PRBSEN | PRBST); //停插伪随机码
 325   6      
 326   6                }
 327   5                else g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS////保护盘位时//
 328   5              }
 329   4      
 330   4            }
 331   3            else
 332   3            {
 333   4              g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;
 334   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;               
 335   4              else  g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=1;
 336   4            } 
 337   3      #ifdef PPIAIS_SUPPORT     
 338   3            if(PPIAIS) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;               
 339   3            else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 340   3      #endif
 341   3            if(TULOP) g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=1;              
 342   3            else g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=0;  
 343   3            if(TUAIS) g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=1;              
 344   3            else g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=0;
 345   3            if(TULOP||TUAIS)
 346   3            {
 347   4              g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 348   4              g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 349   4              g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 350   4              #ifdef NEED_LP_RFI
                      g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
                      #endif
 353   4              g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0; 
 354   4            }
 355   3            else
 356   3            {
 357   4              if(LPSLM) g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=1;              
 358   4              else g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 359   4              if(LPRDI) g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=1;              
 360   4              else g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 361   4              if(LPUNEQ) g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=1;               
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 7   

 362   4              else g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 363   4      
 364   4              /* 烽火老设备未使用RFI,不使用时将下面两句屏蔽 */
 365   4      #ifdef NEED_LP_RFI
                       if(LPRFI) g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=1;              
                       else g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
              #endif
 369   4              
 370   4              if(LPTIM) g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=1;              
 371   4              else g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0;  
 372   4            }
 373   3            if(LOOPL) g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=1;               
 374   3            else g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=0;
 375   3            if(LOOP) g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=1;              
 376   3            else g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=0;
 377   3            if(g_stuPm[i*PMTYPENUM+3].Value.usint>=(0xffff-LPFEBE)) g_stuPm[i*PMTYPENUM+3].Value.usint=0xffff;     
             -  
 378   3            else g_stuPm[i*PMTYPENUM+3].Value.usint+=LPFEBE;   //REI(FEBE)性能值                    
 379   3            if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==0)                               //无PPI_LOS告警时
 380   3            {
 381   4               //HDB3编码违例计数值
 382   4              HDB3 = XBYTE[sw1021Chip + HDB3_CV_REG(n)];
 383   4              
 384   4              if(g_stuPm[i*PMTYPENUM+4].Value.usint>=(0xffff-HDB3)) g_stuPm[i*PMTYPENUM+4].Value.usint=0xffff;     
 385   4              else g_stuPm[i*PMTYPENUM+4].Value.usint+=HDB3;      // HDB3性能值         //g_stuPm[i][4]=HDB3CV
 386   4            }           
 387   3      
 388   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState)
 389   3            almnumber=almnumber+1;
 390   3            
 391   3            tv5 = XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)];
 392   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3
             -)+4].ucState)
 393   3            { //如果TUAIS,TULOP,LPUNEQ之一为"1" 则向上插VC12=AIS,LPRDI,向下插AIS
 394   4                if((tv5 & RDI_CNF) != RDI_CNF)
 395   4                  XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 | RDI_CNF;
 396   4            }
 397   3            else
 398   3            {
 399   4              if((tv5 & RDI_CNF) == RDI_CNF)
 400   4                XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 & (~RDI_CNF);
 401   4            }
 402   3          }
 403   2        }
 404   1      
 405   1        for(i=0;i<(LINENUM-1);i++)
 406   1        {
 407   2          m=i/21;
 408   2          n=i%21;
 409   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 410   2          // 获取N2 和 K4 值
 411   2          //TODO: get N2
 412   2          //g_ucState[204+2*i]=XBYTE[WGS21891+0x0100+0x10*n+0x0C]; 
 413   2          g_ucState[205+2*i]=XBYTE[sw1021Chip + RX_K4_REG(A_BUS_BASE,n)];
 414   2          
 415   2          
 416   2          mi=i/8;
 417   2          ni=i%8;
 418   2          if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 419   2            g_ucState[330+mi]&=(~(0x01<<ni));
 420   2      
 421   2          else
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 8   

 422   2            g_ucState[330+mi]|=(0x01<<ni);    
 423   2      
 424   2          //  tv5=XBYTE[WGS21891+0x0100+0x10*n+0x00];
 425   2      
 426   2        }
 427   1      
 428   1         
 429   1      
 430   1        if(TUXAB) g_ucState[77]=0;
 431   1        else g_ucState[77]=1;
 432   1                           
 433   1             
 434   1        if((WP==0) && (TUSWTI==0))   //保护盘位时,如果没有倒换ACT灯慢闪//     
 435   1        {
 436   2          g_ucState[76]=0;
 437   2          g_LampEn=0;        
 438   2          if(g_stuSysClock.ucSecond%2==0) ACT=ON;
 439   2          else ACT=OFF;
 440   2          for(i=0;i<(LINENUM-1);i++)
 441   2          {
 442   3            g_ucLineMask[i]=1;
 443   3            g_ucState[141+i]=1;
 444   3          }
 445   2        }
 446   1        else if(g_ucState[76]==0)
 447   1        {                           
 448   2          for(i=0;i<(LINENUM-1);i++)
 449   2          {
 450   3            if((g_ucConfData[64+i]==0)||(g_ucConfData[137+i]==01))
 451   3            {    
 452   4              g_ucLineMask[i]=1;
 453   4              g_ucState[141+i]=1;  
 454   4            }   
 455   3            else
 456   3            {
 457   4              g_ucLineMask[i]=0;  
 458   4              g_ucState[141+i]=0;
 459   4            }
 460   3          }
 461   2          g_ucState[76]=1;     
 462   2          g_LampEn=1;
 463   2          WROUTPORT;           
 464   2        }
 465   1             
 466   1        UasClear();
 467   1      
 468   1      
 469   1        if(g_AllClrFlag)                //清性能
 470   1        {   
 471   2          g_bClearUas=1; 
 472   2          g_AllClrFlag=0;
 473   2        }
 474   1      
 475   1        if(g_SecondFlag)                   //秒标识，1：进入新的一秒
 476   1        {
 477   2          CalUas(ulSesLmt);           //uas计算        
 478   2      
 479   2          for(i=0; i<(LINENUM-1); i++)
 480   2          {
 481   3            g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];         //bbe_lp性能的采集
 482   3            g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];        //es_lp性能的采集
 483   3            g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];       //ses_lp性能的采集
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 9   

 484   3            if(g_usiEs[i]>=ulEsLimit) 
 485   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=1;    //curalm[i][8]=es_limit
 486   3            else 
 487   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=0;
 488   3            // if(g_usiSes[i]>=ulSesLimit) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;    //curalm[i][9]=ses_limit
 489   3            // else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 490   3            g_stuPm[i*PMTYPENUM+5].Value.usint=g_usiUas[i];             //UAS_LP性能的采集
 491   3            g_stuPm[i*PMTYPENUM+6].Value.usint=g_usiCses[i];            //cses_lp性能的采集
 492   3      
 493   3      #ifndef PPIAIS_SUPPORT
                    /******************************************************************************/
                    if(g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3)+1].ucState)
                    {
                      g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
                      BIP[i]=0;
                    }
                    else
                    {
                      BIP_2_1S[i]=BIP[i];
                      BIP_2_1000S[i]+=BIP[i];  
                      BIP[i]=0;
                      switch(g_ucConfData[129])
                      {
                        case 0x04:
                        if(BIP_2_1S[i]>=217) 
                          g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
                        else if(BIP_2_1S[i]<=23) 
                          g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
                        break;
              
                        case 0x05:
                        if(BIP_2_1S[i]>=22) 
                          g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
                        else if(BIP_2_1S[i]<=3) 
                          g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
                        break;
              
                        case 0x06:
              
              
                        if((N1000[i]>=10)&&(N1000[i]<100))
                        {
                          if(BIP_2_1000S[i]>=22) 
                            g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
                          else if(BIP_2_1000S[i]<=3) 
                            g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
                          N1000[i]=0;
                          BIP_2_1000S[i]=0;
                        }
                        else N1000[i]++;
              
                        break;
              
                        case 0x07:
              
              
                        if((N1000[i]>=100)&&(N1000[i]<1000))
                        {
                          if(BIP_2_1000S[i]>=22) 
                            g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
                          else if(BIP_2_1000S[i]<=3) 
                            g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 10  

                          N1000[i]=0;
                          BIP_2_1000S[i]=0;
                        }
                        else N1000[i]++;
                        break;
              
                        case 0x08:
              
              
                        if(N1000[i]>=1000)
                        {
                          if(BIP_2_1000S[i]>=22) 
                            g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
                          else if(BIP_2_1000S[i]<=3) 
                            g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
                          N1000[i]=0;
                          BIP_2_1000S[i]=0;
                        }
                        else 
                          N1000[i]++;
                        break;
                      }
                    }
              
                  /********************************************************************************/
              #endif
 572   3          }
 573   2      
 574   2          g_SecondFlag=0;      //秒标识清?
 575   2      
 576   2        }     
 577   1      
 578   1        //IO8=1;
 579   1        // WRHIO;
 580   1        //RDHIO;    
 581   1        //IO9=1;
 582   1        // WRHIO;
 583   1        //RDHIO;
 584   1        //IO10=1;
 585   1        // WRHIO;
 586   1        //RDHIO;
 587   1        //IO11=1;
 588   1        // WRHIO;
 589   1        //RDHIO;
 590   1        //IO12=1;
 591   1        // WRHIO;
 592   1        RDHIO;
 593   1      
 594   1         
 595   1             
 596   1        if(ADCLK||(P2V5==0)||(first_conf==0)) 
 597   1          TUALMO=1; //如果工作支路中全部有告警或2.5V//
 598   1        else 
 599   1          TUALMO=0; //电源有告警或下配置前TUALMO=1,否则TUALMO=0//
 600   1        if((P5VI1==0)&&(DZBI1==0)) 
 601   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=1;
 602   1        else    
 603   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=0;               
 604   1        if((P5VI2==0)&&(DZBI2==0)) 
 605   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=1;
 606   1        else    
 607   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=0;       
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 11  

 608   1        if(P2V5==0) 
 609   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=1;
 610   1        else    
 611   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=0;                     
 612   1       
 613   1      }
 614          
 615          /*****************************************************************
 616          ** 函数名:USERFUN
 617          ** 输　入: 无
 618          ** 输　出: 无
 619          ** 功能描述：用户实时处理函数，10毫秒被调用一次
 620          ** 全局变量：无
 621          ** 调用模块：无
 622          ** 作　者：翁益晖
 623          ** 日　期：2002.5.25
 624          ** 修　改：
 625          ** 日　期：
 626          ** 版  本：1.0
 627          ****************************************************************/
 628          void UserFunc() using 1
 629          {
 630   1        #if 0
                int i,j;
                int tmp;
                unsigned int chip  = SW1021;
                static int docnt = 0;
                if(g_haveTux){
                  if(docnt == 0){
                    XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
                    
                    XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
                    
                    XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
                    docnt++;
                    return;
                  }
                  if(docnt > 2){
                    docnt = 0;
                    g_haveTux = 0;
                  }
                  for(i=0; i<CHIPS_ON_BOARD; i++){
                    for(j=0; j< 21; j++){
                      tmp = XBYTE[chip+PORT_E1_ALARM_REG(j)];
                      if((tmp & RFFERR) == 0){
                        continue;
                      }else{
                        //XBYTE[SW1021_CHIP_ADDR(k) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
                        XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
                        
                        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
                        
                        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
                      
                        g_haveTux = 0;
                        docnt = 0;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 12  

                        return;
                      }
                    }
                    chip+=0x1000;
                  }
                  docnt++;
                }
                #endif
 678   1        return;
 679   1      }
 680          
 681          /*
 682          //static void ChecktuxAB (void) interrupt 9 using 3
 683          static void ChecktuxAB (void) interrupt 9
 684          {
 685          
 686            EX3 = 0;
 687            EXIF &= 0xDF;
 688            g_haveTux = 1;
 689          
 690          
 691            EX3 = 1;
 692            return;
 693          }
 694          */
 695          
 696          static void happenSwich (void) interrupt 8
 697          {
 698   1      
 699   1        EX2 = 0;
 700   1        EXIF &= 0xEF;
 701   1        //g_haveTux = 1;
 702   1        
 703   1        XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
 704   1        XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
 705   1                
 706   1        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
 707   1        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
 708   1                
 709   1        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
 710   1        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
 711   1        
 712   1      
 713   1        EX2 = 1;
 714   1        return;
 715   1      }
 716          
 717          /*****************************************************************
 718          ** 函数名:CONF_SET
 719          ** 输　入: 无
 720          ** 输　出: 无
 721          ** 功能描述：单盘配置
 722          ** 全局变量：无
 723          ** 调用模块：无
 724          ** 作　者：caijun.Li
 725          ** 日　期：2016.3.19
 726          ** 修　改：
 727          ** 日　期：
 728          ** 版  本：1.0
 729          ****************************************************************/
 730          void ConfSet(void)
 731          {
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 13  

 732   1          /*Process ALMMASK*/
 733   1          /*Process PMMASK*/
 734   1        unsigned char i,j,ilong,m,n,temp;
 735   1      
 736   1        g_ucState[69]=g_ucConfData[5];
 737   1        g_ucState[70]=g_ucConfData[6];
 738   1        g_ucState[71]=g_ucConfData[7];
 739   1        g_ucState[72]=g_ucConfData[8];
 740   1        g_ucState[73]=g_ucConfData[9];
 741   1        g_ucState[74]=g_ucConfData[10];
 742   1        g_ucState[75]=g_ucConfData[11];
 743   1        for(i=0;i<(LINENUM-1);i++){
 744   2          m=i/21;
 745   2          n=i%21;
 746   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 747   2        
 748   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 749   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 750   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 751   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 752   2      
 753   2          if(g_ucConfData[64+i]==0){  // 支路关闭
 754   3            // 上下话强发AIS
 755   3            if(ALERT_LOOPL) {
 756   4            //XBYTE[sw1021Chip + TX_CTRL_REG(B_BUS_BASE,n)] = AIS_EN; 
 757   4            temp = XBYTE[sw1021Chip + PORT_CFG_REG(n)];
 758   4            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = temp | TAISEN | RAISEN; 
 759   4            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = 0x00;
 760   4            }
 761   3                  
 762   3            g_ucState[78+i]=0;     
 763   3            g_ucLineMask[i]=1;
 764   3            g_ucState[141+i]=1;
 765   3          }else{  // 支路打开
 766   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = A_UP_DOWN | RnEN;
 767   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = (0x02 << 1);  // 注意信号标记值得配置
 768   3            if(g_ucState[78+i]==0)//刚打开支路开关时插伪随机码
 769   3            {
 770   4              //TODO: 启动误码计数器
 771   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 772   4              Delay(5);
 773   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= ~(PRBSEN | PRBST);
 774   4              g_ucState[78+i]=1;
 775   4              g_ucLineMask[i]=0; 
 776   4              g_ucState[141+i]=0;
 777   4            }
 778   3            //do_rst_fifo(i);     
 779   3          }
 780   2          XBYTE[sw1021Chip + TX_K4_REG(A_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 781   2          XBYTE[sw1021Chip + TX_K4_REG(B_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 782   2          // TODO: N2 发
 783   2          //XBYTE[WGS21891+0x0100+0x10*n+0x01]=g_ucConfData[263+4*i];                 // N2 发
 784   2        
 785   2        #ifdef AIS_CONDITIONS_AUTO
                  if((g_ucConfData[2531] & 0x80)){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }else{
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }
                  if(g_ucConfData[2531] & 0x40){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= UNEQAISE;
                  }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 14  

                  if(g_ucConfData[2531] & 0x20){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= PLMAISE;
                  }
                #endif
 798   2        
 799   2          // J2 发 和 期望收
 800   2          for(j=0;j<16;j++)
 801   2          {
 802   3            if(j==0) temp=0x80;
 803   3            else temp=0;
 804   3            
 805   3            // A 
 806   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 0);
 807   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 0);
 808   3            // B
 809   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 1);
 810   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 1);
 811   3          }
 812   2          
 813   2          if(g_ucConfData[137+i]==0)   //confdata[137+i]==0不屏蔽支路i告警/否则屏蔽支路i告警//
 814   2          {
 815   3            g_ucLineMask[i]=0;
 816   3            g_ucState[141+i]=0;
 817   3          }
 818   2          else
 819   2          {
 820   3            g_ucLineMask[i]=1;
 821   3            g_ucState[141+i]=1;
 822   3          }
 823   2        //if(g_ucConfData[200+i]==0)     //confdata[200+i]==1支路i装载/否则不装载//
 824   2        //XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x00;
 825   2        // else  XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x04;
 826   2      
 827   2        }
 828   1      
 829   1      
 830   1      
 831   1        for(j=0;j<ALMTYPENUM;j++) 
 832   1        {
 833   2           
 834   2           for(ilong=29;ilong<(29+ALMTYPENUM);ilong++)
 835   2           {    
 836   3              if(g_ucConfData[ilong]==g_ucAlmCode[j])   //从网管设告警屏蔽//
 837   3              {
 838   4               g_ucAlmMask[j]=1;  
 839   4               if(j == 9){  // LP_TIM
 840   5                  //禁止RDI 回插 2016-07-15
 841   5                  for(i=0; i<CHIPS_ON_BOARD; i++){
 842   6                    XBYTE[SW1021_CHIP_ADDR(i) + RDI_RFI_CTRL_REG(A_BUS_BASE)] = MREI_AUTO | AISV_RDIEN | LOPV_RDIEN | L
             -OMV_RDIEN | UNEQV_RDIEN | RTIUV_RDIEN;
 843   6                  }
 844   5               }          
 845   4               break;     
 846   4              }else{
 847   4                g_ucAlmMask[j]=0;
 848   4                if(j == 9){  // LP_TIM
 849   5                  //启用RDI 回插 2016-07-15
 850   5                  for(i=0; i<CHIPS_ON_BOARD; i++){
 851   6                    XBYTE[SW1021_CHIP_ADDR(i) + RDI_RFI_CTRL_REG(A_BUS_BASE)] = MREI_AUTO | AISV_RDIEN | LOPV_RDIEN | L
             -OMV_RDIEN | UNEQV_RDIEN | RTIMV_RDIEN | RTIUV_RDIEN;
 852   6                  }
 853   5                }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 15  

 854   4              }
 855   3           }
 856   2        }      
 857   1                          
 858   1        for(j=0;j<PMTYPENUM;j++)  
 859   1        {
 860   2      
 861   2          for(ilong=54;ilong<(54+PMTYPENUM);ilong++)
 862   2          {   
 863   3            if(g_ucConfData[ilong]==g_ucPmCode[j])   //从网管设性能屏蔽//
 864   3            {
 865   4              g_ucPmMask[j]=1;                              
 866   4              break;    
 867   4            }
 868   3            else
 869   3              g_ucPmMask[j]=0;
 870   3          }
 871   2        }        
 872   1      
 873   1        ulEsLimit=256*g_ucConfData[131]+g_ucConfData[132];    //从网管设ulEsLimit门限//
 874   1        ulSesLimit=256*g_ucConfData[134]+g_ucConfData[135];   //从网管设ulSesLimit门限//
 875   1      
 876   1      
 877   1        //if((g_ucConfData[136]==0)&&TUALMO&&WP) TUALMO=0;  //IO2=TUALMO  confdata[108]=盘保护模式不保护
 878   1      
 879   1      
 880   1        // g_ucConfChange=0;                          
 881   1              
 882   1      
 883   1        if(first_conf==0) first_conf=1; 
 884   1      }
 885          
 886          
 887          /*****************************************************************
 888          ** 函数名:UserHdlc
 889          ** 输　入: 无
 890          ** 输　出: 无
 891          ** 功能描述：单盘特殊命令处理
 892          ** 全局变量：无
 893          ** 调用模块：无
 894          ** 作　者：caijun.Li
 895          ** 日　期：2016.3.19
 896          ** 修　改：
 897          ** 日　期：
 898          ** 版  本：1.0
 899          ****************************************************************/
 900          void UserHdlc(void)
 901          {
 902   1        unsigned char i,j,m,n,temp;
 903   1        unsigned int addr;
 904   1        char val;
 905   1      
 906   1        if (g_ucHdlcBuf[CMD_TYPE]==COMM_CATA)
 907   1        {
 908   2          if (g_ucHdlcBuf[CMD_CODE]==RTRV_OCONF)
 909   2          {
 910   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;
 911   3          }
 912   2          else if (g_ucHdlcBuf[CMD_CODE]==SET_OCONF)
 913   2          {
 914   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;                                               
 915   3          }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 16  

 916   2        }
 917   1      
 918   1      
 919   1        switch(g_ucHdlcBuf[5])
 920   1        {
 921   2          case 0x00:    /*SET_LOOP*/
 922   2            if(g_ucHdlcBuf[6]==0x34)
 923   2            { // 设备环回
 924   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 925   3                g_ucHdlcBuf[10]=0x80; 
 926   3              else                
 927   3                for(i=0;i<(g_usRxDataLen);i++)
 928   3                {
 929   4                  temp=g_ucHdlcBuf[14+i]-1;
 930   4                  m=temp/21;
 931   4                  n=temp%21;
 932   4      
 933   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 934   4                  if(g_ucHdlcBuf[7]==0x01){
 935   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
 936   5                  }else{
 937   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
 938   5                  }
 939   4                  g_ucHdlcBuf[10]=0x00;
 940   4                }
 941   3            }
 942   2            else if(g_ucHdlcBuf[6]==0x33)       /*SET_LOOPL*/
 943   2            { // 线路环回 
 944   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 945   3                g_ucHdlcBuf[10]=0x80; 
 946   3              else{
 947   4                // 判断是否为全部线路环回
 948   4                if(g_usRxDataLen == 63){
 949   5                  if(g_ucHdlcBuf[7]==0x01){
 950   6                    ALERT_LOOPL = 0;
 951   6                    for(i=0; i<63; i++){
 952   7                        m=i/21;
 953   7                        n=i%21;
 954   7                        sw1021Chip = SW1021_CHIP_ADDR(m);
 955   7                        if(g_ucState[78+i] == 0){
 956   8                          // 未打开该支路，执行打开
 957   8                          XBYTE[sw1021Chip + PORT_CFG_REG(n)] = A_UP_DOWN | RnEN;
 958   8                          XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = (0x02 << 1);  // 注意信号标记值得配置
 959   8                        }
 960   7                    }
 961   6                    
 962   6                  }else{
 963   6                    ALERT_LOOPL = 1;
 964   6                    for(i=0; i<63; i++){
 965   7                        m=i/21;
 966   7                        n=i%21;
 967   7                        sw1021Chip = SW1021_CHIP_ADDR(m);
 968   7                        XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~E1LBK);
 969   7                        if(g_ucState[78+i] == 0){
 970   8                          // 未打开该支路，执行关闭
 971   8                          temp = XBYTE[sw1021Chip + PORT_CFG_REG(n)];
 972   8                          XBYTE[sw1021Chip + PORT_CFG_REG(n)] = temp | TAISEN | RAISEN; 
 973   8                          XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = 0x00;
 974   8                        }
 975   7                    }
 976   6                  }
 977   5                  g_ucHdlcBuf[10]=0x00;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 17  

 978   5                }else{
 979   5                
 980   5                  for(i=0;i<(g_usRxDataLen);i++)
 981   5                  {
 982   6                    temp=g_ucHdlcBuf[14+i]-1;
 983   6                    m=temp/21;
 984   6                    n=temp%21;
 985   6                    
 986   6                    sw1021Chip = SW1021_CHIP_ADDR(m);
 987   6                    if(g_ucHdlcBuf[7]==0x01){
 988   7                      XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= E1LBK;
 989   7                    }else{
 990   7                      XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~E1LBK);
 991   7                    }
 992   6                    g_ucHdlcBuf[10]=0x00;
 993   6                  }
 994   5                }
 995   4              }
 996   3            }
 997   2            else if(g_ucHdlcBuf[6] == 0x45){  /* 请求报告J字节等辅助信息 */
 998   3              int addr = 0;
 999   3              g_ucHdlcBuf[10]=0x00;
1000   3              g_ucHdlcBuf[11]=0x00;
1001   3              g_ucHdlcBuf[12]=0x04;
1002   3              g_ucHdlcBuf[13]=0x6e;
1003   3            
1004   3              addr = 14;
1005   3              for(i=0; i<63; i++){
1006   4                m = i/21;
1007   4                n = i%21;
1008   4                g_ucHdlcBuf[addr++] = 0x02; //J2
1009   4                g_ucHdlcBuf[addr++] = i;   //TODO: 确认支路号是从0开始还是从1开始
1010   4                for(j=0;j<16;j++){
1011   5                  readRxJ2(m, j, slot[i], &val, 0);
1012   5                  g_ucHdlcBuf[addr++] = val; //J2 value
1013   5                }         
1014   4              } 
1015   3              g_ucHdlcBuf[10]=0x00;       
1016   3              
1017   3            }
1018   2            break;
1019   2          case 0x20:
1020   2             if(g_ucHdlcBuf[6] == 0x09){  /* 大网管请求报告J字节等辅助信息 */
1021   3              int addr = 0;
1022   3              g_ucHdlcBuf[10]=0x00;
1023   3              g_ucHdlcBuf[11]=0x00;
1024   3              g_ucHdlcBuf[12]=0x04;
1025   3              g_ucHdlcBuf[13]=0x6e;
1026   3            
1027   3              addr = 14;
1028   3              for(i=0; i<63; i++){
1029   4                m = i/21;
1030   4                n = i%21;
1031   4                g_ucHdlcBuf[addr++] = 0x02; //J2
1032   4                g_ucHdlcBuf[addr++] = i;   //TODO: 确认支路号是从0开始还是从1开始
1033   4                for(j=0;j<16;j++){
1034   5                  readRxJ2(m, j, slot[i], &val, 0);
1035   5                  g_ucHdlcBuf[addr++] = val; //J2 value
1036   5                }         
1037   4              }
1038   3              g_ucHdlcBuf[10]=0x00;         
1039   3              
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 18  

1040   3            }
1041   2          break;
1042   2      
1043   2          case 0x77:                /**透明帧命令**/
1044   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];  // commbuf[14]，commbuf[15]所存放 的 地址
1045   2            g_ucHdlcBuf[10]=0x00;
1046   2            g_ucHdlcBuf[11]=0x00;
1047   2            g_ucHdlcBuf[12]=0x00;
1048   2            g_ucHdlcBuf[13]=0x11;
1049   2            //读16个字节//  addr 地址开始读取16个字节数据//
1050   2            for(i=0;i<16;i++) 
1051   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; 
1052   2            g_ucHdlcBuf[30]=P1;
1053   2            break;                   
1054   2          
1055   2          case 0x88:
1056   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];
1057   2            XBYTE[addr]=g_ucHdlcBuf[16];       //将commbuf[16]存放的数据送入commbuf[14]，//
1058   2            g_ucHdlcBuf[10]=0x00;              //commbuf[15]所存放的WGS21891的地址单元中//
1059   2            g_ucHdlcBuf[11]=0x00;
1060   2            g_ucHdlcBuf[12]=0x00;
1061   2            g_ucHdlcBuf[13]=0x10;              //读16个字节//
1062   2            for(i=0;i<16;i++) 
1063   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; //从commbuf[14]，commbuf[15]的地址开始读取16个字节数据//
1064   2            break;
1065   2      
1066   2          
1067   2          case 0X99:
1068   2            while(1)
1069   2            {;}
1070   2            if((g_usRxDataLen==0)||(g_usRxDataLen>63)) 
1071   2              g_ucHdlcBuf[10]=0x80; 
1072   2            else                
1073   2              for(i=0;i<(g_usRxDataLen);i++)
1074   2              {
1075   3                temp=g_ucHdlcBuf[14+i]-1;
1076   3                m=temp/21;
1077   3                n=temp%21;
1078   3                sw1021Chip = SW1021_CHIP_ADDR(m);
1079   3                          
1080   3                g_ucHdlcBuf[17]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
1081   3                g_ucHdlcBuf[18]=0xbb;
1082   3                
1083   3                if(g_ucHdlcBuf[7]==0x01)
1084   3                {
1085   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
1086   4                  if(n<8)
1087   4                    g_ucHdlcBuf[18]=0xff;
1088   4                }
1089   3                else
1090   3                {
1091   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
1092   4                }
1093   3                    
1094   3              }
1095   2            g_ucHdlcBuf[10]=0x00;
1096   2            g_ucHdlcBuf[13]=6;
1097   2            g_ucHdlcBuf[14]=0xaa;
1098   2            g_ucHdlcBuf[15]=m;
1099   2            g_ucHdlcBuf[16]=n;
1100   2            g_ucHdlcBuf[19]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
1101   2            
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 19  

1102   2            break;
1103   2            
1104   2      
1105   2        }
1106   1      
1107   1      }
1108          
1109          /*****************************************************************
1110          ** 函数名:SELF_CONF
1111          ** 输　入: 无
1112          ** 输　出: 无
1113          ** 功能描述：单盘上电默认配置
1114          ** 全局变量：g_ucConfData[]
1115          ** 调用模块：无
1116          ** 作　者：翁益晖
1117          ** 日　期：2002.5.25
1118          ** 修　改：
1119          ** 日　期：
1120          ** 版  本：1.0
1121          ** 注  意：所有告警和性能的初始化需安线路号顺序
1122          ****************************************************************/
1123          void SelfConf()
1124          {
1125   1      
1126   1        unsigned int i,j;
1127   1        char ctt[18];
1128   1        unsigned char ucii;
1129   1        //  first_conf=0;
1130   1        g_ucConfData[22]=BOARDCODE;/*BDINF5*/
1131   1        g_ucConfData[0]=0xfe;
1132   1      
1133   1      
1134   1        sprintf(ctt,BoardSn);
1135   1        for(ucii=0;ucii<15;ucii++) g_ucState[ucii]=ctt[ucii];  /*盘号*/
1136   1      
1137   1        sprintf(ctt,PcbSn);   
1138   1        for(ucii=0;ucii<15;ucii++) g_ucState[15+ucii]=ctt[ucii]; /*板号*/
1139   1      
1140   1        sprintf(ctt,PcbTime);   
1141   1        for(ucii=0;ucii<10;ucii++) g_ucState[30+ucii]=ctt[ucii]; /*制板时间*/
1142   1      
1143   1        for(ucii=0;ucii<18;ucii++) ctt[ucii]=0;    /*版本号buf清零*/
1144   1        //sprintf(ctt,"R170609R1B/01F    "); 
1145   1        //for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
1146   1        sprintf(ctt,BoardSoftVer); 
1147   1        for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
1148   1        sprintf(ctt,__DATE__);   
1149   1        for(ucii=0;ucii<11;ucii++) g_ucState[58+ucii]=ctt[ucii]; /*编程时间*/
1150   1      
1151   1        //g_ucState[69]=0x07;
1152   1        //g_ucState[70]=0xD1;
1153   1        //g_ucState[71]=0x06;
1154   1        //g_ucState[72]=0x01;
1155   1        //g_ucState[73]=0x08;
1156   1        //g_ucState[74]=0x00;
1157   1        //g_ucState[75]=0x00;
1158   1        g_ucState[76]=0x01;
1159   1        //g_ucState[77]=0x01;
1160   1      
1161   1      
1162   1      
1163   1        for(i=0;i<LINENUM;i++)           /*linecode=1..63*/
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 20  

1164   1          g_ucLineCode[i]=i+1;
1165   1        for(i=0;i<LINENUM;i++)
1166   1        {
1167   2          g_ucLineMask[i]=0;          
1168   2      
1169   2        }
1170   1      
1171   1      
1172   1      
1173   1        /*for(i=0;i<LINENUM;i++)
1174   1        for(j=0;j<PMNUM;j++) linepmmask[i][j]=0;*/         
1175   1      
1176   1      
1177   1        actnumber=63;             
1178   1        almnumber=0;     
1179   1      
1180   1        ulEsLimit=0xff;
1181   1        ulSesLimit=0xff;
1182   1      
1183   1        g_ucAlmCode[0]=0x03;                        /*PPI_LOS*/
1184   1        g_ucAlmCode[1]=0x27;                        /*TU_LOP*/
1185   1        g_ucAlmCode[2]=0x22;                        /*LP_SLM*/
1186   1        g_ucAlmCode[3]=0x20;                        /*LP_RDI*/
1187   1        g_ucAlmCode[4]=0x24;                        /*LP_UNEQ*/
1188   1      #ifdef PPIAIS_SUPPORT
1189   1        g_ucAlmCode[8]=0x04;                        /*PPI_AIS*/
1190   1      #endif
1191   1        g_ucAlmCode[5]=0x02;                        /*TU_AIS*/
1192   1      #ifdef NEED_LP_RFI
                g_ucAlmCode[15]=0x0c;                        /*LP_RFI*/
              #endif
1195   1        g_ucAlmCode[7]=0x51;                        /*ES_LIMIT*/
1196   1        //g_ucAlmCode[8]=0x52;      /*SES _LIMIT*/
1197   1        g_ucAlmCode[9]=0x28;                       /*LP_TIM*/
1198   1        g_ucAlmCode[10]=0x4f;                       /*LOOPL*/
1199   1        g_ucAlmCode[11]=0x55;     /*LOOP*/
1200   1        g_ucAlmCode[12]=0x01;                       //2V5电源故障告警//
1201   1        g_ucAlmCode[13]=0x05;                       //5VI1电源故障告警//
1202   1        g_ucAlmCode[14]=0x06;                       //5VI2电源故障告警//
1203   1        g_ucAlmCode[6]=0x07;                 //trafic-onload//
1204   1      #ifndef PPIAIS_SUPPORT
                g_ucAlmCode[8]=0x08;                /*LP_SD*/
              #endif
1207   1      
1208   1        g_ucPmCode[0]=0x08;                   /*BBE_LP*/
1209   1        g_ucPmCode[1]=0x02;                   /*ES_LP*/
1210   1        g_ucPmCode[2]=0x03;                   /*SES_LP*/
1211   1        g_ucPmCode[3]=0x07;                   /*REI_LP*/
1212   1        g_ucPmCode[4]=0x0b;                   /*HDB3CV*/
1213   1        //g_ucPmCode[5]=0x06;                 /*UAS_LP*/
1214   1        //g_ucPmCode[5]=0x0c;                   /*UAS_LP*/     //2016-07-19 烽火要求关闭
1215   1        //g_ucPmCode[6]=0xa2;                   /*CSES_LP*/
1216   1      
1217   1        g_ucAlmType[0]=0;   /*almtype：0急告；4非急告；8状态量*/
1218   1        g_ucAlmType[1]=0;
1219   1        g_ucAlmType[2]=0;
1220   1        g_ucAlmType[3]=4;
1221   1        g_ucAlmType[4]=4;
1222   1        g_ucAlmType[5]=4;
1223   1        g_ucAlmType[6]=8;
1224   1        g_ucAlmType[7]=4;
1225   1        g_ucAlmType[8]=4;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 21  

1226   1        g_ucAlmType[9]=0;      /*LP_TIM*/
1227   1        g_ucAlmType[10]=8;         
1228   1        g_ucAlmType[11]=8;  
1229   1        g_ucAlmType[12]=0;
1230   1        g_ucAlmType[13]=0;
1231   1        g_ucAlmType[14]=0;
1232   1        
1233   1      #ifdef NEED_LP_RFI
                g_ucAlmType[15]=4;
              #endif
1236   1      
1237   1        for(j=0;j<(LINENUM-1);j++)
1238   1        {
1239   2          for(i=0;i<(ALMTYPENUM-3);i++)
1240   2          {
1241   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucLineIndex=j;
1242   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucAlmIndex=i;
1243   3          }
1244   2        }
1245   1      
1246   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucLineIndex=63;
1247   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucAlmIndex=12;
1248   1      
1249   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucLineIndex=63;
1250   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucAlmIndex=13;
1251   1      
1252   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucLineIndex=63;
1253   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucAlmIndex=14;
1254   1      
1255   1      
1256   1        for(j=0;j<(LINENUM-1);j++)
1257   1        {
1258   2          for(i=0;i<PMTYPENUM;i++)
1259   2          {
1260   3            g_stuPm[j*PMTYPENUM+i].ucLineIndex=j;
1261   3            g_stuPm[j*PMTYPENUM+i].ucPmIndex=i;
1262   3          }
1263   2        }
1264   1      
1265   1        for(i=0;i<UASNUM;i++)
1266   1        {
1267   2          g_liError1s[i].ulDatlong=0;
1268   2          ulSesLmt[i]=700; //若某一秒内误码个数大于等于ulSesLmt[i]时,该秒是严重误码秒//
1269   2        }                  
1270   1      }
1271          
1272          
1273          
1274          /*****************************************************************
1275          ** 函数名:InitioSw1021
1276          ** 输　入: 无
1277          ** 输　出: 无
1278          ** 功能描述：SW1021初始化
1279          ** 全局变量：
1280          ** 调用模块：
1281          ** 作　者：caijun.Li
1282          ** 日　期：2016.3.18
1283          ** 修　改：
1284          ** 日　期：
1285          ** 版  本：1.0
1286          ****************************************************************/
1287          void InitioSw1021()
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 22  

1288          {
1289   1      
1290   1        unsigned int i,j;
1291   1        unsigned char m,n;
1292   1        first_conf=0;
1293   1      
1294   1        for(i=0; i<CHIPS_ON_BOARD; i++)
1295   1        {
1296   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
1297   2          Delay(1);
1298   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = RST_CANCLE;
1299   2          
1300   2          // TODO: 并行总线时钟选择
1301   2          // SW1021只支持19.44Mbit/s 的传输速率
1302   2          
1303   2          
1304   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时  + V5 期望
             - 0x02
1305   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时
1306   2          
1307   2          XBYTE[SW1021_CHIP_ADDR(i) + SOMESET_REG(A_BUS_BASE)] = BLKBIP_BLOCK;  // BIP-2按块进行校验并计数
1308   2          
1309   2          XBYTE[SW1021_CHIP_ADDR(i) + RDI_RFI_CTRL_REG(A_BUS_BASE)] = MREI_AUTO | AISV_RDIEN | LOPV_RDIEN | LOMV_R
             -DIEN | UNEQV_RDIEN | PLMV_RDIEN | RTIMV_RDIEN | RTIUV_RDIEN;
1310   2          //XBYTE[SW1021_CHIP_ADDR(i) + RDI_RFI_CTRL_REG(A_BUS_BASE)] = MREI_AUTO | AISV_RDIEN | LOPV_RDIEN | LOMV
             -_RDIEN | UNEQV_RDIEN | PLMV_RDIEN | RTIUV_RDIEN;
1311   2          
1312   2          // 上下话数据总线均选择偶校验
1313   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)] = UP_DELAY_2;
1314   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)] = UP_DELAY_2;   
1315   2          
1316   2          // 21个端口从A总线上下话, 使用 +- HDB3模式
1317   2          for(j=0; j<21; j++){
1318   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)] = A_UP_DOWN | RnEN;
1319   3            // 关闭线路环回和系统环回
1320   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_TEST_REG(j)] = 0x00;
1321   3            // TODO: 上下话交叉状态选择 ： 不交叉
1322   3            
1323   3            // TODO: TU通道LOP\AIS告警检测设置： EN_TUAIS  使能TU-AIS 中断
1324   3            //                             EN_TULOP  使能TU-LOP 中断
1325   3            //                             
1326   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_E1_ALARM_INTERRPUT_MASK_REG(j)] = E1AISE | E1LOCE; //??
1327   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(A_BUS_BASE,j)] = LOPE | AISE;  
1328   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(B_BUS_BASE,j)] = LOPE | AISE;  
1329   3            //TODO： 读清中断指示
1330   3            
1331   3            //TODO: 不启动随机码测试； 启动误码计数
1332   3            
1333   3            //TODO: 上话V5-TX2 设置 LP-REI
1334   3            XBYTE[SW1021_CHIP_ADDR(i) + TX_V5_REG(A_BUS_BASE,j)] = (0x02 << 1);
1335   3            
1336   3            //TODO： 上下话通道号编码
1337   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1338   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1339   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1340   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1341   3            
1342   3            
1343   3          }
1344   2          // TODO:上下话时钟数据同相
1345   2          XBYTE[SW1021_CHIP_ADDR(i) + E1_CTRL_REG] = TRZSEL | RRZSEL;
1346   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_IF_CLK_REG] = 0x00;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 23  

1347   2      
1348   2        }
1349   1        
1350   1        // 填充所有支路的J2字节（初始化清0）
1351   1        for(i=0;i<63;i++)            
1352   1        {
1353   2          m=i/21;
1354   2          n=i%21;
1355   2          for(j=0;j<16;j++)
1356   2          {
1357   3            if(j==0)
1358   3            { // A 
1359   4              writeTxJ2(m, j, slot[i],  0x80, 0);
1360   4              writeExpectJ2(m, j, slot[i],  0x80, 0);
1361   4              // B
1362   4              writeTxJ2(m, j, slot[i],  0x80, 1);
1363   4              writeExpectJ2(m, j, slot[i],  0x80, 1);           
1364   4            }
1365   3            else
1366   3            {
1367   4              // A 
1368   4              writeTxJ2(m, j, slot[i],  0x00, 0);
1369   4              writeExpectJ2(m, j, slot[i],  0x00, 0);
1370   4              // B
1371   4              writeTxJ2(m, j, slot[i],  0x00, 1);
1372   4              writeExpectJ2(m, j, slot[i],  0x00, 1); 
1373   4            }
1374   3          }
1375   2        }
1376   1      
1377   1         IO8=1;
1378   1         IO9=1;
1379   1         IO10=1;
1380   1         IO11=1;
1381   1         IO12=1;
1382   1         WRHIO;
1383   1      
1384   1      }
1385          /*****************************************************************
1386          ** 函数名:checkSW1021Init
1387          ** 输　入: 无
1388          ** 输　出: 无
1389          ** 功能描述：检查SW1021初始化成功
1390          ** 全局变量：
1391          ** 调用模块：
1392          ** 作　者：caijun.Li
1393          ** 日　期：2016.3.18
1394          ** 修　改：
1395          ** 日　期：
1396          ** 版  本：1.0
1397          ****************************************************************/
1398          static int checkSW1021Init(void)
1399          {
1400   1        int ret = 0;
1401   1        int i,j;
1402   1        unsigned int reg;
1403   1        for(i=0;i<CHIPS_ON_BOARD;i++)
1404   1        {
1405   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)];
1406   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1407   3            ret = -1;
1408   3            break;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 24  

1409   3          }
1410   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)];
1411   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1412   3            ret = -1;
1413   3            break;
1414   3          }
1415   2          
1416   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)];
1417   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1418   3            ret = -1;
1419   3            break;
1420   3          }
1421   2          
1422   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)];
1423   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1424   3            ret = -1;
1425   3            break;
1426   3          }
1427   2          
1428   2          for(j=0; j<21; j++){
1429   3            reg = XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)];
1430   3            if((reg & (A_UP_DOWN | RnEN)) != (A_UP_DOWN | RnEN)){
1431   4              ret = -1;
1432   4              goto quit;
1433   4            }
1434   3          }
1435   2      
1436   2        }
1437   1      quit:
1438   1        return ret;
1439   1      }
1440          
1441          /*
1442          void do_rst_fifo_all(void)
1443          {
1444            XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
1445            XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
1446                    
1447            XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
1448            XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
1449                    
1450            XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
1451            XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
1452            
1453            
1454          }
1455          void do_rst_fifo(int trib)
1456          {
1457            if(trib/21 == 0){
1458              XBYTE[SW1021 + PORT_RST_REG(trib)] = RST_PORT;
1459              XBYTE[SW1021 + PORT_RST_REG(trib)] = RST_CANCLE;
1460            }else if(trib/21 == 1){ 
1461              XBYTE[SW1021 + 0x1000 + PORT_RST_REG(trib)] = RST_PORT;
1462              XBYTE[SW1021 + 0x1000 + PORT_RST_REG(trib)] = RST_CANCLE;
1463            }else if(trib/21 == 2){     
1464              XBYTE[SW1021 + 0x2000 + PORT_RST_REG(trib)] = RST_PORT;
1465              XBYTE[SW1021 + 0x2000 + PORT_RST_REG(trib)] = RST_CANCLE;
1466            }
1467          }
1468          */
1469          
1470          /*****************************************************************
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 25  

1471          ** 函数名:MAIN
1472          ** 输　入: 无
1473          ** 输　出: 无
1474          ** 功能描述：主函数
1475          ** 全局变量：g_QuarterFlag
1476          ** 调用模块：SelfConf(),GetData(),ProcHisData(),Debug();
1477          ** 作　者：caijun.Li
1478          ** 日　期：2016.3.18
1479          ** 修　改：
1480          ** 日　期：
1481          ** 版  本：1.0
1482          ****************************************************************/
1483          void main()
1484          {   
1485   1        unsigned char i;  
1486   1        int ret = 0;
1487   1         //Delay(50);
1488   1        
1489   1        SelfConf(); 
1490   1        ret = checkSW1021Init();
1491   1        if(ret != 0) {
1492   2          InitioSw1021();
1493   2          //do_rst_fifo_all();
1494   2        }
1495   1        
1496   1      
1497   1        
1498   1        // 使能外部中断2
1499   1        EX2 = 1;
1500   1        PX2 = 0;  // 低优先级
1501   1      
1502   1        while (1)
1503   1        {
1504   2          #ifdef SKIP_DEBUG_CHECK
                    #ifdef NEED_LP_RFI        
                        XBYTE[0x7fe5] = 1;
                    #else
                      //  XBYTE[0x7b74] = 1;
                        XBYTE[0x7b77] = 1;
                    #endif
                  #endif
1512   2          
1513   2          //ACT = ~ACT;
1514   2          //RED = ~RED;
1515   2          //YELLOW = ~YELLOW;
1516   2              
1517   2          
1518   2          ret = checkSW1021Init();
1519   2          if(ret != 0){ 
1520   3            SelfConf(); 
1521   3            InitioSw1021();
1522   3            ConfSet();  
1523   3            //do_rst_fifo_all();
1524   3          }
1525   2        
1526   2          GetData();
1527   2          ProcAlmData();  
1528   2      
1529   2          if (g_QuarterFlag) 
1530   2          {
1531   3            UasQuarter();
1532   3            for(i=0;i<LINENUM;i++)
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    07/20/2016 11:29:10 PAGE 26  

1533   3            {
1534   4              g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];
1535   4              g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];
1536   4              g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];
1537   4            }
1538   3            ProcHisData();  //将当前告警和性能数据存为历史数据//
1539   3            g_QuarterFlag=0;
1540   3          }
1541   2          
1542   2          Debug();
1543   2        }
1544   1      }
1545          
*** WARNING C294 IN LINE 1070 OF GF2488-01F1-E1-RST.C: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  11685    ----
   CONSTANT SIZE    =    250    ----
   XDATA SIZE       =  22238     107
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
