C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE GF2488_01F1_E1_RST
OBJECT MODULE PLACED IN GF2488-01F1-E1-RST.OBJ
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE GF2488-01F1-E1-RST.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND T
                    -ABS(2)

line level    source

   1          /******************************************************************
   2          ** 文件名：STAND.C
   3          ** Copyright (c) 2002 烽火通信传输产品部BCT软件组
   4          ** 创建人：翁益晖
   5          ** 文件编号：
   6          ** 描　述：标准模版程序
   7          **         
   8          ** 日　期：2002.6.28
   9          ** 修改人：
  10          ** 日　期：
  11          ** 文件编号：
  12          ** 描　述：
  13          **
  14          **
  15          ** 编译器：Keil C51 V5.5 或 MCC68K V4.4
  16          ** 公共库：NewLib9.LIB for Mcs51
  17          **         或 NewLib1.LIB for Mc68302
  18          ** 版  本：1.0
  19          ********************************************************************/
  20          //#define  NEED_LP_RFI   /**  !!! 单盘起不来了  */
  21          #define AIS_CONDITIONS      /** 与 AIS_CONDITIONS_AUTO 二选一  */
  22          //#define AIS_CONDITIONS_AUTO
  23          //#define SKIP_DEBUG_CHECK
  24          
  25          #define UASNUM    63        //要计算误码的线路数63//
  26          #define LINENUM   64        /*告警线路数为64*/
  27          #ifdef NEED_LP_RFI
                #define ALMNUM      822     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
                #define ALMTYPENUM      16      /*16种告警类型*/
              #else
  31            #define ALMNUM      759     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
  32            #define ALMTYPENUM      15      /*15种告警类型*/
  33          #endif
  34          
  35          #define PMNUM   441         /*总共63*PMTYPENUM个性能*/
  36          
  37          #define PMTYPENUM       7       /*7种性能类型*/
  38          #define CONFLEN   2560  /*配置数据长度为2560*/
  39          #define STATELEN  338   /*状态数据长度为338*/
  40          #define BOARDCODE 0x96  /*盘代码*/
  41          #define WGS21891A 0xB000
  42          
  43          #define SW1021  0xB000    //TODO：confirm
  44          
  45          #define SW1021_CHIP_ADDR(num)  (SW1021 + 0x1000*(num))
  46          #define CHIPS_ON_BOARD          3
  47          
  48          
  49          #include "commvar9.h"
  50          #include "uasE63.h"
  51          
  52          #include "sw1021.h"
  53          
  54          char code SysName[]="GF2488-01F";
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 2   

  55          char code BoardName[]="E1-63A";
  56          char code BoardSn[]="WKE2.202.202R1A";
  57          char code SoftVer[]="R202202R1A/01F    ";
  58          
  59          char code PcbSn[]="WKE7.201.546R1A";
  60          char code PcbTime[]="2016 05 20";
  61          
  62          char code BoardSoftVer[]="RP0100            ";
  63          
  64          char code SoftDate[]=__DATE__;
  65          char code SoftTime[]=__TIME__;
  66          
  67          extern int sprintf(char *, const char *, ...);
  68          
  69          #define RSTB IO0
  70          #define TUALMO IO2
  71          #define HAPPAN_SWITCH IO4   // 外部中断2,上升沿中断
  72          #define TUXAB IO5 //TUXAB为主备交叉时钟盘XCU有效指示信号,主用XCU有效时TUXAB=0,备用XCU有效TUXAB=1
  73          #define WP IO6     //E1-63A盘在正常槽位时WP=1,在保护槽位时WP=0//
  74          #define TUSWTI IO7 //本盘almnumber大于一定值时,TUALMO=1,XCU盘收到TUALMO=1时,产生TUSWTI=0//
  75          #define P2V5 IO8
  76          #define P5VI1 IO9
  77          #define P5VI2 IO10
  78          #define DZBI1 IO11
  79          #define DZBI2 IO12
  80          extern unsigned char g_AllClrFlag;
  81          extern unsigned char g_LampEn;
  82          unsigned int ulEsLimit,ulSesLimit;
  83          //unsigned int WGS21891,wgs21891reg0[4],wgs21891reg1[4];
  84          unsigned int sw1021Chip;
  85          unsigned int N1000[63],BIP[63],BIP_2_1S[63],BIP_2_1000S[63];
  86          unsigned char actnumber,almnumber,first_conf;
  87          //unsigned char g_haveTux;
  88          /*
  89          code unsigned char slot[64]={1,22,43,4,25,46,7,
  90          28,49,10,31,52,13,34,
  91          55,16,37,58,19,40,61,
  92          
  93          2,23,44,5,26,47,8,
  94          29,50,11,32,53,14,35,
  95          56,17,38,59,20,41,62,
  96          
  97          3,24,45,6,27,48,9,
  98          30,51,12,33,54,15,36,
  99          57,18,39,60,21,42,63,0};
 100              */
 101          /*
 102          code unsigned char slot[64]={0x00,0x20,0x40,0x01,0x21,0x41,0x02,
 103                               0x22,0x42,0x03,0x23,0x43,0x04,0x24,
 104                               0x44,0x05,0x25,0x45,0x06,0x26,0x46,
 105          
 106                               0x07,0x27,0x47,0x08,0x28,0x48,0x09,
 107                               0x29,0x49,0x0a,0x2a,0x4a,0x0b,0x2b,
 108                               0x4b,0x0c,0x2c,0x4c,0x0d,0x2d,0x4d,
 109          
 110                               0x0e,0x2e,0x4e,0x0f,0x2f,0x4f,0x10,
 111                               0x30,0x50,0x11,0x31,0x51,0x12,0x32,
 112                               0x52,0x13,0x33,0x53,0x14,0x34,0x54,
 113                               0
 114                          };    
 115          */
 116          code unsigned char slot[64]={0x00,0x07,0x0e,0x01,0x08,0x0f,0x02,
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 3   

 117                               0x09,0x10,0x03,0x0a,0x11,0x04,0x0b,
 118                               0x12,0x05,0x0c,0x13,0x06,0x0d,0x14,
 119          
 120                               0x20,0x27,0x2e,0x21,0x28,0x2f,0x22,
 121                               0x29,0x30,0x23,0x2a,0x31,0x24,0x2b,
 122                               0x32,0x25,0x2c,0x33,0x26,0x2d,0x34,
 123          
 124                               0x40,0x47,0x4e,0x41,0x48,0x4f,0x42,
 125                               0x49,0x50,0x43,0x4a,0x51,0x44,0x4b,
 126                               0x52,0x45,0x4c,0x53,0x46,0x4d,0x54,
 127                               0
 128                          };
 129          
 130              
 131          static void writeTxJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 132          {
 133   1        int copOk = 0;
 134   1        int busBase = A_BUS_BASE;
 135   1        int i = 5;
 136   1        if(busB)
 137   1          busBase = B_BUS_BASE;
 138   1        // write  Tx J2 data
 139   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_DATA_REG(busBase)] = j2;
 140   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_WHICH_REG(busBase)] = witchJ2;
 141   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_SLOT_REG(busBase)] = RW_SEL | Slot;
 142   1        while(!copOk){
 143   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_RAM_STATUS_REG(busBase)] & 0x01;
 144   2          i--;
 145   2          if(i == 0)
 146   2            break;
 147   2          //Delay(1);
 148   2        }
 149   1      }
 150          
 151          static void writeExpectJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 152          {
 153   1        int copOk = 0;
 154   1        int busBase = A_BUS_BASE;
 155   1        int i = 5;
 156   1        if(busB) 
 157   1          busBase = B_BUS_BASE;
 158   1        // write  Tx J2 data
 159   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)] = j2;
 160   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = EXPECT_J2 |  witchJ2;
 161   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] = RW_SEL | Slot;
 162   1        while(!copOk){
 163   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 164   2          i--;
 165   2          if(i == 0)
 166   2            break;
 167   2          //Delay(1);
 168   2        }
 169   1      }
 170          
 171          static void readRxJ2(char chip, char witchJ2, char Slot, char *j2, char busB)
 172          {
 173   1        int copOk = 0;
 174   1        int busBase = A_BUS_BASE;
 175   1        int i = 5;
 176   1        if(busB) 
 177   1          busBase = B_BUS_BASE;
 178   1        
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 4   

 179   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = RECEV_J2 |  witchJ2;
 180   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] =  Slot;
 181   1        while(!copOk){
 182   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 183   2          i--;
 184   2          if(i == 0)
 185   2            break;
 186   2          //Delay(1);
 187   2        }
 188   1        if(copOk){
 189   2          *j2 = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)];
 190   2        }else{
 191   2          *j2 = -1;
 192   2        }
 193   1        
 194   1      }
 195          
 196          /*****************************************************************
 197          ** 函数名:GETDATA
 198          ** 输　入: 无
 199          ** 输　出: 无
 200          ** 功能描述：采集单盘告警和性能
 201          ** 全局变量：无
 202          ** 调用模块：无
 203          ** 作　者：翁益晖
 204          ** 日　期：2002.5.25
 205          ** 修　改：
 206          ** 日　期：
 207          ** 版  本：1.0
 208          ****************************************************************/
 209          void GetData()          
 210          {
 211   1        unsigned char i,m,n,mi,ni,tmp,tmpi,ADCLK,PPILOS,TULOP,LPSLM,LPTIM,LPTIU,LPRDI,LPRFI,LPUNEQ,TUAIS,PPIAIS,
 212   1        LOOP,LOOPL,tv5;
 213   1        unsigned int  LPFEBE,HDB3;
 214   1        unsigned char lopCnt = 0;
 215   1        actnumber=0;
 216   1        almnumber=0;
 217   1        sw1021Chip = SW1021;
 218   1        for(i=0;i<(LINENUM-1);i++)
 219   1        {          
 220   2          
 221   2          if(g_ucState[78+i]==0)
 222   2          {
 223   3            g_ucLineMask[i]=1;
 224   3            // ADCLK 告警 (A 路下行时钟告警 )
 225   3            ADCLK=XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC; 
 226   3      
 227   3          }
 228   2          else   
 229   2          {
 230   3            m=i/21;
 231   3            n=i%21;
 232   3            mi=i/8;
 233   3            ni=i%8;
 234   3            
 235   3            sw1021Chip = SW1021_CHIP_ADDR(m);
 236   3            
 237   3            if(TULOP||TUAIS)
 238   3              g_ucLofFlag[i]=1;      //有TULOP,TUAIS,PPILOS告警之一时上报UAS
 239   3            else
 240   3              g_ucLofFlag[i]=0;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 5   

 241   3            
 242   3            actnumber=actnumber+g_ucConfData[64+i];
 243   3            
 244   3            ADCLK = XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC;
 245   3            tmp = XBYTE[sw1021Chip+PORT_E1_ALARM_REG(n)];
 246   3            PPIAIS = tmp & E1AIS;
 247   3            PPILOS = tmp & E1LOS;
 248   3          /*
 249   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 250   3            TULOP = tmp & LOPI;
 251   3            TUAIS = tmp & AISI;
 252   3            LPSLM = tmp & PLMI;
 253   3            LPTIM = tmp & RTIMI;
 254   3            LPTIU = tmp & RTIUI;
 255   3            LPRDI = tmp & RDII;
 256   3            LPRFI = tmp & RFII;
 257   3            LPUNEQ = tmp & UNEQI;
 258   3          */
 259   3            
 260   3            tmpi = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 261   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG(A_BUS_BASE, n)] | tmpi;
 262   3            TULOP = tmp & LOPV;
 263   3            TUAIS = tmp & AISV;
 264   3            LPSLM = tmp & PLMV;
 265   3            LPTIM = tmp & RTIMV;
 266   3            LPTIU = tmp & RTIUV;
 267   3            LPRDI = tmp & RDIV;
 268   3            LPRFI = tmp & RFIV;
 269   3            LPUNEQ = tmp & UNEQV;
 270   3            
 271   3            if(TULOP) lopCnt++;
 272   3            
 273   3          #ifdef AIS_CONDITIONS 
 274   3            /** 方法1： 手动 */
 275   3            //AIS 产生条件 ---add by caijun.Li
 276   3            if(((g_ucConfData[2531] & 0x80) && LPTIM) || ((g_ucConfData[2531] & 0x40) && LPUNEQ ) || ((g_ucConfData
             -[2531] & 0x20) && LPSLM ) /* || ((g_ucConfData[2531] & 0x10) && LPSD )*/ ){
 277   4              // 下插AIS
 278   4              XBYTE[sw1021Chip + PORT_CFG_REG(n)] |= RAISEN;
 279   4            }else{
 280   4              // 停止下插AIS
 281   4              XBYTE[sw1021Chip + PORT_CFG_REG(n)] &= ~RAISEN;
 282   4            }
 283   3              
 284   3          #endif
 285   3            
 286   3            
 287   3            //must be write BIPERR_COUNTER_REG ; see manual
 288   3            XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 289   3            g_liError1s[i].ulDatlong += XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+BIP
             -ERR_COUNTER_REG(A_BUS_BASE, n) + 1] * 256);   // BIP错误计数值
 290   3            //must be write REI_COUNTER_REG ; see manual
 291   3            XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 292   3            LPFEBE = XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BAS
             -E, n) + 1] * 256); //REI(FEBE)计数值
 293   3            
 294   3            tmp = XBYTE[sw1021Chip + PORT_TEST_REG(n)];
 295   3                  
 296   3            LOOPL =  tmp & E1LBK;
 297   3            LOOP =   tmp & LnLBK;
 298   3            
 299   3            if((g_ucConfData[200+mi]&(0x01<<ni))==0)
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 6   

 300   3            {
 301   4              g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;
 302   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)].ucState=1;           
 303   4              else                                              //E1输入口有信号时/// 
 304   4              {
 305   5                if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==1)  //如果还存在PPILOS告警//
 306   5                if(WP==1)                        //非保护盘位时//
 307   5                {
 308   6                  // 向第i通道上话方向插短时间的伪随机码
 309   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 310   6                  g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS//
 311   6          
 312   6                  Delay(10);
 313   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &=  ~(PRBSEN | PRBST); //停插伪随机码
 314   6      
 315   6                }
 316   5                else g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS////保护盘位时//
 317   5              }
 318   4      
 319   4            }
 320   3            else
 321   3            {
 322   4              g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;
 323   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;               
 324   4              else  g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=1;
 325   4            }              
 326   3            //if(PPIAIS) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;               
 327   3            //else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 328   3            if(TULOP) g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=1;              
 329   3            else g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=0;  
 330   3            if(TUAIS) g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=1;              
 331   3            else g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=0;
 332   3            if(TULOP||TUAIS)
 333   3            {
 334   4              g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 335   4              g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 336   4              g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 337   4              #ifdef NEED_LP_RFI
                      g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
                      #endif
 340   4              g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0; 
 341   4            }
 342   3            else
 343   3            {
 344   4              if(LPSLM) g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=1;              
 345   4              else g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 346   4              if(LPRDI) g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=1;              
 347   4              else g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 348   4              if(LPUNEQ) g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=1;               
 349   4              else g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 350   4      
 351   4              /* 烽火老设备未使用RFI,不使用时将下面两句屏蔽 */
 352   4      #ifdef NEED_LP_RFI
                       if(LPRFI) g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=1;              
                       else g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
              #endif
 356   4              
 357   4              if(LPTIM) g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=1;              
 358   4              else g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0;  
 359   4            }
 360   3            if(LOOPL) g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=1;               
 361   3            else g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=0;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 7   

 362   3            if(LOOP) g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=1;              
 363   3            else g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=0;
 364   3            if(g_stuPm[i*PMTYPENUM+3].Value.usint>=(0xffff-LPFEBE)) g_stuPm[i*PMTYPENUM+3].Value.usint=0xffff;     
             -  
 365   3            else g_stuPm[i*PMTYPENUM+3].Value.usint+=LPFEBE;   //REI(FEBE)性能值                    
 366   3            if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==0)                               //无PPI_LOS告警时
 367   3            {
 368   4               //HDB3编码违例计数值
 369   4              HDB3 = XBYTE[sw1021Chip + HDB3_CV_REG(n)];
 370   4              
 371   4              if(g_stuPm[i*PMTYPENUM+4].Value.usint>=(0xffff-HDB3)) g_stuPm[i*PMTYPENUM+4].Value.usint=0xffff;     
 372   4              else g_stuPm[i*PMTYPENUM+4].Value.usint+=HDB3;      // HDB3性能值         //g_stuPm[i][4]=HDB3CV
 373   4            }           
 374   3      
 375   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState)
 376   3            almnumber=almnumber+1;
 377   3            
 378   3            tv5 = XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)];
 379   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3
             -)+4].ucState)
 380   3            { //如果TUAIS,TULOP,LPUNEQ之一为"1" 则向上插VC12=AIS,LPRDI,向下插AIS
 381   4                if((tv5 & RDI_CNF) != RDI_CNF)
 382   4                  XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 | RDI_CNF;
 383   4            }
 384   3            else
 385   3            {
 386   4              if((tv5 & RDI_CNF) == RDI_CNF)
 387   4                XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 & (~RDI_CNF);
 388   4            }
 389   3          }
 390   2        }
 391   1      
 392   1        for(i=0;i<(LINENUM-1);i++)
 393   1        {
 394   2          m=i/21;
 395   2          n=i%21;
 396   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 397   2          // 获取N2 和 K4 值
 398   2          //TODO: get N2
 399   2          //g_ucState[204+2*i]=XBYTE[WGS21891+0x0100+0x10*n+0x0C]; 
 400   2          g_ucState[205+2*i]=XBYTE[sw1021Chip + RX_K4_REG(A_BUS_BASE,n)];
 401   2          
 402   2          
 403   2          mi=i/8;
 404   2          ni=i%8;
 405   2          if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 406   2            g_ucState[330+mi]&=(~(0x01<<ni));
 407   2      
 408   2          else
 409   2            g_ucState[330+mi]|=(0x01<<ni);    
 410   2      
 411   2          //  tv5=XBYTE[WGS21891+0x0100+0x10*n+0x00];
 412   2      
 413   2        }
 414   1      
 415   1         
 416   1      
 417   1        if(TUXAB) g_ucState[77]=0;
 418   1        else g_ucState[77]=1;
 419   1                           
 420   1             
 421   1        if((WP==0) && (TUSWTI==0))   //保护盘位时,如果没有倒换ACT灯慢闪//     
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 8   

 422   1        {
 423   2          g_ucState[76]=0;
 424   2          g_LampEn=0;        
 425   2          if(g_stuSysClock.ucSecond%2==0) ACT=ON;
 426   2          else ACT=OFF;
 427   2          for(i=0;i<(LINENUM-1);i++)
 428   2          {
 429   3            g_ucLineMask[i]=1;
 430   3            g_ucState[141+i]=1;
 431   3          }
 432   2        }
 433   1        else if(g_ucState[76]==0)
 434   1        {                           
 435   2          for(i=0;i<(LINENUM-1);i++)
 436   2          {
 437   3            if((g_ucConfData[64+i]==0)||(g_ucConfData[137+i]==01))
 438   3            {    
 439   4              g_ucLineMask[i]=1;
 440   4              g_ucState[141+i]=1;  
 441   4            }   
 442   3            else
 443   3            {
 444   4              g_ucLineMask[i]=0;  
 445   4              g_ucState[141+i]=0;
 446   4            }
 447   3          }
 448   2          g_ucState[76]=1;     
 449   2          g_LampEn=1;
 450   2          WROUTPORT;           
 451   2        }
 452   1             
 453   1        UasClear();
 454   1      
 455   1      
 456   1        if(g_AllClrFlag)                //清性能
 457   1        {   
 458   2          g_bClearUas=1; 
 459   2          g_AllClrFlag=0;
 460   2        }
 461   1      
 462   1        if(g_SecondFlag)                   //秒标识，1：进入新的一秒
 463   1        {
 464   2          CalUas(ulSesLmt);           //uas计算        
 465   2      
 466   2          for(i=0; i<(LINENUM-1); i++)
 467   2          {
 468   3            g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];         //bbe_lp性能的采集
 469   3            g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];        //es_lp性能的采集
 470   3            g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];       //ses_lp性能的采集
 471   3            if(g_usiEs[i]>=ulEsLimit) 
 472   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=1;    //curalm[i][8]=es_limit
 473   3            else 
 474   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=0;
 475   3            // if(g_usiSes[i]>=ulSesLimit) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;    //curalm[i][9]=ses_limit
 476   3            // else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 477   3            g_stuPm[i*PMTYPENUM+5].Value.usint=g_usiUas[i];             //UAS_LP性能的采集
 478   3            g_stuPm[i*PMTYPENUM+6].Value.usint=g_usiCses[i];            //cses_lp性能的采集
 479   3      
 480   3      
 481   3            /******************************************************************************/
 482   3            if(g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3)+1].ucState)
 483   3            {
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 9   

 484   4              g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 485   4              BIP[i]=0;
 486   4            }
 487   3            else
 488   3            {
 489   4              BIP_2_1S[i]=BIP[i];
 490   4              BIP_2_1000S[i]+=BIP[i];  
 491   4              BIP[i]=0;
 492   4              switch(g_ucConfData[129])
 493   4              {
 494   5                case 0x04:
 495   5                if(BIP_2_1S[i]>=217) 
 496   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 497   5                else if(BIP_2_1S[i]<=23) 
 498   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 499   5                break;
 500   5      
 501   5                case 0x05:
 502   5                if(BIP_2_1S[i]>=22) 
 503   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 504   5                else if(BIP_2_1S[i]<=3) 
 505   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 506   5                break;
 507   5      
 508   5                case 0x06:
 509   5      
 510   5      
 511   5                if((N1000[i]>=10)&&(N1000[i]<100))
 512   5                {
 513   6                  if(BIP_2_1000S[i]>=22) 
 514   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 515   6                  else if(BIP_2_1000S[i]<=3) 
 516   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 517   6                  N1000[i]=0;
 518   6                  BIP_2_1000S[i]=0;
 519   6                }
 520   5                else N1000[i]++;
 521   5      
 522   5                break;
 523   5      
 524   5                case 0x07:
 525   5      
 526   5      
 527   5                if((N1000[i]>=100)&&(N1000[i]<1000))
 528   5                {
 529   6                  if(BIP_2_1000S[i]>=22) 
 530   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 531   6                  else if(BIP_2_1000S[i]<=3) 
 532   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 533   6                  N1000[i]=0;
 534   6                  BIP_2_1000S[i]=0;
 535   6                }
 536   5                else N1000[i]++;
 537   5                break;
 538   5      
 539   5                case 0x08:
 540   5      
 541   5      
 542   5                if(N1000[i]>=1000)
 543   5                {
 544   6                  if(BIP_2_1000S[i]>=22) 
 545   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 10  

 546   6                  else if(BIP_2_1000S[i]<=3) 
 547   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 548   6                  N1000[i]=0;
 549   6                  BIP_2_1000S[i]=0;
 550   6                }
 551   5                else 
 552   5                  N1000[i]++;
 553   5                break;
 554   5              }
 555   4            }
 556   3      
 557   3          /********************************************************************************/
 558   3      
 559   3          }
 560   2      
 561   2          g_SecondFlag=0;      //秒标识清?
 562   2      
 563   2        }     
 564   1      
 565   1        //IO8=1;
 566   1        // WRHIO;
 567   1        //RDHIO;    
 568   1        //IO9=1;
 569   1        // WRHIO;
 570   1        //RDHIO;
 571   1        //IO10=1;
 572   1        // WRHIO;
 573   1        //RDHIO;
 574   1        //IO11=1;
 575   1        // WRHIO;
 576   1        //RDHIO;
 577   1        //IO12=1;
 578   1        // WRHIO;
 579   1        RDHIO;
 580   1      
 581   1         
 582   1             
 583   1        if(ADCLK||(P2V5==0)||(first_conf==0)) 
 584   1          TUALMO=1; //如果工作支路中全部有告警或2.5V//
 585   1        else 
 586   1          TUALMO=0; //电源有告警或下配置前TUALMO=1,否则TUALMO=0//
 587   1        if((P5VI1==0)&&(DZBI1==0)) 
 588   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=1;
 589   1        else    
 590   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=0;               
 591   1        if((P5VI2==0)&&(DZBI2==0)) 
 592   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=1;
 593   1        else    
 594   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=0;       
 595   1        if(P2V5==0) 
 596   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=1;
 597   1        else    
 598   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=0;                     
 599   1       
 600   1      }
 601          
 602          /*****************************************************************
 603          ** 函数名:USERFUN
 604          ** 输　入: 无
 605          ** 输　出: 无
 606          ** 功能描述：用户实时处理函数，10毫秒被调用一次
 607          ** 全局变量：无
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 11  

 608          ** 调用模块：无
 609          ** 作　者：翁益晖
 610          ** 日　期：2002.5.25
 611          ** 修　改：
 612          ** 日　期：
 613          ** 版  本：1.0
 614          ****************************************************************/
 615          void UserFunc() using 1
 616          {
 617   1        #if 0
                int i,j;
                int tmp;
                unsigned int chip  = SW1021;
                static int docnt = 0;
                if(g_haveTux){
                  if(docnt == 0){
                    XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
                    
                    XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
                    
                    XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
                    docnt++;
                    return;
                  }
                  if(docnt > 2){
                    docnt = 0;
                    g_haveTux = 0;
                  }
                  for(i=0; i<CHIPS_ON_BOARD; i++){
                    for(j=0; j< 21; j++){
                      tmp = XBYTE[chip+PORT_E1_ALARM_REG(j)];
                      if((tmp & RFFERR) == 0){
                        continue;
                      }else{
                        //XBYTE[SW1021_CHIP_ADDR(k) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
                        XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
                        
                        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
                        
                        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
                      
                        g_haveTux = 0;
                        docnt = 0;
                        return;
                      }
                    }
                    chip+=0x1000;
                  }
                  docnt++;
                }
                #endif
 665   1        return;
 666   1      }
 667          
 668          /*
 669          //static void ChecktuxAB (void) interrupt 9 using 3
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 12  

 670          static void ChecktuxAB (void) interrupt 9
 671          {
 672          
 673            EX3 = 0;
 674            EXIF &= 0xDF;
 675            g_haveTux = 1;
 676          
 677          
 678            EX3 = 1;
 679            return;
 680          }
 681          */
 682          
 683          static void happenSwich (void) interrupt 8
 684          {
 685   1      
 686   1        EX2 = 0;
 687   1        EXIF &= 0xEF;
 688   1        //g_haveTux = 1;
 689   1        
 690   1        XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
 691   1        XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
 692   1                
 693   1        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
 694   1        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
 695   1                
 696   1        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
 697   1        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
 698   1        
 699   1      
 700   1        EX2 = 1;
 701   1        return;
 702   1      }
 703          
 704          /*****************************************************************
 705          ** 函数名:CONF_SET
 706          ** 输　入: 无
 707          ** 输　出: 无
 708          ** 功能描述：单盘配置
 709          ** 全局变量：无
 710          ** 调用模块：无
 711          ** 作　者：caijun.Li
 712          ** 日　期：2016.3.19
 713          ** 修　改：
 714          ** 日　期：
 715          ** 版  本：1.0
 716          ****************************************************************/
 717          void ConfSet(void)
 718          {
 719   1          /*Process ALMMASK*/
 720   1          /*Process PMMASK*/
 721   1        unsigned char i,j,ilong,m,n,temp;
 722   1      
 723   1        g_ucState[69]=g_ucConfData[5];
 724   1        g_ucState[70]=g_ucConfData[6];
 725   1        g_ucState[71]=g_ucConfData[7];
 726   1        g_ucState[72]=g_ucConfData[8];
 727   1        g_ucState[73]=g_ucConfData[9];
 728   1        g_ucState[74]=g_ucConfData[10];
 729   1        g_ucState[75]=g_ucConfData[11];
 730   1        for(i=0;i<(LINENUM-1);i++){
 731   2          m=i/21;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 13  

 732   2          n=i%21;
 733   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 734   2        
 735   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 736   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 737   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 738   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 739   2      
 740   2          if(g_ucConfData[64+i]==0){  // 支路关闭
 741   3            // 上下话强发AIS
 742   3            //XBYTE[sw1021Chip + TX_CTRL_REG(B_BUS_BASE,n)] = AIS_EN; 
 743   3            temp = XBYTE[sw1021Chip + PORT_CFG_REG(n)];
 744   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = temp | TAISEN | RAISEN; 
 745   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = 0x00;
 746   3                  
 747   3            g_ucState[78+i]=0;     
 748   3            g_ucLineMask[i]=1;
 749   3            g_ucState[141+i]=1;
 750   3          }else{  // 支路打开
 751   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = A_UP_DOWN | RnEN;
 752   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = (0x02 << 1);  // 注意信号标记值得配置
 753   3            if(g_ucState[78+i]==0)//刚打开支路开关时插伪随机码
 754   3            {
 755   4              //TODO: 启动误码计数器
 756   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 757   4              Delay(5);
 758   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= ~(PRBSEN | PRBST);
 759   4              g_ucState[78+i]=1;
 760   4              g_ucLineMask[i]=0; 
 761   4              g_ucState[141+i]=0;
 762   4            }         
 763   3          }
 764   2          XBYTE[sw1021Chip + TX_K4_REG(A_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 765   2          XBYTE[sw1021Chip + TX_K4_REG(B_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 766   2          // TODO: N2 发
 767   2          //XBYTE[WGS21891+0x0100+0x10*n+0x01]=g_ucConfData[263+4*i];                 // N2 发
 768   2        
 769   2        #ifdef AIS_CONDITIONS_AUTO
                  if((g_ucConfData[2531] & 0x80)){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }else{
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }
                  if(g_ucConfData[2531] & 0x40){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= UNEQAISE;
                  }
                  if(g_ucConfData[2531] & 0x20){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= PLMAISE;
                  }
                #endif
 782   2        
 783   2          // J2 发 和 期望收
 784   2          for(j=0;j<16;j++)
 785   2          {
 786   3            if(j==0) temp=0x80;
 787   3            else temp=0;
 788   3            
 789   3            // A 
 790   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 0);
 791   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 0);
 792   3            // B
 793   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 1);
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 14  

 794   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 1);
 795   3          }
 796   2          
 797   2          if(g_ucConfData[137+i]==0)   //confdata[137+i]==0不屏蔽支路i告警/否则屏蔽支路i告警//
 798   2          {
 799   3            g_ucLineMask[i]=0;
 800   3            g_ucState[141+i]=0;
 801   3          }
 802   2          else
 803   2          {
 804   3            g_ucLineMask[i]=1;
 805   3            g_ucState[141+i]=1;
 806   3          }
 807   2        //if(g_ucConfData[200+i]==0)     //confdata[200+i]==1支路i装载/否则不装载//
 808   2        //XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x00;
 809   2        // else  XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x04;
 810   2      
 811   2        }
 812   1      
 813   1      
 814   1      
 815   1        for(j=0;j<ALMTYPENUM;j++) 
 816   1        {
 817   2           
 818   2           for(ilong=29;ilong<(29+ALMTYPENUM);ilong++)
 819   2           {    
 820   3              if(g_ucConfData[ilong]==g_ucAlmCode[j])   //从网管设告警屏蔽//
 821   3              {
 822   4               g_ucAlmMask[j]=1;                              
 823   4               break;     
 824   4              }
 825   3              else
 826   3              g_ucAlmMask[j]=0;
 827   3      
 828   3           }
 829   2        }      
 830   1                          
 831   1        for(j=0;j<PMTYPENUM;j++)  
 832   1        {
 833   2      
 834   2          for(ilong=54;ilong<(54+PMTYPENUM);ilong++)
 835   2          {   
 836   3            if(g_ucConfData[ilong]==g_ucPmCode[j])   //从网管设性能屏蔽//
 837   3            {
 838   4              g_ucPmMask[j]=1;                              
 839   4              break;    
 840   4            }
 841   3            else
 842   3              g_ucPmMask[j]=0;
 843   3          }
 844   2        }        
 845   1      
 846   1        ulEsLimit=256*g_ucConfData[131]+g_ucConfData[132];    //从网管设ulEsLimit门限//
 847   1        ulSesLimit=256*g_ucConfData[134]+g_ucConfData[135];   //从网管设ulSesLimit门限//
 848   1      
 849   1      
 850   1        //if((g_ucConfData[136]==0)&&TUALMO&&WP) TUALMO=0;  //IO2=TUALMO  confdata[108]=盘保护模式不保护
 851   1      
 852   1      
 853   1        // g_ucConfChange=0;                          
 854   1              
 855   1      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 15  

 856   1        if(first_conf==0) first_conf=1; 
 857   1      }
 858          
 859          
 860          /*****************************************************************
 861          ** 函数名:UserHdlc
 862          ** 输　入: 无
 863          ** 输　出: 无
 864          ** 功能描述：单盘特殊命令处理
 865          ** 全局变量：无
 866          ** 调用模块：无
 867          ** 作　者：caijun.Li
 868          ** 日　期：2016.3.19
 869          ** 修　改：
 870          ** 日　期：
 871          ** 版  本：1.0
 872          ****************************************************************/
 873          void UserHdlc(void)
 874          {
 875   1        unsigned char i,j,m,n,temp;
 876   1        unsigned int addr;
 877   1        char val;
 878   1      
 879   1        if (g_ucHdlcBuf[CMD_TYPE]==COMM_CATA)
 880   1        {
 881   2          if (g_ucHdlcBuf[CMD_CODE]==RTRV_OCONF)
 882   2          {
 883   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;
 884   3          }
 885   2          else if (g_ucHdlcBuf[CMD_CODE]==SET_OCONF)
 886   2          {
 887   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;                                               
 888   3          }
 889   2        }
 890   1      
 891   1      
 892   1        switch(g_ucHdlcBuf[5])
 893   1        {
 894   2          case 0x00:    /*SET_LOOP*/
 895   2            if(g_ucHdlcBuf[6]==0x34)
 896   2            { // 设备环回
 897   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 898   3                g_ucHdlcBuf[10]=0x80; 
 899   3              else                
 900   3                for(i=0;i<(g_usRxDataLen);i++)
 901   3                {
 902   4                  temp=g_ucHdlcBuf[14+i]-1;
 903   4                  m=temp/21;
 904   4                  n=temp%21;
 905   4      
 906   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 907   4                  if(g_ucHdlcBuf[7]==0x01){
 908   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
 909   5                  }else{
 910   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
 911   5                  }
 912   4                  g_ucHdlcBuf[10]=0x00;
 913   4                }
 914   3            }
 915   2            else if(g_ucHdlcBuf[6]==0x33)       /*SET_LOOPL*/
 916   2            { // 线路环回 
 917   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 16  

 918   3                g_ucHdlcBuf[10]=0x80; 
 919   3              else                  
 920   3                for(i=0;i<(g_usRxDataLen);i++)
 921   3                {
 922   4                  temp=g_ucHdlcBuf[14+i]-1;
 923   4                  m=temp/21;
 924   4                  n=temp%21;
 925   4                  
 926   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 927   4                  if(g_ucHdlcBuf[7]==0x01){
 928   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= E1LBK;
 929   5                  }else{
 930   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~E1LBK);
 931   5                  }
 932   4                  g_ucHdlcBuf[10]=0x00;
 933   4                }
 934   3            }
 935   2            else if(g_ucHdlcBuf[6] == 0x45){  /* 请求报告J字节等辅助信息 */
 936   3              int addr = 0;
 937   3              g_ucHdlcBuf[10]=0x00;
 938   3              g_ucHdlcBuf[11]=0x00;
 939   3              g_ucHdlcBuf[12]=0x04;
 940   3              g_ucHdlcBuf[13]=0x6e;
 941   3            
 942   3              addr = 14;
 943   3              for(i=0; i<63; i++){
 944   4                m = i/21;
 945   4                n = i%21;
 946   4                g_ucHdlcBuf[addr++] = 0x02; //J2
 947   4                g_ucHdlcBuf[addr++] = i;   //TODO: 确认支路号是从0开始还是从1开始
 948   4                for(j=0;j<16;j++){
 949   5                  readRxJ2(m, j, slot[i], &val, 0);
 950   5                  g_ucHdlcBuf[addr++] = val; //J2 value
 951   5                }         
 952   4              } 
 953   3              g_ucHdlcBuf[10]=0x00;       
 954   3              
 955   3            }
 956   2            break;
 957   2          case 0x20:
 958   2             if(g_ucHdlcBuf[6] == 0x09){  /* 大网管请求报告J字节等辅助信息 */
 959   3              int addr = 0;
 960   3              g_ucHdlcBuf[10]=0x00;
 961   3              g_ucHdlcBuf[11]=0x00;
 962   3              g_ucHdlcBuf[12]=0x04;
 963   3              g_ucHdlcBuf[13]=0x6e;
 964   3            
 965   3              addr = 14;
 966   3              for(i=0; i<63; i++){
 967   4                m = i/21;
 968   4                n = i%21;
 969   4                g_ucHdlcBuf[addr++] = 0x02; //J2
 970   4                g_ucHdlcBuf[addr++] = i;   //TODO: 确认支路号是从0开始还是从1开始
 971   4                for(j=0;j<16;j++){
 972   5                  readRxJ2(m, j, slot[i], &val, 0);
 973   5                  g_ucHdlcBuf[addr++] = val; //J2 value
 974   5                }         
 975   4              }
 976   3              g_ucHdlcBuf[10]=0x00;         
 977   3              
 978   3            }
 979   2          break;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 17  

 980   2      
 981   2          case 0x77:                /**透明帧命令**/
 982   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];  // commbuf[14]，commbuf[15]所存放 的 地址
 983   2            g_ucHdlcBuf[10]=0x00;
 984   2            g_ucHdlcBuf[11]=0x00;
 985   2            g_ucHdlcBuf[12]=0x00;
 986   2            g_ucHdlcBuf[13]=0x11;
 987   2            //读16个字节//  addr 地址开始读取16个字节数据//
 988   2            for(i=0;i<16;i++) 
 989   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; 
 990   2            g_ucHdlcBuf[30]=P1;
 991   2            break;                   
 992   2          
 993   2          case 0x88:
 994   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];
 995   2            XBYTE[addr]=g_ucHdlcBuf[16];       //将commbuf[16]存放的数据送入commbuf[14]，//
 996   2            g_ucHdlcBuf[10]=0x00;              //commbuf[15]所存放的WGS21891的地址单元中//
 997   2            g_ucHdlcBuf[11]=0x00;
 998   2            g_ucHdlcBuf[12]=0x00;
 999   2            g_ucHdlcBuf[13]=0x10;              //读16个字节//
1000   2            for(i=0;i<16;i++) 
1001   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; //从commbuf[14]，commbuf[15]的地址开始读取16个字节数据//
1002   2            break;
1003   2      
1004   2          
1005   2          case 0X99:
1006   2            while(1)
1007   2            {;}
1008   2            if((g_usRxDataLen==0)||(g_usRxDataLen>63)) 
1009   2              g_ucHdlcBuf[10]=0x80; 
1010   2            else                
1011   2              for(i=0;i<(g_usRxDataLen);i++)
1012   2              {
1013   3                temp=g_ucHdlcBuf[14+i]-1;
1014   3                m=temp/21;
1015   3                n=temp%21;
1016   3                sw1021Chip = SW1021_CHIP_ADDR(m);
1017   3                          
1018   3                g_ucHdlcBuf[17]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
1019   3                g_ucHdlcBuf[18]=0xbb;
1020   3                
1021   3                if(g_ucHdlcBuf[7]==0x01)
1022   3                {
1023   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
1024   4                  if(n<8)
1025   4                    g_ucHdlcBuf[18]=0xff;
1026   4                }
1027   3                else
1028   3                {
1029   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
1030   4                }
1031   3                    
1032   3              }
1033   2            g_ucHdlcBuf[10]=0x00;
1034   2            g_ucHdlcBuf[13]=6;
1035   2            g_ucHdlcBuf[14]=0xaa;
1036   2            g_ucHdlcBuf[15]=m;
1037   2            g_ucHdlcBuf[16]=n;
1038   2            g_ucHdlcBuf[19]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
1039   2            
1040   2            break;
1041   2            
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 18  

1042   2      
1043   2        }
1044   1      
1045   1      }
1046          
1047          /*****************************************************************
1048          ** 函数名:SELF_CONF
1049          ** 输　入: 无
1050          ** 输　出: 无
1051          ** 功能描述：单盘上电默认配置
1052          ** 全局变量：g_ucConfData[]
1053          ** 调用模块：无
1054          ** 作　者：翁益晖
1055          ** 日　期：2002.5.25
1056          ** 修　改：
1057          ** 日　期：
1058          ** 版  本：1.0
1059          ** 注  意：所有告警和性能的初始化需安线路号顺序
1060          ****************************************************************/
1061          void SelfConf()
1062          {
1063   1      
1064   1        unsigned int i,j;
1065   1        char ctt[18];
1066   1        unsigned char ucii;
1067   1        //  first_conf=0;
1068   1        g_ucConfData[22]=BOARDCODE;/*BDINF5*/
1069   1        g_ucConfData[0]=0xfe;
1070   1      
1071   1      
1072   1        sprintf(ctt,BoardSn);
1073   1        for(ucii=0;ucii<15;ucii++) g_ucState[ucii]=ctt[ucii];  /*盘号*/
1074   1      
1075   1        sprintf(ctt,PcbSn);   
1076   1        for(ucii=0;ucii<15;ucii++) g_ucState[15+ucii]=ctt[ucii]; /*板号*/
1077   1      
1078   1        sprintf(ctt,PcbTime);   
1079   1        for(ucii=0;ucii<10;ucii++) g_ucState[30+ucii]=ctt[ucii]; /*制板时间*/
1080   1      
1081   1        for(ucii=0;ucii<18;ucii++) ctt[ucii]=0;    /*版本号buf清零*/
1082   1        //sprintf(ctt,"R170609R1B/01F    "); 
1083   1        //for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
1084   1        sprintf(ctt,BoardSoftVer); 
1085   1        for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
1086   1        sprintf(ctt,__DATE__);   
1087   1        for(ucii=0;ucii<11;ucii++) g_ucState[58+ucii]=ctt[ucii]; /*编程时间*/
1088   1      
1089   1        //g_ucState[69]=0x07;
1090   1        //g_ucState[70]=0xD1;
1091   1        //g_ucState[71]=0x06;
1092   1        //g_ucState[72]=0x01;
1093   1        //g_ucState[73]=0x08;
1094   1        //g_ucState[74]=0x00;
1095   1        //g_ucState[75]=0x00;
1096   1        g_ucState[76]=0x01;
1097   1        //g_ucState[77]=0x01;
1098   1      
1099   1      
1100   1      
1101   1        for(i=0;i<LINENUM;i++)           /*linecode=1..63*/
1102   1          g_ucLineCode[i]=i+1;
1103   1        for(i=0;i<LINENUM;i++)
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 19  

1104   1        {
1105   2          g_ucLineMask[i]=0;          
1106   2      
1107   2        }
1108   1      
1109   1      
1110   1      
1111   1        /*for(i=0;i<LINENUM;i++)
1112   1        for(j=0;j<PMNUM;j++) linepmmask[i][j]=0;*/         
1113   1      
1114   1      
1115   1        actnumber=63;             
1116   1        almnumber=0;     
1117   1      
1118   1        ulEsLimit=0xff;
1119   1        ulSesLimit=0xff;
1120   1      
1121   1        g_ucAlmCode[0]=0x03;                        /*PPI_LOS*/
1122   1        g_ucAlmCode[1]=0x27;                        /*TU_LOP*/
1123   1        g_ucAlmCode[2]=0x22;                        /*LP_SLM*/
1124   1        g_ucAlmCode[3]=0x20;                        /*LP_RDI*/
1125   1        g_ucAlmCode[4]=0x24;                        /*LP_UNEQ*/
1126   1        //g_ucAlmCode[8]=0x04;                        /*PPI_AIS*/
1127   1        g_ucAlmCode[5]=0x02;                        /*TU_AIS*/
1128   1      #ifdef NEED_LP_RFI
                g_ucAlmCode[15]=0x0c;                        /*LP_RFI*/
              #endif
1131   1        g_ucAlmCode[7]=0x51;                        /*ES_LIMIT*/
1132   1        //g_ucAlmCode[8]=0x52;      /*SES _LIMIT*/
1133   1        g_ucAlmCode[9]=0x28;                       /*LP_TIM*/
1134   1        g_ucAlmCode[10]=0x4f;                       /*LOOPL*/
1135   1        g_ucAlmCode[11]=0x55;     /*LOOP*/
1136   1        g_ucAlmCode[12]=0x01;                       //2V5电源故障告警//
1137   1        g_ucAlmCode[13]=0x05;                       //5VI1电源故障告警//
1138   1        g_ucAlmCode[14]=0x06;                       //5VI2电源故障告警//
1139   1        g_ucAlmCode[6]=0x07;                 //trafic-onload//
1140   1        g_ucAlmCode[8]=0x08;                /*LP_SD*/
1141   1      
1142   1        g_ucPmCode[0]=0x08;                   /*BBE_LP*/
1143   1        g_ucPmCode[1]=0x02;                   /*ES_LP*/
1144   1        g_ucPmCode[2]=0x03;                   /*SES_LP*/
1145   1        g_ucPmCode[3]=0x07;                   /*REI_LP*/
1146   1        g_ucPmCode[4]=0x0b;                   /*HDB3CV*/
1147   1        //g_ucPmCode[5]=0x06;                 /*UAS_LP*/
1148   1        g_ucPmCode[5]=0x0c;                   /*UAS_LP*/
1149   1        g_ucPmCode[6]=0xa2;                   /*CSES_LP*/
1150   1      
1151   1        g_ucAlmType[0]=0;   /*almtype：0急告；4非急告；8状态量*/
1152   1        g_ucAlmType[1]=0;
1153   1        g_ucAlmType[2]=0;
1154   1        g_ucAlmType[3]=4;
1155   1        g_ucAlmType[4]=4;
1156   1        g_ucAlmType[5]=4;
1157   1        g_ucAlmType[6]=8;
1158   1        g_ucAlmType[7]=4;
1159   1        g_ucAlmType[8]=4;
1160   1        g_ucAlmType[9]=0;      /*LP_TIM*/
1161   1        g_ucAlmType[10]=8;         
1162   1        g_ucAlmType[11]=8;  
1163   1        g_ucAlmType[12]=0;
1164   1        g_ucAlmType[13]=0;
1165   1        g_ucAlmType[14]=0;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 20  

1166   1        
1167   1      #ifdef NEED_LP_RFI
                g_ucAlmType[15]=4;
              #endif
1170   1      
1171   1        for(j=0;j<(LINENUM-1);j++)
1172   1        {
1173   2          for(i=0;i<(ALMTYPENUM-3);i++)
1174   2          {
1175   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucLineIndex=j;
1176   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucAlmIndex=i;
1177   3          }
1178   2        }
1179   1      
1180   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucLineIndex=63;
1181   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucAlmIndex=12;
1182   1      
1183   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucLineIndex=63;
1184   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucAlmIndex=13;
1185   1      
1186   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucLineIndex=63;
1187   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucAlmIndex=14;
1188   1      
1189   1      
1190   1        for(j=0;j<(LINENUM-1);j++)
1191   1        {
1192   2          for(i=0;i<PMTYPENUM;i++)
1193   2          {
1194   3            g_stuPm[j*PMTYPENUM+i].ucLineIndex=j;
1195   3            g_stuPm[j*PMTYPENUM+i].ucPmIndex=i;
1196   3          }
1197   2        }
1198   1      
1199   1        for(i=0;i<UASNUM;i++)
1200   1        {
1201   2          g_liError1s[i].ulDatlong=0;
1202   2          ulSesLmt[i]=700; //若某一秒内误码个数大于等于ulSesLmt[i]时,该秒是严重误码秒//
1203   2        }                  
1204   1      }
1205          
1206          
1207          
1208          /*****************************************************************
1209          ** 函数名:InitioSw1021
1210          ** 输　入: 无
1211          ** 输　出: 无
1212          ** 功能描述：SW1021初始化
1213          ** 全局变量：
1214          ** 调用模块：
1215          ** 作　者：caijun.Li
1216          ** 日　期：2016.3.18
1217          ** 修　改：
1218          ** 日　期：
1219          ** 版  本：1.0
1220          ****************************************************************/
1221          void InitioSw1021()
1222          {
1223   1      
1224   1        unsigned int i,j;
1225   1        unsigned char m,n;
1226   1        first_conf=0;
1227   1      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 21  

1228   1        for(i=0; i<CHIPS_ON_BOARD; i++)
1229   1        {
1230   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
1231   2          Delay(1);
1232   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = RST_CANCLE;
1233   2          
1234   2          // TODO: 并行总线时钟选择
1235   2          // SW1021只支持19.44Mbit/s 的传输速率
1236   2          
1237   2          
1238   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时  + V5 期望
             - 0x02
1239   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时
1240   2          
1241   2          XBYTE[SW1021_CHIP_ADDR(i) + SOMESET_REG(A_BUS_BASE)] = BLKBIP_BLOCK;  // BIP-2按块进行校验并计数
1242   2          
1243   2          XBYTE[SW1021_CHIP_ADDR(i) + RDI_RFI_CTRL_REG(A_BUS_BASE)] = MREI_AUTO | AISV_RDIEN | LOPV_RDIEN | LOMV_R
             -DIEN | UNEQV_RDIEN | PLMV_RDIEN | RTIMV_RDIEN | RTIUV_RDIEN;
1244   2          
1245   2          // 上下话数据总线均选择偶校验
1246   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)] = UP_DELAY_2;
1247   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)] = UP_DELAY_2;   
1248   2          
1249   2          // 21个端口从A总线上下话, 使用 +- HDB3模式
1250   2          for(j=0; j<21; j++){
1251   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)] = A_UP_DOWN | RnEN;
1252   3            // 关闭线路环回和系统环回
1253   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_TEST_REG(j)] = 0x00;
1254   3            // TODO: 上下话交叉状态选择 ： 不交叉
1255   3            
1256   3            // TODO: TU通道LOP\AIS告警检测设置： EN_TUAIS  使能TU-AIS 中断
1257   3            //                             EN_TULOP  使能TU-LOP 中断
1258   3            //                             
1259   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_E1_ALARM_INTERRPUT_MASK_REG(j)] = E1AISE | E1LOCE; //??
1260   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(A_BUS_BASE,j)] = LOPE | AISE;  
1261   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(B_BUS_BASE,j)] = LOPE | AISE;  
1262   3            //TODO： 读清中断指示
1263   3            
1264   3            //TODO: 不启动随机码测试； 启动误码计数
1265   3            
1266   3            //TODO: 上话V5-TX2 设置 LP-REI
1267   3            XBYTE[SW1021_CHIP_ADDR(i) + TX_V5_REG(A_BUS_BASE,j)] = (0x02 << 1);
1268   3            
1269   3            //TODO： 上下话通道号编码
1270   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1271   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1272   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1273   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1274   3            
1275   3            
1276   3          }
1277   2          // TODO:上下话时钟数据同相
1278   2          XBYTE[SW1021_CHIP_ADDR(i) + E1_CTRL_REG] = TRZSEL | RRZSEL;
1279   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_IF_CLK_REG] = 0x00;
1280   2      
1281   2        }
1282   1        
1283   1        // 填充所有支路的J2字节（初始化清0）
1284   1        for(i=0;i<63;i++)            
1285   1        {
1286   2          m=i/21;
1287   2          n=i%21;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 22  

1288   2          for(j=0;j<16;j++)
1289   2          {
1290   3            if(j==0)
1291   3            { // A 
1292   4              writeTxJ2(m, j, slot[i],  0x80, 0);
1293   4              writeExpectJ2(m, j, slot[i],  0x80, 0);
1294   4              // B
1295   4              writeTxJ2(m, j, slot[i],  0x80, 1);
1296   4              writeExpectJ2(m, j, slot[i],  0x80, 1);           
1297   4            }
1298   3            else
1299   3            {
1300   4              // A 
1301   4              writeTxJ2(m, j, slot[i],  0x00, 0);
1302   4              writeExpectJ2(m, j, slot[i],  0x00, 0);
1303   4              // B
1304   4              writeTxJ2(m, j, slot[i],  0x00, 1);
1305   4              writeExpectJ2(m, j, slot[i],  0x00, 1); 
1306   4            }
1307   3          }
1308   2        }
1309   1      
1310   1         IO8=1;
1311   1         IO9=1;
1312   1         IO10=1;
1313   1         IO11=1;
1314   1         IO12=1;
1315   1         WRHIO;
1316   1      
1317   1      }
1318          /*****************************************************************
1319          ** 函数名:checkSW1021Init
1320          ** 输　入: 无
1321          ** 输　出: 无
1322          ** 功能描述：检查SW1021初始化成功
1323          ** 全局变量：
1324          ** 调用模块：
1325          ** 作　者：caijun.Li
1326          ** 日　期：2016.3.18
1327          ** 修　改：
1328          ** 日　期：
1329          ** 版  本：1.0
1330          ****************************************************************/
1331          static int checkSW1021Init(void)
1332          {
1333   1        int ret = 0;
1334   1        int i,j;
1335   1        unsigned int reg;
1336   1        for(i=0;i<CHIPS_ON_BOARD;i++)
1337   1        {
1338   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)];
1339   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1340   3            ret = -1;
1341   3            break;
1342   3          }
1343   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)];
1344   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1345   3            ret = -1;
1346   3            break;
1347   3          }
1348   2          
1349   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)];
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 23  

1350   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1351   3            ret = -1;
1352   3            break;
1353   3          }
1354   2          
1355   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)];
1356   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1357   3            ret = -1;
1358   3            break;
1359   3          }
1360   2          
1361   2          for(j=0; j<21; j++){
1362   3            reg = XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)];
1363   3            if((reg & (A_UP_DOWN | RnEN)) != (A_UP_DOWN | RnEN)){
1364   4              ret = -1;
1365   4              goto quit;
1366   4            }
1367   3          }
1368   2      
1369   2        }
1370   1      quit:
1371   1        return ret;
1372   1      }
1373          
1374          /*****************************************************************
1375          ** 函数名:MAIN
1376          ** 输　入: 无
1377          ** 输　出: 无
1378          ** 功能描述：主函数
1379          ** 全局变量：g_QuarterFlag
1380          ** 调用模块：SelfConf(),GetData(),ProcHisData(),Debug();
1381          ** 作　者：caijun.Li
1382          ** 日　期：2016.3.18
1383          ** 修　改：
1384          ** 日　期：
1385          ** 版  本：1.0
1386          ****************************************************************/
1387          void main()
1388          {   
1389   1        unsigned char i;  
1390   1        int ret = 0;
1391   1        //Delay(50);
1392   1      
1393   1        SelfConf(); 
1394   1        
1395   1        ret = checkSW1021Init();
1396   1        if(ret != 0)
1397   1          InitioSw1021();
1398   1        
1399   1        // 使能外部中断2
1400   1        EX2 = 1;
1401   1        PX2 = 0;  // 低优先级
1402   1      
1403   1        while (1)
1404   1        {
1405   2          #ifdef SKIP_DEBUG_CHECK
                    #ifdef NEED_LP_RFI        
                        XBYTE[0x7fe5] = 1;
                    #else
                      //  XBYTE[0x7b74] = 1;
                        XBYTE[0x7b77] = 1;
                    #endif
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/27/2016 09:04:10 PAGE 24  

                  #endif
1413   2          
1414   2          //ACT = ~ACT;
1415   2          //RED = ~RED;
1416   2          //YELLOW = ~YELLOW;
1417   2              
1418   2          
1419   2          ret = checkSW1021Init();
1420   2          if(ret != 0){ 
1421   3            SelfConf(); 
1422   3            InitioSw1021();
1423   3            ConfSet();  
1424   3          }
1425   2        
1426   2          GetData();
1427   2          ProcAlmData();  
1428   2      
1429   2          if (g_QuarterFlag) 
1430   2          {
1431   3            UasQuarter();
1432   3            for(i=0;i<LINENUM;i++)
1433   3            {
1434   4              g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];
1435   4              g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];
1436   4              g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];
1437   4            }
1438   3            ProcHisData();  //将当前告警和性能数据存为历史数据//
1439   3            g_QuarterFlag=0;
1440   3          }
1441   2          
1442   2          Debug();
1443   2        }
1444   1      }
1445          
*** WARNING C294 IN LINE 1008 OF GF2488-01F1-E1-RST.C: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12066    ----
   CONSTANT SIZE    =    250    ----
   XDATA SIZE       =  22238     105
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
