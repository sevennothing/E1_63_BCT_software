C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE GF2488_01F1_E1_RST
OBJECT MODULE PLACED IN GF2488-01F1-E1-RST.OBJ
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE GF2488-01F1-E1-RST.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND T
                    -ABS(2)

line level    source

   1          /******************************************************************
   2          ** 文件名：STAND.C
   3          ** Copyright (c) 2002 烽火通信传输产品部BCT软件组
   4          ** 创建人：翁益晖
   5          ** 文件编号：
   6          ** 描　述：标准模版程序
   7          **         
   8          ** 日　期：2002.6.28
   9          ** 修改人：
  10          ** 日　期：
  11          ** 文件编号：
  12          ** 描　述：
  13          **
  14          **
  15          ** 编译器：Keil C51 V5.5 或 MCC68K V4.4
  16          ** 公共库：NewLib9.LIB for Mcs51
  17          **         或 NewLib1.LIB for Mc68302
  18          ** 版  本：1.0
  19          ********************************************************************/
  20          //#define  NEED_LP_RFI   /**  !!! 单盘起不来了  */
  21          #define AIS_CONDITIONS      /** 与 AIS_CONDITIONS_AUTO 二选一  */
  22          //#define AIS_CONDITIONS_AUTO
  23          #define SKIP_DEBUG_CHECK
  24          
  25          #define UASNUM    63        //要计算误码的线路数63//
  26          #define LINENUM   64        /*告警线路数为64*/
  27          #ifdef NEED_LP_RFI
                #define ALMNUM      822     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
                #define ALMTYPENUM      16      /*16种告警类型*/
              #else
  31            #define ALMNUM      759     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
  32            #define ALMTYPENUM      15      /*15种告警类型*/
  33          #endif
  34          
  35          #define PMNUM   441         /*总共63*PMTYPENUM个性能*/
  36          
  37          #define PMTYPENUM       7       /*7种性能类型*/
  38          #define CONFLEN   2560  /*配置数据长度为2560*/
  39          #define STATELEN  338   /*状态数据长度为338*/
  40          #define BOARDCODE 0x96  /*盘代码*/
  41          #define WGS21891A 0xB000
  42          
  43          #define SW1021  0xB000    //TODO：confirm
  44          
  45          #define SW1021_CHIP_ADDR(num)  (SW1021 + 0x1000*(num))
  46          #define CHIPS_ON_BOARD          3
  47          
  48          
  49          #include "commvar9.h"
  50          #include "uasE63.h"
  51          
  52          #include "sw1021.h"
  53          
  54          char code SysName[]="GF2488-01F";
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 2   

  55          char code BoardName[]="E1-63A";
  56          char code BoardSn[]="WKE2.170.609R1B";
  57          char code SoftVer[]="R170609R1B/01F    ";
  58          
  59          char code PcbSn[]="WKE7.822.828R1B";
  60          char code PcbTime[]="2004 05 02";
  61          
  62          char code BoardSoftVer[]="RP0100            ";
  63          
  64          char code SoftDate[]=__DATE__;
  65          char code SoftTime[]=__TIME__;
  66          
  67          extern int sprintf(char *, const char *, ...);
  68          
  69          #define RSTB IO0
  70          #define TUALMO IO2
  71          #define HAPPAN_SWITCH IO4   // 外部中断2,上升沿中断
  72          #define TUXAB IO5 //TUXAB为主备交叉时钟盘XCU有效指示信号,主用XCU有效时TUXAB=0,备用XCU有效TUXAB=1
  73          #define WP IO6     //E1-63A盘在正常槽位时WP=1,在保护槽位时WP=0//
  74          #define TUSWTI IO7 //本盘almnumber大于一定值时,TUALMO=1,XCU盘收到TUALMO=1时,产生TUSWTI=0//
  75          #define P2V5 IO8
  76          #define P5VI1 IO9
  77          #define P5VI2 IO10
  78          #define DZBI1 IO11
  79          #define DZBI2 IO12
  80          extern unsigned char g_AllClrFlag;
  81          extern unsigned char g_LampEn;
  82          unsigned int ulEsLimit,ulSesLimit;
  83          //unsigned int WGS21891,wgs21891reg0[4],wgs21891reg1[4];
  84          unsigned int sw1021Chip;
  85          unsigned int N1000[63],BIP[63],BIP_2_1S[63],BIP_2_1000S[63];
  86          unsigned char actnumber,almnumber,first_conf;
  87          unsigned char g_haveTux;
  88          /*
  89          code unsigned char slot[64]={1,22,43,4,25,46,7,
  90          28,49,10,31,52,13,34,
  91          55,16,37,58,19,40,61,
  92          
  93          2,23,44,5,26,47,8,
  94          29,50,11,32,53,14,35,
  95          56,17,38,59,20,41,62,
  96          
  97          3,24,45,6,27,48,9,
  98          30,51,12,33,54,15,36,
  99          57,18,39,60,21,42,63,0};
 100              */
 101          /*
 102          code unsigned char slot[64]={0x00,0x20,0x40,0x01,0x21,0x41,0x02,
 103                               0x22,0x42,0x03,0x23,0x43,0x04,0x24,
 104                               0x44,0x05,0x25,0x45,0x06,0x26,0x46,
 105          
 106                               0x07,0x27,0x47,0x08,0x28,0x48,0x09,
 107                               0x29,0x49,0x0a,0x2a,0x4a,0x0b,0x2b,
 108                               0x4b,0x0c,0x2c,0x4c,0x0d,0x2d,0x4d,
 109          
 110                               0x0e,0x2e,0x4e,0x0f,0x2f,0x4f,0x10,
 111                               0x30,0x50,0x11,0x31,0x51,0x12,0x32,
 112                               0x52,0x13,0x33,0x53,0x14,0x34,0x54,
 113                               0
 114                          };    
 115          */
 116          code unsigned char slot[64]={0x00,0x07,0x0e,0x01,0x08,0x0f,0x02,
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 3   

 117                               0x09,0x10,0x03,0x0a,0x11,0x04,0x0b,
 118                               0x12,0x05,0x0c,0x13,0x06,0x0d,0x14,
 119          
 120                               0x20,0x27,0x2e,0x21,0x28,0x2f,0x22,
 121                               0x29,0x30,0x23,0x2a,0x31,0x24,0x2b,
 122                               0x32,0x25,0x2c,0x33,0x26,0x2d,0x34,
 123          
 124                               0x40,0x47,0x4e,0x41,0x48,0x4f,0x42,
 125                               0x49,0x50,0x43,0x4a,0x51,0x44,0x4b,
 126                               0x52,0x45,0x4c,0x53,0x46,0x4d,0x54,
 127                               0
 128                          };
 129          
 130              
 131          static void writeTxJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 132          {
 133   1        int copOk = 0;
 134   1        int busBase = A_BUS_BASE;
 135   1        int i = 5;
 136   1        if(busB)
 137   1          busBase = B_BUS_BASE;
 138   1        // write  Tx J2 data
 139   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_DATA_REG(busBase)] = j2;
 140   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_WHICH_REG(busBase)] = witchJ2;
 141   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_SLOT_REG(busBase)] = RW_SEL | Slot;
 142   1        while(!copOk){
 143   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_RAM_STATUS_REG(busBase)] & 0x01;
 144   2          i--;
 145   2          if(i == 0)
 146   2            break;
 147   2          //Delay(1);
 148   2        }
 149   1      }
 150          
 151          static void writeExpectJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 152          {
 153   1        int copOk = 0;
 154   1        int busBase = A_BUS_BASE;
 155   1        int i = 5;
 156   1        if(busB) 
 157   1          busBase = B_BUS_BASE;
 158   1        // write  Tx J2 data
 159   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)] = j2;
 160   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = EXPECT_J2 |  witchJ2;
 161   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] = RW_SEL | Slot;
 162   1        while(!copOk){
 163   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 164   2          i--;
 165   2          if(i == 0)
 166   2            break;
 167   2          //Delay(1);
 168   2        }
 169   1      }
 170          
 171          static void readRxJ2(char chip, char witchJ2, char Slot, char *j2, char busB)
 172          {
 173   1        int copOk = 0;
 174   1        int busBase = A_BUS_BASE;
 175   1        int i = 5;
 176   1        if(busB) 
 177   1          busBase = B_BUS_BASE;
 178   1        
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 4   

 179   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = RECEV_J2 |  witchJ2;
 180   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] =  Slot;
 181   1        while(!copOk){
 182   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 183   2          i--;
 184   2          if(i == 0)
 185   2            break;
 186   2          //Delay(1);
 187   2        }
 188   1        if(copOk){
 189   2          *j2 = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)];
 190   2        }else{
 191   2          *j2 = -1;
 192   2        }
 193   1        
 194   1      }
 195          
 196          /*****************************************************************
 197          ** 函数名:GETDATA
 198          ** 输　入: 无
 199          ** 输　出: 无
 200          ** 功能描述：采集单盘告警和性能
 201          ** 全局变量：无
 202          ** 调用模块：无
 203          ** 作　者：翁益晖
 204          ** 日　期：2002.5.25
 205          ** 修　改：
 206          ** 日　期：
 207          ** 版  本：1.0
 208          ****************************************************************/
 209          void GetData()          
 210          {
 211   1        unsigned char i,m,n,mi,ni,tmp,tmpi,ADCLK,PPILOS,TULOP,LPSLM,LPTIM,LPTIU,LPRDI,LPRFI,LPUNEQ,TUAIS,PPIAIS,
 212   1        LOOP,LOOPL,tv5;
 213   1        unsigned int  LPFEBE,HDB3;
 214   1        unsigned char lopCnt = 0;
 215   1        actnumber=0;
 216   1        almnumber=0;
 217   1        sw1021Chip = SW1021;
 218   1        for(i=0;i<(LINENUM-1);i++)
 219   1        {          
 220   2          
 221   2          if(g_ucState[78+i]==0)
 222   2          {
 223   3            g_ucLineMask[i]=1;
 224   3            // ADCLK 告警 (A 路下行时钟告警 )
 225   3            ADCLK=XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC; 
 226   3      
 227   3          }
 228   2          else   
 229   2          {
 230   3            m=i/21;
 231   3            n=i%21;
 232   3            mi=i/8;
 233   3            ni=i%8;
 234   3            
 235   3            sw1021Chip = SW1021_CHIP_ADDR(m);
 236   3            
 237   3            if(TULOP||TUAIS)
 238   3              g_ucLofFlag[i]=1;      //有TULOP,TUAIS,PPILOS告警之一时上报UAS
 239   3            else
 240   3              g_ucLofFlag[i]=0;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 5   

 241   3            
 242   3            actnumber=actnumber+g_ucConfData[64+i];
 243   3            
 244   3            ADCLK = XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC;
 245   3            tmp = XBYTE[sw1021Chip+PORT_E1_ALARM_REG(n)];
 246   3            PPIAIS = tmp & E1AIS;
 247   3            PPILOS = tmp & E1LOS;
 248   3          /*
 249   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 250   3            TULOP = tmp & LOPI;
 251   3            TUAIS = tmp & AISI;
 252   3            LPSLM = tmp & PLMI;
 253   3            LPTIM = tmp & RTIMI;
 254   3            LPTIU = tmp & RTIUI;
 255   3            LPRDI = tmp & RDII;
 256   3            LPRFI = tmp & RFII;
 257   3            LPUNEQ = tmp & UNEQI;
 258   3          */
 259   3            
 260   3            tmpi = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 261   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG(A_BUS_BASE, n)] | tmpi;
 262   3            TULOP = tmp & LOPV;
 263   3            TUAIS = tmp & AISV;
 264   3            LPSLM = tmp & PLMV;
 265   3            LPTIM = tmp & RTIMV;
 266   3            LPTIU = tmp & RTIUV;
 267   3            LPRDI = tmp & RDIV;
 268   3            LPRFI = tmp & RFIV;
 269   3            LPUNEQ = tmp & UNEQV;
 270   3            
 271   3            if(TULOP) lopCnt++;
 272   3            
 273   3          #ifdef AIS_CONDITIONS 
 274   3            /** 方法1： 手动 */
 275   3            //AIS 产生条件 ---add by caijun.Li
 276   3            if(((g_ucConfData[2531] & 0x80) && LPTIM) || ((g_ucConfData[2531] & 0x40) && LPUNEQ ) || ((g_ucConfData
             -[2531] & 0x20) && LPSLM ) /* || ((g_ucConfData[2531] & 0x10) && LPSD )*/ ){
 277   4              // 下插AIS
 278   4              XBYTE[sw1021Chip + PORT_CFG_REG(n)] |= RAISEN;
 279   4            }else{
 280   4              // 停止下插AIS
 281   4              XBYTE[sw1021Chip + PORT_CFG_REG(n)] &= ~RAISEN;
 282   4            }
 283   3              
 284   3          #endif
 285   3            
 286   3            
 287   3            //must be write BIPERR_COUNTER_REG ; see manual
 288   3            XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 289   3            g_liError1s[i].ulDatlong += XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+BIP
             -ERR_COUNTER_REG(A_BUS_BASE, n) + 1] * 256);   // BIP错误计数值
 290   3            //must be write REI_COUNTER_REG ; see manual
 291   3            XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 292   3            LPFEBE = XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BAS
             -E, n) + 1] * 256); //REI(FEBE)计数值
 293   3            
 294   3            tmp = XBYTE[sw1021Chip + PORT_TEST_REG(n)];
 295   3                  
 296   3            LOOPL =  tmp & E1LBK;
 297   3            LOOP =   tmp & LnLBK;
 298   3            
 299   3            if((g_ucConfData[200+mi]&(0x01<<ni))==0)
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 6   

 300   3            {
 301   4              g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;
 302   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)].ucState=1;           
 303   4              else                                              //E1输入口有信号时/// 
 304   4              {
 305   5                if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==1)  //如果还存在PPILOS告警//
 306   5                if(WP==1)                        //非保护盘位时//
 307   5                {
 308   6                  // 向第i通道上话方向插短时间的伪随机码
 309   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 310   6                  g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS//
 311   6          
 312   6                  Delay(10);
 313   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &=  ~(PRBSEN | PRBST); //停插伪随机码
 314   6      
 315   6                }
 316   5                else g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS////保护盘位时//
 317   5              }
 318   4      
 319   4            }
 320   3            else
 321   3            {
 322   4              g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;
 323   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;               
 324   4              else  g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=1;
 325   4            }              
 326   3            //if(PPIAIS) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;               
 327   3            //else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 328   3            if(TULOP) g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=1;              
 329   3            else g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=0;  
 330   3            if(TUAIS) g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=1;              
 331   3            else g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=0;
 332   3            if(TULOP||TUAIS)
 333   3            {
 334   4              g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 335   4              g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 336   4              g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 337   4              #ifdef NEED_LP_RFI
                      g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
                      #endif
 340   4              g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0; 
 341   4            }
 342   3            else
 343   3            {
 344   4              if(LPSLM) g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=1;              
 345   4              else g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 346   4              if(LPRDI) g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=1;              
 347   4              else g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 348   4              if(LPUNEQ) g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=1;               
 349   4              else g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 350   4      
 351   4              /* 烽火老设备未使用RFI,不使用时将下面两句屏蔽 */
 352   4      #ifdef NEED_LP_RFI
                       if(LPRFI) g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=1;              
                       else g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
              #endif
 356   4              
 357   4              if(LPTIM) g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=1;              
 358   4              else g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0;  
 359   4            }
 360   3            if(LOOPL) g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=1;               
 361   3            else g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=0;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 7   

 362   3            if(LOOP) g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=1;              
 363   3            else g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=0;
 364   3            if(g_stuPm[i*PMTYPENUM+3].Value.usint>=(0xffff-LPFEBE)) g_stuPm[i*PMTYPENUM+3].Value.usint=0xffff;     
             -  
 365   3            else g_stuPm[i*PMTYPENUM+3].Value.usint+=LPFEBE;   //REI(FEBE)性能值                    
 366   3            if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==0)                               //无PPI_LOS告警时
 367   3            {
 368   4               //HDB3编码违例计数值
 369   4              HDB3 = XBYTE[sw1021Chip + HDB3_CV_REG(n)];
 370   4              
 371   4              if(g_stuPm[i*PMTYPENUM+4].Value.usint>=(0xffff-HDB3)) g_stuPm[i*PMTYPENUM+4].Value.usint=0xffff;     
 372   4              else g_stuPm[i*PMTYPENUM+4].Value.usint+=HDB3;      // HDB3性能值         //g_stuPm[i][4]=HDB3CV
 373   4            }           
 374   3      
 375   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState)
 376   3            almnumber=almnumber+1;
 377   3            
 378   3            tv5 = XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)];
 379   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3
             -)+4].ucState)
 380   3            { //如果TUAIS,TULOP,LPUNEQ之一为"1" 则向上插VC12=AIS,LPRDI,向下插AIS
 381   4                if((tv5 & RDI_CNF) != RDI_CNF)
 382   4                  XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 | RDI_CNF;
 383   4            }
 384   3            else
 385   3            {
 386   4              if((tv5 & RDI_CNF) == RDI_CNF)
 387   4                XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 & (~RDI_CNF);
 388   4            }
 389   3          }
 390   2        }
 391   1      
 392   1        for(i=0;i<(LINENUM-1);i++)
 393   1        {
 394   2          m=i/21;
 395   2          n=i%21;
 396   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 397   2          // 获取N2 和 K4 值
 398   2          //TODO: get N2
 399   2          //g_ucState[204+2*i]=XBYTE[WGS21891+0x0100+0x10*n+0x0C]; 
 400   2          g_ucState[205+2*i]=XBYTE[sw1021Chip + RX_K4_REG(A_BUS_BASE,n)];
 401   2          
 402   2          
 403   2          mi=i/8;
 404   2          ni=i%8;
 405   2          if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 406   2            g_ucState[330+mi]&=(~(0x01<<ni));
 407   2      
 408   2          else
 409   2            g_ucState[330+mi]|=(0x01<<ni);    
 410   2      
 411   2          //  tv5=XBYTE[WGS21891+0x0100+0x10*n+0x00];
 412   2      
 413   2        }
 414   1      
 415   1         
 416   1      
 417   1        if(TUXAB) g_ucState[77]=0;
 418   1        else g_ucState[77]=1;
 419   1                           
 420   1             
 421   1        if((WP==0) && (TUSWTI==0))   //保护盘位时,如果没有倒换ACT灯慢闪//     
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 8   

 422   1        {
 423   2          g_ucState[76]=0;
 424   2          g_LampEn=0;        
 425   2          if(g_stuSysClock.ucSecond%2==0) ACT=ON;
 426   2          else ACT=OFF;
 427   2          for(i=0;i<(LINENUM-1);i++)
 428   2          {
 429   3            g_ucLineMask[i]=1;
 430   3            g_ucState[141+i]=1;
 431   3          }
 432   2        }
 433   1        else if(g_ucState[76]==0)
 434   1        {                           
 435   2          for(i=0;i<(LINENUM-1);i++)
 436   2          {
 437   3            if((g_ucConfData[64+i]==0)||(g_ucConfData[137+i]==01))
 438   3            {    
 439   4              g_ucLineMask[i]=1;
 440   4              g_ucState[141+i]=1;  
 441   4            }   
 442   3            else
 443   3            {
 444   4              g_ucLineMask[i]=0;  
 445   4              g_ucState[141+i]=0;
 446   4            }
 447   3          }
 448   2          g_ucState[76]=1;     
 449   2          g_LampEn=1;
 450   2          WROUTPORT;           
 451   2        }
 452   1             
 453   1        UasClear();
 454   1      
 455   1      
 456   1        if(g_AllClrFlag)                //清性能
 457   1        {   
 458   2          g_bClearUas=1; 
 459   2          g_AllClrFlag=0;
 460   2        }
 461   1      
 462   1        if(g_SecondFlag)                   //秒标识，1：进入新的一秒
 463   1        {
 464   2          CalUas(ulSesLmt);           //uas计算        
 465   2      
 466   2          for(i=0; i<(LINENUM-1); i++)
 467   2          {
 468   3            g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];         //bbe_lp性能的采集
 469   3            g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];        //es_lp性能的采集
 470   3            g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];       //ses_lp性能的采集
 471   3            if(g_usiEs[i]>=ulEsLimit) 
 472   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=1;    //curalm[i][8]=es_limit
 473   3            else 
 474   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=0;
 475   3            // if(g_usiSes[i]>=ulSesLimit) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;    //curalm[i][9]=ses_limit
 476   3            // else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 477   3            g_stuPm[i*PMTYPENUM+5].Value.usint=g_usiUas[i];             //UAS_LP性能的采集
 478   3            g_stuPm[i*PMTYPENUM+6].Value.usint=g_usiCses[i];            //cses_lp性能的采集
 479   3      
 480   3      
 481   3            /******************************************************************************/
 482   3            if(g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3)+1].ucState)
 483   3            {
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 9   

 484   4              g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 485   4              BIP[i]=0;
 486   4            }
 487   3            else
 488   3            {
 489   4              BIP_2_1S[i]=BIP[i];
 490   4              BIP_2_1000S[i]+=BIP[i];  
 491   4              BIP[i]=0;
 492   4              switch(g_ucConfData[129])
 493   4              {
 494   5                case 0x04:
 495   5                if(BIP_2_1S[i]>=217) 
 496   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 497   5                else if(BIP_2_1S[i]<=23) 
 498   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 499   5                break;
 500   5      
 501   5                case 0x05:
 502   5                if(BIP_2_1S[i]>=22) 
 503   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 504   5                else if(BIP_2_1S[i]<=3) 
 505   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 506   5                break;
 507   5      
 508   5                case 0x06:
 509   5      
 510   5      
 511   5                if((N1000[i]>=10)&&(N1000[i]<100))
 512   5                {
 513   6                  if(BIP_2_1000S[i]>=22) 
 514   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 515   6                  else if(BIP_2_1000S[i]<=3) 
 516   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 517   6                  N1000[i]=0;
 518   6                  BIP_2_1000S[i]=0;
 519   6                }
 520   5                else N1000[i]++;
 521   5      
 522   5                break;
 523   5      
 524   5                case 0x07:
 525   5      
 526   5      
 527   5                if((N1000[i]>=100)&&(N1000[i]<1000))
 528   5                {
 529   6                  if(BIP_2_1000S[i]>=22) 
 530   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 531   6                  else if(BIP_2_1000S[i]<=3) 
 532   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 533   6                  N1000[i]=0;
 534   6                  BIP_2_1000S[i]=0;
 535   6                }
 536   5                else N1000[i]++;
 537   5                break;
 538   5      
 539   5                case 0x08:
 540   5      
 541   5      
 542   5                if(N1000[i]>=1000)
 543   5                {
 544   6                  if(BIP_2_1000S[i]>=22) 
 545   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 10  

 546   6                  else if(BIP_2_1000S[i]<=3) 
 547   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 548   6                  N1000[i]=0;
 549   6                  BIP_2_1000S[i]=0;
 550   6                }
 551   5                else 
 552   5                  N1000[i]++;
 553   5                break;
 554   5              }
 555   4            }
 556   3      
 557   3          /********************************************************************************/
 558   3      
 559   3          }
 560   2      
 561   2          g_SecondFlag=0;      //秒标识清?
 562   2      
 563   2        }     
 564   1      
 565   1        //IO8=1;
 566   1        // WRHIO;
 567   1        //RDHIO;    
 568   1        //IO9=1;
 569   1        // WRHIO;
 570   1        //RDHIO;
 571   1        //IO10=1;
 572   1        // WRHIO;
 573   1        //RDHIO;
 574   1        //IO11=1;
 575   1        // WRHIO;
 576   1        //RDHIO;
 577   1        //IO12=1;
 578   1        // WRHIO;
 579   1        RDHIO;
 580   1      
 581   1         
 582   1             
 583   1        if(ADCLK||(P2V5==0)||(first_conf==0)) 
 584   1          TUALMO=1; //如果工作支路中全部有告警或2.5V//
 585   1        else 
 586   1          TUALMO=0; //电源有告警或下配置前TUALMO=1,否则TUALMO=0//
 587   1        if((P5VI1==0)&&(DZBI1==0)) 
 588   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=1;
 589   1        else    
 590   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=0;               
 591   1        if((P5VI2==0)&&(DZBI2==0)) 
 592   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=1;
 593   1        else    
 594   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=0;       
 595   1        if(P2V5==0) 
 596   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=1;
 597   1        else    
 598   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=0;                     
 599   1       
 600   1      }
 601          
 602          /*****************************************************************
 603          ** 函数名:USERFUN
 604          ** 输　入: 无
 605          ** 输　出: 无
 606          ** 功能描述：用户实时处理函数，10毫秒被调用一次
 607          ** 全局变量：无
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 11  

 608          ** 调用模块：无
 609          ** 作　者：翁益晖
 610          ** 日　期：2002.5.25
 611          ** 修　改：
 612          ** 日　期：
 613          ** 版  本：1.0
 614          ****************************************************************/
 615          void UserFunc() using 1
 616          {
 617   1        int i,j;
 618   1        int tmp;
 619   1        unsigned int chip  = SW1021;
 620   1        static int docnt = 0;
 621   1        if(g_haveTux){
 622   2          if(docnt == 0){
 623   3            XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
 624   3            XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
 625   3            
 626   3            XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
 627   3            XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
 628   3            
 629   3            XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
 630   3            XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
 631   3            docnt++;
 632   3            return;
 633   3          }
 634   2          if(docnt > 10){
 635   3            docnt = 0;
 636   3            g_haveTux = 0;
 637   3          }
 638   2          for(i=0; i<CHIPS_ON_BOARD; i++){
 639   3            for(j=0; j< 21; j++){
 640   4              tmp = XBYTE[chip+PORT_E1_ALARM_REG(j)];
 641   4              if((tmp & RFFERR) == 0){
 642   5                continue;
 643   5              }else{
 644   5                //XBYTE[SW1021_CHIP_ADDR(k) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
 645   5                XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
 646   5                XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
 647   5                
 648   5                XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
 649   5                XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
 650   5                
 651   5                XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
 652   5                XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
 653   5              
 654   5                g_haveTux = 0;
 655   5                docnt = 0;
 656   5                return;
 657   5              }
 658   4            }
 659   3            chip+=0x1000;
 660   3          }
 661   2          docnt++;
 662   2        }
 663   1        
 664   1        return;
 665   1      }
 666          
 667          /*
 668          //static void ChecktuxAB (void) interrupt 9 using 3
 669          static void ChecktuxAB (void) interrupt 9
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 12  

 670          {
 671          
 672            EX3 = 0;
 673            EXIF &= 0xDF;
 674            g_haveTux = 1;
 675          
 676          
 677            EX3 = 1;
 678            return;
 679          }
 680          */
 681          
 682          static void happenSwich (void) interrupt 8
 683          {
 684   1      
 685   1        EX2 = 0;
 686   1        EXIF &= 0xEF;
 687   1        g_haveTux = 1;
 688   1      
 689   1      
 690   1        EX2 = 1;
 691   1        return;
 692   1      }
 693          
 694          /*****************************************************************
 695          ** 函数名:CONF_SET
 696          ** 输　入: 无
 697          ** 输　出: 无
 698          ** 功能描述：单盘配置
 699          ** 全局变量：无
 700          ** 调用模块：无
 701          ** 作　者：caijun.Li
 702          ** 日　期：2016.3.19
 703          ** 修　改：
 704          ** 日　期：
 705          ** 版  本：1.0
 706          ****************************************************************/
 707          void ConfSet(void)
 708          {
 709   1          /*Process ALMMASK*/
 710   1          /*Process PMMASK*/
 711   1        unsigned char i,j,ilong,m,n,temp;
 712   1      
 713   1        g_ucState[69]=g_ucConfData[5];
 714   1        g_ucState[70]=g_ucConfData[6];
 715   1        g_ucState[71]=g_ucConfData[7];
 716   1        g_ucState[72]=g_ucConfData[8];
 717   1        g_ucState[73]=g_ucConfData[9];
 718   1        g_ucState[74]=g_ucConfData[10];
 719   1        g_ucState[75]=g_ucConfData[11];
 720   1        for(i=0;i<(LINENUM-1);i++){
 721   2          m=i/21;
 722   2          n=i%21;
 723   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 724   2        
 725   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 726   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 727   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 728   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 729   2      
 730   2          if(g_ucConfData[64+i]==0){  // 支路关闭
 731   3            // 上下话强发AIS
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 13  

 732   3            //XBYTE[sw1021Chip + TX_CTRL_REG(B_BUS_BASE,n)] = AIS_EN; 
 733   3            temp = XBYTE[sw1021Chip + PORT_CFG_REG(n)];
 734   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = temp | TAISEN | RAISEN; 
 735   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = 0x00;
 736   3                  
 737   3            g_ucState[78+i]=0;     
 738   3            g_ucLineMask[i]=1;
 739   3            g_ucState[141+i]=1;
 740   3          }else{  // 支路打开
 741   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = A_UP_DOWN | RnEN;
 742   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = (0x02 << 1);  // 注意信号标记值得配置
 743   3            if(g_ucState[78+i]==0)//刚打开支路开关时插伪随机码
 744   3            {
 745   4              //TODO: 启动误码计数器
 746   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 747   4              Delay(5);
 748   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= ~(PRBSEN | PRBST);
 749   4              g_ucState[78+i]=1;
 750   4              g_ucLineMask[i]=0; 
 751   4              g_ucState[141+i]=0;
 752   4            }         
 753   3          }
 754   2          XBYTE[sw1021Chip + TX_K4_REG(A_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 755   2          XBYTE[sw1021Chip + TX_K4_REG(B_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 756   2          // TODO: N2 发
 757   2          //XBYTE[WGS21891+0x0100+0x10*n+0x01]=g_ucConfData[263+4*i];                 // N2 发
 758   2        
 759   2        #ifdef AIS_CONDITIONS_AUTO
                  if((g_ucConfData[2531] & 0x80)){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }else{
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }
                  if(g_ucConfData[2531] & 0x40){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= UNEQAISE;
                  }
                  if(g_ucConfData[2531] & 0x20){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= PLMAISE;
                  }
                #endif
 772   2        
 773   2          // J2 发 和 期望收
 774   2          for(j=0;j<16;j++)
 775   2          {
 776   3            if(j==0) temp=0x80;
 777   3            else temp=0;
 778   3            
 779   3            // A 
 780   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 0);
 781   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 0);
 782   3            // B
 783   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 1);
 784   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 1);
 785   3          }
 786   2          
 787   2          if(g_ucConfData[137+i]==0)   //confdata[137+i]==0不屏蔽支路i告警/否则屏蔽支路i告警//
 788   2          {
 789   3            g_ucLineMask[i]=0;
 790   3            g_ucState[141+i]=0;
 791   3          }
 792   2          else
 793   2          {
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 14  

 794   3            g_ucLineMask[i]=1;
 795   3            g_ucState[141+i]=1;
 796   3          }
 797   2        //if(g_ucConfData[200+i]==0)     //confdata[200+i]==1支路i装载/否则不装载//
 798   2        //XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x00;
 799   2        // else  XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x04;
 800   2      
 801   2        }
 802   1      
 803   1      
 804   1      
 805   1        for(j=0;j<ALMTYPENUM;j++) 
 806   1        {
 807   2           
 808   2           for(ilong=29;ilong<(29+ALMTYPENUM);ilong++)
 809   2           {    
 810   3              if(g_ucConfData[ilong]==g_ucAlmCode[j])   //从网管设告警屏蔽//
 811   3              {
 812   4               g_ucAlmMask[j]=1;                              
 813   4               break;     
 814   4              }
 815   3              else
 816   3              g_ucAlmMask[j]=0;
 817   3      
 818   3           }
 819   2        }      
 820   1                          
 821   1        for(j=0;j<PMTYPENUM;j++)  
 822   1        {
 823   2      
 824   2          for(ilong=54;ilong<(54+PMTYPENUM);ilong++)
 825   2          {   
 826   3            if(g_ucConfData[ilong]==g_ucPmCode[j])   //从网管设性能屏蔽//
 827   3            {
 828   4              g_ucPmMask[j]=1;                              
 829   4              break;    
 830   4            }
 831   3            else
 832   3              g_ucPmMask[j]=0;
 833   3          }
 834   2        }        
 835   1      
 836   1        ulEsLimit=256*g_ucConfData[131]+g_ucConfData[132];    //从网管设ulEsLimit门限//
 837   1        ulSesLimit=256*g_ucConfData[134]+g_ucConfData[135];   //从网管设ulSesLimit门限//
 838   1      
 839   1      
 840   1        //if((g_ucConfData[136]==0)&&TUALMO&&WP) TUALMO=0;  //IO2=TUALMO  confdata[108]=盘保护模式不保护
 841   1      
 842   1      
 843   1        // g_ucConfChange=0;                          
 844   1              
 845   1      
 846   1        if(first_conf==0) first_conf=1; 
 847   1      }
 848          
 849          
 850          /*****************************************************************
 851          ** 函数名:UserHdlc
 852          ** 输　入: 无
 853          ** 输　出: 无
 854          ** 功能描述：单盘特殊命令处理
 855          ** 全局变量：无
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 15  

 856          ** 调用模块：无
 857          ** 作　者：caijun.Li
 858          ** 日　期：2016.3.19
 859          ** 修　改：
 860          ** 日　期：
 861          ** 版  本：1.0
 862          ****************************************************************/
 863          void UserHdlc(void)
 864          {
 865   1        unsigned char i,j,m,n,temp;
 866   1        unsigned int addr;
 867   1        char val;
 868   1      
 869   1        if (g_ucHdlcBuf[CMD_TYPE]==COMM_CATA)
 870   1        {
 871   2          if (g_ucHdlcBuf[CMD_CODE]==RTRV_OCONF)
 872   2          {
 873   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;
 874   3          }
 875   2          else if (g_ucHdlcBuf[CMD_CODE]==SET_OCONF)
 876   2          {
 877   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;                                               
 878   3          }
 879   2        }
 880   1      
 881   1      
 882   1        switch(g_ucHdlcBuf[5])
 883   1        {
 884   2          case 0x00:    /*SET_LOOP*/
 885   2            if(g_ucHdlcBuf[6]==0x34)
 886   2            { // 设备环回
 887   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 888   3                g_ucHdlcBuf[10]=0x80; 
 889   3              else                
 890   3                for(i=0;i<(g_usRxDataLen);i++)
 891   3                {
 892   4                  temp=g_ucHdlcBuf[14+i]-1;
 893   4                  m=temp/21;
 894   4                  n=temp%21;
 895   4      
 896   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 897   4                  if(g_ucHdlcBuf[7]==0x01){
 898   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
 899   5                  }else{
 900   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
 901   5                  }
 902   4                  g_ucHdlcBuf[10]=0x00;
 903   4                }
 904   3            }
 905   2            else if(g_ucHdlcBuf[6]==0x33)       /*SET_LOOPL*/
 906   2            { // 线路环回 
 907   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 908   3                g_ucHdlcBuf[10]=0x80; 
 909   3              else                  
 910   3                for(i=0;i<(g_usRxDataLen);i++)
 911   3                {
 912   4                  temp=g_ucHdlcBuf[14+i]-1;
 913   4                  m=temp/21;
 914   4                  n=temp%21;
 915   4                  
 916   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 917   4                  if(g_ucHdlcBuf[7]==0x01){
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 16  

 918   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= E1LBK;
 919   5                  }else{
 920   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~E1LBK);
 921   5                  }
 922   4                  g_ucHdlcBuf[10]=0x00;
 923   4                }
 924   3            }
 925   2            else if(g_ucHdlcBuf[6] == 0x45){  /* 请求报告J字节等辅助信息 */
 926   3              int addr = 0;
 927   3              g_ucHdlcBuf[10]=0x00;
 928   3              g_ucHdlcBuf[11]=0x00;
 929   3              g_ucHdlcBuf[12]=0x04;
 930   3              g_ucHdlcBuf[13]=0x6e;
 931   3            
 932   3              addr = 14;
 933   3              for(i=0; i<63; i++){
 934   4                m = i/21;
 935   4                n = i%21;
 936   4                g_ucHdlcBuf[addr++] = 0x02; //J2
 937   4                g_ucHdlcBuf[addr++] = i;   //TODO: 确认支路号是从0开始还是从1开始
 938   4                for(j=0;j<16;j++){
 939   5                  readRxJ2(m, j, slot[i], &val, 0);
 940   5                  g_ucHdlcBuf[addr++] = val; //J2 value
 941   5                }         
 942   4              }     
 943   3              
 944   3            }
 945   2            break;
 946   2      
 947   2          case 0x77:                /**透明帧命令**/
 948   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];  // commbuf[14]，commbuf[15]所存放 的 地址
 949   2            g_ucHdlcBuf[10]=0x00;
 950   2            g_ucHdlcBuf[11]=0x00;
 951   2            g_ucHdlcBuf[12]=0x00;
 952   2            g_ucHdlcBuf[13]=0x11;
 953   2            //读16个字节//  addr 地址开始读取16个字节数据//
 954   2            for(i=0;i<16;i++) 
 955   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; 
 956   2            g_ucHdlcBuf[30]=P1;
 957   2            break;                   
 958   2          
 959   2          case 0x88:
 960   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];
 961   2            XBYTE[addr]=g_ucHdlcBuf[16];       //将commbuf[16]存放的数据送入commbuf[14]，//
 962   2            g_ucHdlcBuf[10]=0x00;              //commbuf[15]所存放的WGS21891的地址单元中//
 963   2            g_ucHdlcBuf[11]=0x00;
 964   2            g_ucHdlcBuf[12]=0x00;
 965   2            g_ucHdlcBuf[13]=0x10;              //读16个字节//
 966   2            for(i=0;i<16;i++) 
 967   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; //从commbuf[14]，commbuf[15]的地址开始读取16个字节数据//
 968   2            break;
 969   2      
 970   2          
 971   2          case 0X99:
 972   2            while(1)
 973   2            {;}
 974   2            if((g_usRxDataLen==0)||(g_usRxDataLen>63)) 
 975   2              g_ucHdlcBuf[10]=0x80; 
 976   2            else                
 977   2              for(i=0;i<(g_usRxDataLen);i++)
 978   2              {
 979   3                temp=g_ucHdlcBuf[14+i]-1;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 17  

 980   3                m=temp/21;
 981   3                n=temp%21;
 982   3                sw1021Chip = SW1021_CHIP_ADDR(m);
 983   3                          
 984   3                g_ucHdlcBuf[17]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
 985   3                g_ucHdlcBuf[18]=0xbb;
 986   3                
 987   3                if(g_ucHdlcBuf[7]==0x01)
 988   3                {
 989   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
 990   4                  if(n<8)
 991   4                    g_ucHdlcBuf[18]=0xff;
 992   4                }
 993   3                else
 994   3                {
 995   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
 996   4                }
 997   3                    
 998   3              }
 999   2            g_ucHdlcBuf[10]=0x00;
1000   2            g_ucHdlcBuf[13]=6;
1001   2            g_ucHdlcBuf[14]=0xaa;
1002   2            g_ucHdlcBuf[15]=m;
1003   2            g_ucHdlcBuf[16]=n;
1004   2            g_ucHdlcBuf[19]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
1005   2            
1006   2            break;
1007   2            
1008   2      
1009   2        }
1010   1      
1011   1      }
1012          
1013          /*****************************************************************
1014          ** 函数名:SELF_CONF
1015          ** 输　入: 无
1016          ** 输　出: 无
1017          ** 功能描述：单盘上电默认配置
1018          ** 全局变量：g_ucConfData[]
1019          ** 调用模块：无
1020          ** 作　者：翁益晖
1021          ** 日　期：2002.5.25
1022          ** 修　改：
1023          ** 日　期：
1024          ** 版  本：1.0
1025          ** 注  意：所有告警和性能的初始化需安线路号顺序
1026          ****************************************************************/
1027          void SelfConf()
1028          {
1029   1      
1030   1        unsigned int i,j;
1031   1        char ctt[18];
1032   1        unsigned char ucii;
1033   1        //  first_conf=0;
1034   1        g_ucConfData[22]=BOARDCODE;/*BDINF5*/
1035   1        g_ucConfData[0]=0xfe;
1036   1      
1037   1      
1038   1        sprintf(ctt,BoardSn);
1039   1        for(ucii=0;ucii<15;ucii++) g_ucState[ucii]=ctt[ucii];  /*盘号*/
1040   1      
1041   1        sprintf(ctt,PcbSn);   
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 18  

1042   1        for(ucii=0;ucii<15;ucii++) g_ucState[15+ucii]=ctt[ucii]; /*板号*/
1043   1      
1044   1        sprintf(ctt,PcbTime);   
1045   1        for(ucii=0;ucii<10;ucii++) g_ucState[30+ucii]=ctt[ucii]; /*制板时间*/
1046   1      
1047   1        for(ucii=0;ucii<18;ucii++) ctt[ucii]=0;    /*版本号buf清零*/
1048   1        //sprintf(ctt,"R170609R1B/01F    "); 
1049   1        //for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
1050   1        sprintf(ctt,BoardSoftVer); 
1051   1        for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
1052   1        sprintf(ctt,__DATE__);   
1053   1        for(ucii=0;ucii<11;ucii++) g_ucState[58+ucii]=ctt[ucii]; /*编程时间*/
1054   1      
1055   1        //g_ucState[69]=0x07;
1056   1        //g_ucState[70]=0xD1;
1057   1        //g_ucState[71]=0x06;
1058   1        //g_ucState[72]=0x01;
1059   1        //g_ucState[73]=0x08;
1060   1        //g_ucState[74]=0x00;
1061   1        //g_ucState[75]=0x00;
1062   1        g_ucState[76]=0x01;
1063   1        //g_ucState[77]=0x01;
1064   1      
1065   1      
1066   1      
1067   1        for(i=0;i<LINENUM;i++)           /*linecode=1..63*/
1068   1          g_ucLineCode[i]=i+1;
1069   1        for(i=0;i<LINENUM;i++)
1070   1        {
1071   2          g_ucLineMask[i]=0;          
1072   2      
1073   2        }
1074   1      
1075   1      
1076   1      
1077   1        /*for(i=0;i<LINENUM;i++)
1078   1        for(j=0;j<PMNUM;j++) linepmmask[i][j]=0;*/         
1079   1      
1080   1      
1081   1        actnumber=63;             
1082   1        almnumber=0;     
1083   1      
1084   1        ulEsLimit=0xff;
1085   1        ulSesLimit=0xff;
1086   1      
1087   1        g_ucAlmCode[0]=0x03;                        /*PPI_LOS*/
1088   1        g_ucAlmCode[1]=0x27;                        /*TU_LOP*/
1089   1        g_ucAlmCode[2]=0x22;                        /*LP_SLM*/
1090   1        g_ucAlmCode[3]=0x20;                        /*LP_RDI*/
1091   1        g_ucAlmCode[4]=0x24;                        /*LP_UNEQ*/
1092   1        //g_ucAlmCode[8]=0x04;                        /*PPI_AIS*/
1093   1        g_ucAlmCode[5]=0x02;                        /*TU_AIS*/
1094   1      #ifdef NEED_LP_RFI
                g_ucAlmCode[15]=0x0c;                        /*LP_RFI*/
              #endif
1097   1        g_ucAlmCode[7]=0x51;                        /*ES_LIMIT*/
1098   1        //g_ucAlmCode[8]=0x52;      /*SES _LIMIT*/
1099   1        g_ucAlmCode[9]=0x28;                       /*LP_TIM*/
1100   1        g_ucAlmCode[10]=0x4f;                       /*LOOPL*/
1101   1        g_ucAlmCode[11]=0x55;     /*LOOP*/
1102   1        g_ucAlmCode[12]=0x01;                       //2V5电源故障告警//
1103   1        g_ucAlmCode[13]=0x05;                       //5VI1电源故障告警//
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 19  

1104   1        g_ucAlmCode[14]=0x06;                       //5VI2电源故障告警//
1105   1        g_ucAlmCode[6]=0x07;                 //trafic-onload//
1106   1        g_ucAlmCode[8]=0x08;                /*LP_SD*/
1107   1      
1108   1        g_ucPmCode[0]=0x08;                   /*BBE_LP*/
1109   1        g_ucPmCode[1]=0x02;                   /*ES_LP*/
1110   1        g_ucPmCode[2]=0x03;                   /*SES_LP*/
1111   1        g_ucPmCode[3]=0x07;                   /*REI_LP*/
1112   1        g_ucPmCode[4]=0x0b;                   /*HDB3CV*/
1113   1        //g_ucPmCode[5]=0x06;                 /*UAS_LP*/
1114   1        g_ucPmCode[5]=0x0c;                   /*UAS_LP*/
1115   1        g_ucPmCode[6]=0xa2;                   /*CSES_LP*/
1116   1      
1117   1        g_ucAlmType[0]=0;   /*almtype：0急告；4非急告；8状态量*/
1118   1        g_ucAlmType[1]=0;
1119   1        g_ucAlmType[2]=0;
1120   1        g_ucAlmType[3]=4;
1121   1        g_ucAlmType[4]=4;
1122   1        g_ucAlmType[5]=4;
1123   1        g_ucAlmType[6]=8;
1124   1        g_ucAlmType[7]=4;
1125   1        g_ucAlmType[8]=4;
1126   1        g_ucAlmType[9]=0;      /*LP_TIM*/
1127   1        g_ucAlmType[10]=8;         
1128   1        g_ucAlmType[11]=8;  
1129   1        g_ucAlmType[12]=0;
1130   1        g_ucAlmType[13]=0;
1131   1        g_ucAlmType[14]=0;
1132   1        
1133   1      #ifdef NEED_LP_RFI
                g_ucAlmType[15]=4;
              #endif
1136   1      
1137   1        for(j=0;j<(LINENUM-1);j++)
1138   1        {
1139   2          for(i=0;i<(ALMTYPENUM-3);i++)
1140   2          {
1141   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucLineIndex=j;
1142   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucAlmIndex=i;
1143   3          }
1144   2        }
1145   1      
1146   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucLineIndex=63;
1147   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucAlmIndex=12;
1148   1      
1149   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucLineIndex=63;
1150   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucAlmIndex=13;
1151   1      
1152   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucLineIndex=63;
1153   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucAlmIndex=14;
1154   1      
1155   1      
1156   1        for(j=0;j<(LINENUM-1);j++)
1157   1        {
1158   2          for(i=0;i<PMTYPENUM;i++)
1159   2          {
1160   3            g_stuPm[j*PMTYPENUM+i].ucLineIndex=j;
1161   3            g_stuPm[j*PMTYPENUM+i].ucPmIndex=i;
1162   3          }
1163   2        }
1164   1      
1165   1        for(i=0;i<UASNUM;i++)
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 20  

1166   1        {
1167   2          g_liError1s[i].ulDatlong=0;
1168   2          ulSesLmt[i]=700; //若某一秒内误码个数大于等于ulSesLmt[i]时,该秒是严重误码秒//
1169   2        }                  
1170   1      }
1171          
1172          
1173          
1174          /*****************************************************************
1175          ** 函数名:InitioSw1021
1176          ** 输　入: 无
1177          ** 输　出: 无
1178          ** 功能描述：SW1021初始化
1179          ** 全局变量：
1180          ** 调用模块：
1181          ** 作　者：caijun.Li
1182          ** 日　期：2016.3.18
1183          ** 修　改：
1184          ** 日　期：
1185          ** 版  本：1.0
1186          ****************************************************************/
1187          void InitioSw1021()
1188          {
1189   1      
1190   1        unsigned int i,j;
1191   1        unsigned char m,n;
1192   1        first_conf=0;
1193   1      
1194   1        for(i=0; i<CHIPS_ON_BOARD; i++)
1195   1        {
1196   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
1197   2          Delay(1);
1198   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = RST_CANCLE;
1199   2          
1200   2          // TODO: 并行总线时钟选择
1201   2          // SW1021只支持19.44Mbit/s 的传输速率
1202   2          
1203   2          
1204   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时  + V5 期望
             - 0x02
1205   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时
1206   2          
1207   2          XBYTE[SW1021_CHIP_ADDR(i) + SOMESET_REG(A_BUS_BASE)] = BLKBIP_BLOCK;  // BIP-2按块进行校验并计数
1208   2          
1209   2          XBYTE[SW1021_CHIP_ADDR(i) + RDI_RFI_CTRL_REG(A_BUS_BASE)] = MREI_AUTO | AISV_RDIEN | LOPV_RDIEN | LOMV_R
             -DIEN | UNEQV_RDIEN | PLMV_RDIEN | RTIMV_RDIEN | RTIUV_RDIEN;
1210   2          
1211   2          // 上下话数据总线均选择偶校验
1212   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)] = UP_DELAY_2;
1213   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)] = UP_DELAY_2;   
1214   2          
1215   2          // 21个端口从A总线上下话, 使用 +- HDB3模式
1216   2          for(j=0; j<21; j++){
1217   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)] = A_UP_DOWN | RnEN;
1218   3            // 关闭线路环回和系统环回
1219   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_TEST_REG(j)] = 0x00;
1220   3            // TODO: 上下话交叉状态选择 ： 不交叉
1221   3            
1222   3            // TODO: TU通道LOP\AIS告警检测设置： EN_TUAIS  使能TU-AIS 中断
1223   3            //                             EN_TULOP  使能TU-LOP 中断
1224   3            //                             
1225   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_E1_ALARM_INTERRPUT_MASK_REG(j)] = E1AISE | E1LOCE; //??
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 21  

1226   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(A_BUS_BASE,j)] = LOPE | AISE;  
1227   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(B_BUS_BASE,j)] = LOPE | AISE;  
1228   3            //TODO： 读清中断指示
1229   3            
1230   3            //TODO: 不启动随机码测试； 启动误码计数
1231   3            
1232   3            //TODO: 上话V5-TX2 设置 LP-REI
1233   3            XBYTE[SW1021_CHIP_ADDR(i) + TX_V5_REG(A_BUS_BASE,j)] = (0x02 << 1);
1234   3            
1235   3            //TODO： 上下话通道号编码
1236   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1237   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1238   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1239   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1240   3            
1241   3            
1242   3          }
1243   2          // TODO:上下话时钟数据同相
1244   2          XBYTE[SW1021_CHIP_ADDR(i) + E1_CTRL_REG] = TRZSEL | RRZSEL;
1245   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_IF_CLK_REG] = 0x00;
1246   2      
1247   2        }
1248   1        
1249   1        // 填充所有支路的J2字节（初始化清0）
1250   1        for(i=0;i<63;i++)            
1251   1        {
1252   2          m=i/21;
1253   2          n=i%21;
1254   2          for(j=0;j<16;j++)
1255   2          {
1256   3            if(j==0)
1257   3            { // A 
1258   4              writeTxJ2(m, j, slot[i],  0x80, 0);
1259   4              writeExpectJ2(m, j, slot[i],  0x80, 0);
1260   4              // B
1261   4              writeTxJ2(m, j, slot[i],  0x80, 1);
1262   4              writeExpectJ2(m, j, slot[i],  0x80, 1);           
1263   4            }
1264   3            else
1265   3            {
1266   4              // A 
1267   4              writeTxJ2(m, j, slot[i],  0x00, 0);
1268   4              writeExpectJ2(m, j, slot[i],  0x00, 0);
1269   4              // B
1270   4              writeTxJ2(m, j, slot[i],  0x00, 1);
1271   4              writeExpectJ2(m, j, slot[i],  0x00, 1); 
1272   4            }
1273   3          }
1274   2        }
1275   1      
1276   1         IO8=1;
1277   1         IO9=1;
1278   1         IO10=1;
1279   1         IO11=1;
1280   1         IO12=1;
1281   1         WRHIO;
1282   1      
1283   1      }
1284          /*****************************************************************
1285          ** 函数名:checkSW1021Init
1286          ** 输　入: 无
1287          ** 输　出: 无
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 22  

1288          ** 功能描述：检查SW1021初始化成功
1289          ** 全局变量：
1290          ** 调用模块：
1291          ** 作　者：caijun.Li
1292          ** 日　期：2016.3.18
1293          ** 修　改：
1294          ** 日　期：
1295          ** 版  本：1.0
1296          ****************************************************************/
1297          static int checkSW1021Init(void)
1298          {
1299   1        int ret = 0;
1300   1        int i,j;
1301   1        unsigned int reg;
1302   1        for(i=0;i<CHIPS_ON_BOARD;i++)
1303   1        {
1304   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)];
1305   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1306   3            ret = -1;
1307   3            break;
1308   3          }
1309   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)];
1310   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1311   3            ret = -1;
1312   3            break;
1313   3          }
1314   2          
1315   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)];
1316   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1317   3            ret = -1;
1318   3            break;
1319   3          }
1320   2          
1321   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)];
1322   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1323   3            ret = -1;
1324   3            break;
1325   3          }
1326   2          
1327   2          for(j=0; j<21; j++){
1328   3            reg = XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)];
1329   3            if((reg & (A_UP_DOWN | RnEN)) != (A_UP_DOWN | RnEN)){
1330   4              ret = -1;
1331   4              goto quit;
1332   4            }
1333   3          }
1334   2      
1335   2        }
1336   1      quit:
1337   1        return ret;
1338   1      }
1339          
1340          /*****************************************************************
1341          ** 函数名:MAIN
1342          ** 输　入: 无
1343          ** 输　出: 无
1344          ** 功能描述：主函数
1345          ** 全局变量：g_QuarterFlag
1346          ** 调用模块：SelfConf(),GetData(),ProcHisData(),Debug();
1347          ** 作　者：caijun.Li
1348          ** 日　期：2016.3.18
1349          ** 修　改：
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 23  

1350          ** 日　期：
1351          ** 版  本：1.0
1352          ****************************************************************/
1353          void main()
1354          {   
1355   1        unsigned char i;  
1356   1        int ret = 0;
1357   1        //Delay(50);
1358   1      
1359   1        SelfConf(); 
1360   1        
1361   1        ret = checkSW1021Init();
1362   1        if(ret != 0)
1363   1          InitioSw1021();
1364   1        
1365   1        // 使能外部中断2
1366   1        EX2 = 1;
1367   1        PX2 = 0;  // 低优先级
1368   1      
1369   1        while (1)
1370   1        {
1371   2          #ifdef SKIP_DEBUG_CHECK
1372   2            #ifdef NEED_LP_RFI        
                        XBYTE[0x7fe5] = 1;
                    #else
1375   2              //  XBYTE[0x7b74] = 1;
1376   2                XBYTE[0x7b7A] = 1;
1377   2            #endif
1378   2          #endif
1379   2          
1380   2          //ACT = ~ACT;
1381   2          //RED = ~RED;
1382   2          //YELLOW = ~YELLOW;
1383   2              
1384   2          
1385   2          ret = checkSW1021Init();
1386   2          if(ret != 0){ 
1387   3            SelfConf(); 
1388   3            InitioSw1021();
1389   3            ConfSet();  
1390   3          }
1391   2        
1392   2          GetData();
1393   2          ProcAlmData();  
1394   2      
1395   2          if (g_QuarterFlag) 
1396   2          {
1397   3            UasQuarter();
1398   3            for(i=0;i<LINENUM;i++)
1399   3            {
1400   4              g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];
1401   4              g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];
1402   4              g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];
1403   4            }
1404   3            ProcHisData();  //将当前告警和性能数据存为历史数据//
1405   3            g_QuarterFlag=0;
1406   3          }
1407   2          
1408   2          Debug();
1409   2        }
1410   1      }
1411          
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    05/18/2016 16:26:50 PAGE 24  

*** WARNING C294 IN LINE 974 OF GF2488-01F1-E1-RST.C: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12092    ----
   CONSTANT SIZE    =    250    ----
   XDATA SIZE       =  22241     107
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
