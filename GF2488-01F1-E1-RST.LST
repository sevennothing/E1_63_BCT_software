C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE GF2488_01F1_E1_RST
OBJECT MODULE PLACED IN GF2488-01F1-E1-RST.OBJ
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE GF2488-01F1-E1-RST.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND T
                    -ABS(2)

line level    source

   1          /******************************************************************
   2          ** 文件名：STAND.C
   3          ** Copyright (c) 2002 烽火通信传输产品部BCT软件组
   4          ** 创建人：翁益晖
   5          ** 文件编号：
   6          ** 描　述：标准模版程序
   7          **         
   8          ** 日　期：2002.6.28
   9          ** 修改人：
  10          ** 日　期：
  11          ** 文件编号：
  12          ** 描　述：
  13          **
  14          **
  15          ** 编译器：Keil C51 V5.5 或 MCC68K V4.4
  16          ** 公共库：NewLib9.LIB for Mcs51
  17          **         或 NewLib1.LIB for Mc68302
  18          ** 版  本：1.0
  19          ********************************************************************/
  20          //#define  NEED_LP_RFI   /**  !!! 单盘起不来了  */
  21          #define AIS_CONDITIONS      /** 与 AIS_CONDITIONS_AUTO 二选一  */
  22          //#define AIS_CONDITIONS_AUTO
  23          //#define SKIP_DEBUG_CHECK
  24          
  25          #define UASNUM    63        //要计算误码的线路数63//
  26          #define LINENUM   64        /*告警线路数为64*/
  27          #ifdef NEED_LP_RFI
                #define ALMNUM      822     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
                #define ALMTYPENUM      16      /*16种告警类型*/
              #else
  31            #define ALMNUM      759     /*总共63*(ALMTYPENUM-3)+3=759个告警*/
  32            #define ALMTYPENUM      15      /*15种告警类型*/
  33          #endif
  34          
  35          #define PMNUM   441         /*总共63*PMTYPENUM个性能*/
  36          
  37          #define PMTYPENUM       7       /*7种性能类型*/
  38          #define CONFLEN   2560  /*配置数据长度为2560*/
  39          #define STATELEN  338   /*状态数据长度为338*/
  40          #define BOARDCODE 0x96  /*盘代码*/
  41          #define WGS21891A 0xB000
  42          
  43          #define SW1021  0xB000    //TODO：confirm
  44          
  45          #define SW1021_CHIP_ADDR(num)  (SW1021 + 0x1000*(num))
  46          #define CHIPS_ON_BOARD          3
  47          
  48          
  49          #include "commvar9.h"
  50          #include "uasE63.h"
  51          
  52          #include "sw1021.h"
  53          
  54          char code SysName[]="GF2488-01F";
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 2   

  55          char code BoardName[]="E1-63A";
  56          char code BoardSn[]="WKE2.202.202R1A";
  57          char code SoftVer[]="R202202R1A/01F    ";
  58          
  59          char code PcbSn[]="WKE7.201.546R1A";
  60          char code PcbTime[]="2016 05 20";
  61          
  62          char code BoardSoftVer[]="RP0100            ";
  63          
  64          char code SoftDate[]=__DATE__;
  65          char code SoftTime[]=__TIME__;
  66          
  67          extern int sprintf(char *, const char *, ...);
  68          
  69          #define RSTB IO0
  70          #define TUALMO IO2
  71          #define HAPPAN_SWITCH IO4   // 外部中断2,上升沿中断
  72          #define TUXAB IO5 //TUXAB为主备交叉时钟盘XCU有效指示信号,主用XCU有效时TUXAB=0,备用XCU有效TUXAB=1
  73          #define WP IO6     //E1-63A盘在正常槽位时WP=1,在保护槽位时WP=0//
  74          #define TUSWTI IO7 //本盘almnumber大于一定值时,TUALMO=1,XCU盘收到TUALMO=1时,产生TUSWTI=0//
  75          #define P2V5 IO8
  76          #define P5VI1 IO9
  77          #define P5VI2 IO10
  78          #define DZBI1 IO11
  79          #define DZBI2 IO12
  80          
  81          // 仅用于调试（解决全部线路环回缺陷问题）
  82          #define ALERT_LOOPL IO3
  83          
  84          extern unsigned char g_AllClrFlag;
  85          extern unsigned char g_LampEn;
  86          unsigned int ulEsLimit,ulSesLimit;
  87          //unsigned int WGS21891,wgs21891reg0[4],wgs21891reg1[4];
  88          unsigned int sw1021Chip;
  89          unsigned int N1000[63],BIP[63],BIP_2_1S[63],BIP_2_1000S[63];
  90          unsigned char actnumber,almnumber,first_conf;
  91          //unsigned char g_haveTux;
  92          /*
  93          code unsigned char slot[64]={1,22,43,4,25,46,7,
  94          28,49,10,31,52,13,34,
  95          55,16,37,58,19,40,61,
  96          
  97          2,23,44,5,26,47,8,
  98          29,50,11,32,53,14,35,
  99          56,17,38,59,20,41,62,
 100          
 101          3,24,45,6,27,48,9,
 102          30,51,12,33,54,15,36,
 103          57,18,39,60,21,42,63,0};
 104              */
 105          /*
 106          code unsigned char slot[64]={0x00,0x20,0x40,0x01,0x21,0x41,0x02,
 107                               0x22,0x42,0x03,0x23,0x43,0x04,0x24,
 108                               0x44,0x05,0x25,0x45,0x06,0x26,0x46,
 109          
 110                               0x07,0x27,0x47,0x08,0x28,0x48,0x09,
 111                               0x29,0x49,0x0a,0x2a,0x4a,0x0b,0x2b,
 112                               0x4b,0x0c,0x2c,0x4c,0x0d,0x2d,0x4d,
 113          
 114                               0x0e,0x2e,0x4e,0x0f,0x2f,0x4f,0x10,
 115                               0x30,0x50,0x11,0x31,0x51,0x12,0x32,
 116                               0x52,0x13,0x33,0x53,0x14,0x34,0x54,
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 3   

 117                               0
 118                          };    
 119          */
 120          code unsigned char slot[64]={0x00,0x07,0x0e,0x01,0x08,0x0f,0x02,
 121                               0x09,0x10,0x03,0x0a,0x11,0x04,0x0b,
 122                               0x12,0x05,0x0c,0x13,0x06,0x0d,0x14,
 123          
 124                               0x20,0x27,0x2e,0x21,0x28,0x2f,0x22,
 125                               0x29,0x30,0x23,0x2a,0x31,0x24,0x2b,
 126                               0x32,0x25,0x2c,0x33,0x26,0x2d,0x34,
 127          
 128                               0x40,0x47,0x4e,0x41,0x48,0x4f,0x42,
 129                               0x49,0x50,0x43,0x4a,0x51,0x44,0x4b,
 130                               0x52,0x45,0x4c,0x53,0x46,0x4d,0x54,
 131                               0
 132                          };
 133          
 134              
 135          static void writeTxJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 136          {
 137   1        int copOk = 0;
 138   1        int busBase = A_BUS_BASE;
 139   1        int i = 5;
 140   1        if(busB)
 141   1          busBase = B_BUS_BASE;
 142   1        // write  Tx J2 data
 143   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_DATA_REG(busBase)] = j2;
 144   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_WHICH_REG(busBase)] = witchJ2;
 145   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_SLOT_REG(busBase)] = RW_SEL | Slot;
 146   1        while(!copOk){
 147   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_RAM_STATUS_REG(busBase)] & 0x01;
 148   2          i--;
 149   2          if(i == 0)
 150   2            break;
 151   2          //Delay(1);
 152   2        }
 153   1      }
 154          
 155          static void writeExpectJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 156          {
 157   1        int copOk = 0;
 158   1        int busBase = A_BUS_BASE;
 159   1        int i = 5;
 160   1        if(busB) 
 161   1          busBase = B_BUS_BASE;
 162   1        // write  Tx J2 data
 163   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)] = j2;
 164   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = EXPECT_J2 |  witchJ2;
 165   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] = RW_SEL | Slot;
 166   1        while(!copOk){
 167   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 168   2          i--;
 169   2          if(i == 0)
 170   2            break;
 171   2          //Delay(1);
 172   2        }
 173   1      }
 174          
 175          static void readRxJ2(char chip, char witchJ2, char Slot, char *j2, char busB)
 176          {
 177   1        int copOk = 0;
 178   1        int busBase = A_BUS_BASE;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 4   

 179   1        int i = 5;
 180   1        if(busB) 
 181   1          busBase = B_BUS_BASE;
 182   1        
 183   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = RECEV_J2 |  witchJ2;
 184   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] =  Slot;
 185   1        while(!copOk){
 186   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 187   2          i--;
 188   2          if(i == 0)
 189   2            break;
 190   2          //Delay(1);
 191   2        }
 192   1        if(copOk){
 193   2          *j2 = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)];
 194   2        }else{
 195   2          *j2 = -1;
 196   2        }
 197   1        
 198   1      }
 199          
 200          /*****************************************************************
 201          ** 函数名:GETDATA
 202          ** 输　入: 无
 203          ** 输　出: 无
 204          ** 功能描述：采集单盘告警和性能
 205          ** 全局变量：无
 206          ** 调用模块：无
 207          ** 作　者：翁益晖
 208          ** 日　期：2002.5.25
 209          ** 修　改：
 210          ** 日　期：
 211          ** 版  本：1.0
 212          ****************************************************************/
 213          void GetData()          
 214          {
 215   1        unsigned char i,m,n,mi,ni,tmp,tmpi,ADCLK,PPILOS,TULOP,LPSLM,LPTIM,LPTIU,LPRDI,LPRFI,LPUNEQ,TUAIS,PPIAIS,
 216   1        LOOP,LOOPL,tv5;
 217   1        unsigned int  LPFEBE,HDB3;
 218   1        unsigned char lopCnt = 0;
 219   1        actnumber=0;
 220   1        almnumber=0;
 221   1        sw1021Chip = SW1021;
 222   1        for(i=0;i<(LINENUM-1);i++)
 223   1        {          
 224   2          
 225   2          if(g_ucState[78+i]==0)
 226   2          {
 227   3            g_ucLineMask[i]=1;
 228   3            // ADCLK 告警 (A 路下行时钟告警 )
 229   3            ADCLK=XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC; 
 230   3      
 231   3          }
 232   2          else   
 233   2          {
 234   3            m=i/21;
 235   3            n=i%21;
 236   3            mi=i/8;
 237   3            ni=i%8;
 238   3            
 239   3            sw1021Chip = SW1021_CHIP_ADDR(m);
 240   3            
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 5   

 241   3            if(TULOP||TUAIS)
 242   3              g_ucLofFlag[i]=1;      //有TULOP,TUAIS,PPILOS告警之一时上报UAS
 243   3            else
 244   3              g_ucLofFlag[i]=0;
 245   3            
 246   3            actnumber=actnumber+g_ucConfData[64+i];
 247   3            
 248   3            ADCLK = XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC;
 249   3            tmp = XBYTE[sw1021Chip+PORT_E1_ALARM_REG(n)];
 250   3            PPIAIS = tmp & E1AIS;
 251   3            PPILOS = tmp & E1LOS;
 252   3          /*
 253   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 254   3            TULOP = tmp & LOPI;
 255   3            TUAIS = tmp & AISI;
 256   3            LPSLM = tmp & PLMI;
 257   3            LPTIM = tmp & RTIMI;
 258   3            LPTIU = tmp & RTIUI;
 259   3            LPRDI = tmp & RDII;
 260   3            LPRFI = tmp & RFII;
 261   3            LPUNEQ = tmp & UNEQI;
 262   3          */
 263   3            
 264   3            tmpi = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 265   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG(A_BUS_BASE, n)] | tmpi;
 266   3            TULOP = tmp & LOPV;
 267   3            TUAIS = tmp & AISV;
 268   3            LPSLM = tmp & PLMV;
 269   3            LPTIM = tmp & RTIMV;
 270   3            LPTIU = tmp & RTIUV;
 271   3            LPRDI = tmp & RDIV;
 272   3            LPRFI = tmp & RFIV;
 273   3            LPUNEQ = tmp & UNEQV;
 274   3            
 275   3            if(TULOP) lopCnt++;
 276   3            
 277   3          #ifdef AIS_CONDITIONS 
 278   3            /** 方法1： 手动 */
 279   3            //AIS 产生条件 ---add by caijun.Li
 280   3            if(((g_ucConfData[2531] & 0x80) && LPTIM) || ((g_ucConfData[2531] & 0x40) && LPUNEQ ) || ((g_ucConfData
             -[2531] & 0x20) && LPSLM ) /* || ((g_ucConfData[2531] & 0x10) && LPSD )*/ ){
 281   4              // 下插AIS
 282   4              XBYTE[sw1021Chip + PORT_CFG_REG(n)] |= RAISEN;
 283   4            }else{
 284   4              // 停止下插AIS
 285   4              XBYTE[sw1021Chip + PORT_CFG_REG(n)] &= ~RAISEN;
 286   4            }
 287   3              
 288   3          #endif
 289   3            
 290   3            
 291   3            //must be write BIPERR_COUNTER_REG ; see manual
 292   3            XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 293   3            g_liError1s[i].ulDatlong += XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+BIP
             -ERR_COUNTER_REG(A_BUS_BASE, n) + 1] * 256);   // BIP错误计数值
 294   3            //must be write REI_COUNTER_REG ; see manual
 295   3            XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] = 0x00;
 296   3            LPFEBE = XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)] + (XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BAS
             -E, n) + 1] * 256); //REI(FEBE)计数值
 297   3            
 298   3            
 299   3            tmp = XBYTE[sw1021Chip + PORT_TEST_REG(n)]; 
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 6   

 300   3            LOOP =   tmp & LnLBK;
 301   3            if(ALERT_LOOPL == 0){
 302   4              LOOPL = 1;
 303   4            }else{
 304   4              LOOPL =  tmp & E1LBK;
 305   4            }
 306   3            
 307   3            if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 308   3            {
 309   4              g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;
 310   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)].ucState=1;           
 311   4              else                                              //E1输入口有信号时/// 
 312   4              {
 313   5                if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==1)  //如果还存在PPILOS告警//
 314   5                if(WP==1)                        //非保护盘位时//
 315   5                {
 316   6                  // 向第i通道上话方向插短时间的伪随机码
 317   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 318   6                  g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS//
 319   6          
 320   6                  Delay(10);
 321   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &=  ~(PRBSEN | PRBST); //停插伪随机码
 322   6      
 323   6                }
 324   5                else g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS////保护盘位时//
 325   5              }
 326   4      
 327   4            }
 328   3            else
 329   3            {
 330   4              g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;
 331   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;               
 332   4              else  g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=1;
 333   4            }              
 334   3            //if(PPIAIS) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;               
 335   3            //else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 336   3            if(TULOP) g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=1;              
 337   3            else g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=0;  
 338   3            if(TUAIS) g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=1;              
 339   3            else g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=0;
 340   3            if(TULOP||TUAIS)
 341   3            {
 342   4              g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 343   4              g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 344   4              g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 345   4              #ifdef NEED_LP_RFI
                      g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
                      #endif
 348   4              g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0; 
 349   4            }
 350   3            else
 351   3            {
 352   4              if(LPSLM) g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=1;              
 353   4              else g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 354   4              if(LPRDI) g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=1;              
 355   4              else g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 356   4              if(LPUNEQ) g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=1;               
 357   4              else g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 358   4      
 359   4              /* 烽火老设备未使用RFI,不使用时将下面两句屏蔽 */
 360   4      #ifdef NEED_LP_RFI
                       if(LPRFI) g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=1;              
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 7   

                       else g_stuAlm[i*(ALMTYPENUM-3)+15].ucState=0; 
              #endif
 364   4              
 365   4              if(LPTIM) g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=1;              
 366   4              else g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0;  
 367   4            }
 368   3            if(LOOPL) g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=1;               
 369   3            else g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=0;
 370   3            if(LOOP) g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=1;              
 371   3            else g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=0;
 372   3            if(g_stuPm[i*PMTYPENUM+3].Value.usint>=(0xffff-LPFEBE)) g_stuPm[i*PMTYPENUM+3].Value.usint=0xffff;     
             -  
 373   3            else g_stuPm[i*PMTYPENUM+3].Value.usint+=LPFEBE;   //REI(FEBE)性能值                    
 374   3            if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==0)                               //无PPI_LOS告警时
 375   3            {
 376   4               //HDB3编码违例计数值
 377   4              HDB3 = XBYTE[sw1021Chip + HDB3_CV_REG(n)];
 378   4              
 379   4              if(g_stuPm[i*PMTYPENUM+4].Value.usint>=(0xffff-HDB3)) g_stuPm[i*PMTYPENUM+4].Value.usint=0xffff;     
 380   4              else g_stuPm[i*PMTYPENUM+4].Value.usint+=HDB3;      // HDB3性能值         //g_stuPm[i][4]=HDB3CV
 381   4            }           
 382   3      
 383   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState)
 384   3            almnumber=almnumber+1;
 385   3            
 386   3            tv5 = XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)];
 387   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3
             -)+4].ucState)
 388   3            { //如果TUAIS,TULOP,LPUNEQ之一为"1" 则向上插VC12=AIS,LPRDI,向下插AIS
 389   4                if((tv5 & RDI_CNF) != RDI_CNF)
 390   4                  XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 | RDI_CNF;
 391   4            }
 392   3            else
 393   3            {
 394   4              if((tv5 & RDI_CNF) == RDI_CNF)
 395   4                XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 & (~RDI_CNF);
 396   4            }
 397   3          }
 398   2        }
 399   1      
 400   1        for(i=0;i<(LINENUM-1);i++)
 401   1        {
 402   2          m=i/21;
 403   2          n=i%21;
 404   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 405   2          // 获取N2 和 K4 值
 406   2          //TODO: get N2
 407   2          //g_ucState[204+2*i]=XBYTE[WGS21891+0x0100+0x10*n+0x0C]; 
 408   2          g_ucState[205+2*i]=XBYTE[sw1021Chip + RX_K4_REG(A_BUS_BASE,n)];
 409   2          
 410   2          
 411   2          mi=i/8;
 412   2          ni=i%8;
 413   2          if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 414   2            g_ucState[330+mi]&=(~(0x01<<ni));
 415   2      
 416   2          else
 417   2            g_ucState[330+mi]|=(0x01<<ni);    
 418   2      
 419   2          //  tv5=XBYTE[WGS21891+0x0100+0x10*n+0x00];
 420   2      
 421   2        }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 8   

 422   1      
 423   1         
 424   1      
 425   1        if(TUXAB) g_ucState[77]=0;
 426   1        else g_ucState[77]=1;
 427   1                           
 428   1             
 429   1        if((WP==0) && (TUSWTI==0))   //保护盘位时,如果没有倒换ACT灯慢闪//     
 430   1        {
 431   2          g_ucState[76]=0;
 432   2          g_LampEn=0;        
 433   2          if(g_stuSysClock.ucSecond%2==0) ACT=ON;
 434   2          else ACT=OFF;
 435   2          for(i=0;i<(LINENUM-1);i++)
 436   2          {
 437   3            g_ucLineMask[i]=1;
 438   3            g_ucState[141+i]=1;
 439   3          }
 440   2        }
 441   1        else if(g_ucState[76]==0)
 442   1        {                           
 443   2          for(i=0;i<(LINENUM-1);i++)
 444   2          {
 445   3            if((g_ucConfData[64+i]==0)||(g_ucConfData[137+i]==01))
 446   3            {    
 447   4              g_ucLineMask[i]=1;
 448   4              g_ucState[141+i]=1;  
 449   4            }   
 450   3            else
 451   3            {
 452   4              g_ucLineMask[i]=0;  
 453   4              g_ucState[141+i]=0;
 454   4            }
 455   3          }
 456   2          g_ucState[76]=1;     
 457   2          g_LampEn=1;
 458   2          WROUTPORT;           
 459   2        }
 460   1             
 461   1        UasClear();
 462   1      
 463   1      
 464   1        if(g_AllClrFlag)                //清性能
 465   1        {   
 466   2          g_bClearUas=1; 
 467   2          g_AllClrFlag=0;
 468   2        }
 469   1      
 470   1        if(g_SecondFlag)                   //秒标识，1：进入新的一秒
 471   1        {
 472   2          CalUas(ulSesLmt);           //uas计算        
 473   2      
 474   2          for(i=0; i<(LINENUM-1); i++)
 475   2          {
 476   3            g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];         //bbe_lp性能的采集
 477   3            g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];        //es_lp性能的采集
 478   3            g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];       //ses_lp性能的采集
 479   3            if(g_usiEs[i]>=ulEsLimit) 
 480   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=1;    //curalm[i][8]=es_limit
 481   3            else 
 482   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=0;
 483   3            // if(g_usiSes[i]>=ulSesLimit) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;    //curalm[i][9]=ses_limit
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 9   

 484   3            // else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 485   3            g_stuPm[i*PMTYPENUM+5].Value.usint=g_usiUas[i];             //UAS_LP性能的采集
 486   3            g_stuPm[i*PMTYPENUM+6].Value.usint=g_usiCses[i];            //cses_lp性能的采集
 487   3      
 488   3      
 489   3            /******************************************************************************/
 490   3            if(g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3)+1].ucState)
 491   3            {
 492   4              g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 493   4              BIP[i]=0;
 494   4            }
 495   3            else
 496   3            {
 497   4              BIP_2_1S[i]=BIP[i];
 498   4              BIP_2_1000S[i]+=BIP[i];  
 499   4              BIP[i]=0;
 500   4              switch(g_ucConfData[129])
 501   4              {
 502   5                case 0x04:
 503   5                if(BIP_2_1S[i]>=217) 
 504   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 505   5                else if(BIP_2_1S[i]<=23) 
 506   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 507   5                break;
 508   5      
 509   5                case 0x05:
 510   5                if(BIP_2_1S[i]>=22) 
 511   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 512   5                else if(BIP_2_1S[i]<=3) 
 513   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 514   5                break;
 515   5      
 516   5                case 0x06:
 517   5      
 518   5      
 519   5                if((N1000[i]>=10)&&(N1000[i]<100))
 520   5                {
 521   6                  if(BIP_2_1000S[i]>=22) 
 522   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 523   6                  else if(BIP_2_1000S[i]<=3) 
 524   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 525   6                  N1000[i]=0;
 526   6                  BIP_2_1000S[i]=0;
 527   6                }
 528   5                else N1000[i]++;
 529   5      
 530   5                break;
 531   5      
 532   5                case 0x07:
 533   5      
 534   5      
 535   5                if((N1000[i]>=100)&&(N1000[i]<1000))
 536   5                {
 537   6                  if(BIP_2_1000S[i]>=22) 
 538   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 539   6                  else if(BIP_2_1000S[i]<=3) 
 540   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 541   6                  N1000[i]=0;
 542   6                  BIP_2_1000S[i]=0;
 543   6                }
 544   5                else N1000[i]++;
 545   5                break;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 10  

 546   5      
 547   5                case 0x08:
 548   5      
 549   5      
 550   5                if(N1000[i]>=1000)
 551   5                {
 552   6                  if(BIP_2_1000S[i]>=22) 
 553   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 554   6                  else if(BIP_2_1000S[i]<=3) 
 555   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 556   6                  N1000[i]=0;
 557   6                  BIP_2_1000S[i]=0;
 558   6                }
 559   5                else 
 560   5                  N1000[i]++;
 561   5                break;
 562   5              }
 563   4            }
 564   3      
 565   3          /********************************************************************************/
 566   3      
 567   3          }
 568   2      
 569   2          g_SecondFlag=0;      //秒标识清?
 570   2      
 571   2        }     
 572   1      
 573   1        //IO8=1;
 574   1        // WRHIO;
 575   1        //RDHIO;    
 576   1        //IO9=1;
 577   1        // WRHIO;
 578   1        //RDHIO;
 579   1        //IO10=1;
 580   1        // WRHIO;
 581   1        //RDHIO;
 582   1        //IO11=1;
 583   1        // WRHIO;
 584   1        //RDHIO;
 585   1        //IO12=1;
 586   1        // WRHIO;
 587   1        RDHIO;
 588   1      
 589   1         
 590   1             
 591   1        if(ADCLK||(P2V5==0)||(first_conf==0)) 
 592   1          TUALMO=1; //如果工作支路中全部有告警或2.5V//
 593   1        else 
 594   1          TUALMO=0; //电源有告警或下配置前TUALMO=1,否则TUALMO=0//
 595   1        if((P5VI1==0)&&(DZBI1==0)) 
 596   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=1;
 597   1        else    
 598   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=0;               
 599   1        if((P5VI2==0)&&(DZBI2==0)) 
 600   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=1;
 601   1        else    
 602   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=0;       
 603   1        if(P2V5==0) 
 604   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=1;
 605   1        else    
 606   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=0;                     
 607   1       
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 11  

 608   1      }
 609          
 610          /*****************************************************************
 611          ** 函数名:USERFUN
 612          ** 输　入: 无
 613          ** 输　出: 无
 614          ** 功能描述：用户实时处理函数，10毫秒被调用一次
 615          ** 全局变量：无
 616          ** 调用模块：无
 617          ** 作　者：翁益晖
 618          ** 日　期：2002.5.25
 619          ** 修　改：
 620          ** 日　期：
 621          ** 版  本：1.0
 622          ****************************************************************/
 623          void UserFunc() using 1
 624          {
 625   1        #if 0
                int i,j;
                int tmp;
                unsigned int chip  = SW1021;
                static int docnt = 0;
                if(g_haveTux){
                  if(docnt == 0){
                    XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
                    
                    XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
                    
                    XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
                    XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
                    docnt++;
                    return;
                  }
                  if(docnt > 2){
                    docnt = 0;
                    g_haveTux = 0;
                  }
                  for(i=0; i<CHIPS_ON_BOARD; i++){
                    for(j=0; j< 21; j++){
                      tmp = XBYTE[chip+PORT_E1_ALARM_REG(j)];
                      if((tmp & RFFERR) == 0){
                        continue;
                      }else{
                        //XBYTE[SW1021_CHIP_ADDR(k) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
                        XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
                        
                        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
                        
                        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
                        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
                      
                        g_haveTux = 0;
                        docnt = 0;
                        return;
                      }
                    }
                    chip+=0x1000;
                  }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 12  

                  docnt++;
                }
                #endif
 673   1        return;
 674   1      }
 675          
 676          /*
 677          //static void ChecktuxAB (void) interrupt 9 using 3
 678          static void ChecktuxAB (void) interrupt 9
 679          {
 680          
 681            EX3 = 0;
 682            EXIF &= 0xDF;
 683            g_haveTux = 1;
 684          
 685          
 686            EX3 = 1;
 687            return;
 688          }
 689          */
 690          
 691          static void happenSwich (void) interrupt 8
 692          {
 693   1      
 694   1        EX2 = 0;
 695   1        EXIF &= 0xEF;
 696   1        //g_haveTux = 1;
 697   1        
 698   1        XBYTE[SW1021 + SOFTWARE_RST_REG] = SRST_E1;
 699   1        XBYTE[SW1021 + SOFTWARE_RST_REG] = RST_CANCLE;
 700   1                
 701   1        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = SRST_E1;
 702   1        XBYTE[SW1021 + 0x1000 + SOFTWARE_RST_REG] = RST_CANCLE;
 703   1                
 704   1        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = SRST_E1;
 705   1        XBYTE[SW1021 + 0x2000 + SOFTWARE_RST_REG] = RST_CANCLE;
 706   1        
 707   1      
 708   1        EX2 = 1;
 709   1        return;
 710   1      }
 711          
 712          /*****************************************************************
 713          ** 函数名:CONF_SET
 714          ** 输　入: 无
 715          ** 输　出: 无
 716          ** 功能描述：单盘配置
 717          ** 全局变量：无
 718          ** 调用模块：无
 719          ** 作　者：caijun.Li
 720          ** 日　期：2016.3.19
 721          ** 修　改：
 722          ** 日　期：
 723          ** 版  本：1.0
 724          ****************************************************************/
 725          void ConfSet(void)
 726          {
 727   1          /*Process ALMMASK*/
 728   1          /*Process PMMASK*/
 729   1        unsigned char i,j,ilong,m,n,temp;
 730   1      
 731   1        g_ucState[69]=g_ucConfData[5];
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 13  

 732   1        g_ucState[70]=g_ucConfData[6];
 733   1        g_ucState[71]=g_ucConfData[7];
 734   1        g_ucState[72]=g_ucConfData[8];
 735   1        g_ucState[73]=g_ucConfData[9];
 736   1        g_ucState[74]=g_ucConfData[10];
 737   1        g_ucState[75]=g_ucConfData[11];
 738   1        for(i=0;i<(LINENUM-1);i++){
 739   2          m=i/21;
 740   2          n=i%21;
 741   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 742   2        
 743   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 744   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 745   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 746   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 747   2      
 748   2          if(g_ucConfData[64+i]==0){  // 支路关闭
 749   3            // 上下话强发AIS
 750   3            if(ALERT_LOOPL) {
 751   4            //XBYTE[sw1021Chip + TX_CTRL_REG(B_BUS_BASE,n)] = AIS_EN; 
 752   4            temp = XBYTE[sw1021Chip + PORT_CFG_REG(n)];
 753   4            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = temp | TAISEN | RAISEN; 
 754   4            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = 0x00;
 755   4            }
 756   3                  
 757   3            g_ucState[78+i]=0;     
 758   3            g_ucLineMask[i]=1;
 759   3            g_ucState[141+i]=1;
 760   3          }else{  // 支路打开
 761   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = A_UP_DOWN | RnEN;
 762   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = (0x02 << 1);  // 注意信号标记值得配置
 763   3            if(g_ucState[78+i]==0)//刚打开支路开关时插伪随机码
 764   3            {
 765   4              //TODO: 启动误码计数器
 766   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= PRBSEN | PRBST;
 767   4              Delay(5);
 768   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= ~(PRBSEN | PRBST);
 769   4              g_ucState[78+i]=1;
 770   4              g_ucLineMask[i]=0; 
 771   4              g_ucState[141+i]=0;
 772   4            }         
 773   3          }
 774   2          XBYTE[sw1021Chip + TX_K4_REG(A_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 775   2          XBYTE[sw1021Chip + TX_K4_REG(B_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 776   2          // TODO: N2 发
 777   2          //XBYTE[WGS21891+0x0100+0x10*n+0x01]=g_ucConfData[263+4*i];                 // N2 发
 778   2        
 779   2        #ifdef AIS_CONDITIONS_AUTO
                  if((g_ucConfData[2531] & 0x80)){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }else{
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= J2RTIME;
                  }
                  if(g_ucConfData[2531] & 0x40){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= UNEQAISE;
                  }
                  if(g_ucConfData[2531] & 0x20){
                    XBYTE[sw1021Chip + RCV_INSET_AIS_REG(A_BUS_BASE,n)] |= PLMAISE;
                  }
                #endif
 792   2        
 793   2          // J2 发 和 期望收
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 14  

 794   2          for(j=0;j<16;j++)
 795   2          {
 796   3            if(j==0) temp=0x80;
 797   3            else temp=0;
 798   3            
 799   3            // A 
 800   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 0);
 801   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 0);
 802   3            // B
 803   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 1);
 804   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 1);
 805   3          }
 806   2          
 807   2          if(g_ucConfData[137+i]==0)   //confdata[137+i]==0不屏蔽支路i告警/否则屏蔽支路i告警//
 808   2          {
 809   3            g_ucLineMask[i]=0;
 810   3            g_ucState[141+i]=0;
 811   3          }
 812   2          else
 813   2          {
 814   3            g_ucLineMask[i]=1;
 815   3            g_ucState[141+i]=1;
 816   3          }
 817   2        //if(g_ucConfData[200+i]==0)     //confdata[200+i]==1支路i装载/否则不装载//
 818   2        //XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x00;
 819   2        // else  XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x04;
 820   2      
 821   2        }
 822   1      
 823   1      
 824   1      
 825   1        for(j=0;j<ALMTYPENUM;j++) 
 826   1        {
 827   2           
 828   2           for(ilong=29;ilong<(29+ALMTYPENUM);ilong++)
 829   2           {    
 830   3              if(g_ucConfData[ilong]==g_ucAlmCode[j])   //从网管设告警屏蔽//
 831   3              {
 832   4               g_ucAlmMask[j]=1;                              
 833   4               break;     
 834   4              }
 835   3              else
 836   3              g_ucAlmMask[j]=0;
 837   3      
 838   3           }
 839   2        }      
 840   1                          
 841   1        for(j=0;j<PMTYPENUM;j++)  
 842   1        {
 843   2      
 844   2          for(ilong=54;ilong<(54+PMTYPENUM);ilong++)
 845   2          {   
 846   3            if(g_ucConfData[ilong]==g_ucPmCode[j])   //从网管设性能屏蔽//
 847   3            {
 848   4              g_ucPmMask[j]=1;                              
 849   4              break;    
 850   4            }
 851   3            else
 852   3              g_ucPmMask[j]=0;
 853   3          }
 854   2        }        
 855   1      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 15  

 856   1        ulEsLimit=256*g_ucConfData[131]+g_ucConfData[132];    //从网管设ulEsLimit门限//
 857   1        ulSesLimit=256*g_ucConfData[134]+g_ucConfData[135];   //从网管设ulSesLimit门限//
 858   1      
 859   1      
 860   1        //if((g_ucConfData[136]==0)&&TUALMO&&WP) TUALMO=0;  //IO2=TUALMO  confdata[108]=盘保护模式不保护
 861   1      
 862   1      
 863   1        // g_ucConfChange=0;                          
 864   1              
 865   1      
 866   1        if(first_conf==0) first_conf=1; 
 867   1      }
 868          
 869          
 870          /*****************************************************************
 871          ** 函数名:UserHdlc
 872          ** 输　入: 无
 873          ** 输　出: 无
 874          ** 功能描述：单盘特殊命令处理
 875          ** 全局变量：无
 876          ** 调用模块：无
 877          ** 作　者：caijun.Li
 878          ** 日　期：2016.3.19
 879          ** 修　改：
 880          ** 日　期：
 881          ** 版  本：1.0
 882          ****************************************************************/
 883          void UserHdlc(void)
 884          {
 885   1        unsigned char i,j,m,n,temp;
 886   1        unsigned int addr;
 887   1        char val;
 888   1      
 889   1        if (g_ucHdlcBuf[CMD_TYPE]==COMM_CATA)
 890   1        {
 891   2          if (g_ucHdlcBuf[CMD_CODE]==RTRV_OCONF)
 892   2          {
 893   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;
 894   3          }
 895   2          else if (g_ucHdlcBuf[CMD_CODE]==SET_OCONF)
 896   2          {
 897   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;                                               
 898   3          }
 899   2        }
 900   1      
 901   1      
 902   1        switch(g_ucHdlcBuf[5])
 903   1        {
 904   2          case 0x00:    /*SET_LOOP*/
 905   2            if(g_ucHdlcBuf[6]==0x34)
 906   2            { // 设备环回
 907   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 908   3                g_ucHdlcBuf[10]=0x80; 
 909   3              else                
 910   3                for(i=0;i<(g_usRxDataLen);i++)
 911   3                {
 912   4                  temp=g_ucHdlcBuf[14+i]-1;
 913   4                  m=temp/21;
 914   4                  n=temp%21;
 915   4      
 916   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 917   4                  if(g_ucHdlcBuf[7]==0x01){
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 16  

 918   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
 919   5                  }else{
 920   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
 921   5                  }
 922   4                  g_ucHdlcBuf[10]=0x00;
 923   4                }
 924   3            }
 925   2            else if(g_ucHdlcBuf[6]==0x33)       /*SET_LOOPL*/
 926   2            { // 线路环回 
 927   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 928   3                g_ucHdlcBuf[10]=0x80; 
 929   3              else{
 930   4                // 判断是否为全部线路环回
 931   4                if(g_usRxDataLen == 63){
 932   5                  if(g_ucHdlcBuf[7]==0x01){
 933   6                    ALERT_LOOPL = 0;
 934   6                    for(i=0; i<63; i++){
 935   7                        m=i/21;
 936   7                        n=i%21;
 937   7                        sw1021Chip = SW1021_CHIP_ADDR(m);
 938   7                        if(g_ucState[78+i] == 0){
 939   8                          // 未打开该支路，执行打开
 940   8                          XBYTE[sw1021Chip + PORT_CFG_REG(n)] = A_UP_DOWN | RnEN;
 941   8                          XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = (0x02 << 1);  // 注意信号标记值得配置
 942   8                        }
 943   7                    }
 944   6                    
 945   6                  }else{
 946   6                    ALERT_LOOPL = 1;
 947   6                    for(i=0; i<63; i++){
 948   7                        m=i/21;
 949   7                        n=i%21;
 950   7                        sw1021Chip = SW1021_CHIP_ADDR(m);
 951   7                        XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~E1LBK);
 952   7                        if(g_ucState[78+i] == 0){
 953   8                          // 未打开该支路，执行关闭
 954   8                          temp = XBYTE[sw1021Chip + PORT_CFG_REG(n)];
 955   8                          XBYTE[sw1021Chip + PORT_CFG_REG(n)] = temp | TAISEN | RAISEN; 
 956   8                          XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = 0x00;
 957   8                        }
 958   7                    }
 959   6                  }
 960   5                  g_ucHdlcBuf[10]=0x00;
 961   5                }else{
 962   5                
 963   5                  for(i=0;i<(g_usRxDataLen);i++)
 964   5                  {
 965   6                    temp=g_ucHdlcBuf[14+i]-1;
 966   6                    m=temp/21;
 967   6                    n=temp%21;
 968   6                    
 969   6                    sw1021Chip = SW1021_CHIP_ADDR(m);
 970   6                    if(g_ucHdlcBuf[7]==0x01){
 971   7                      XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= E1LBK;
 972   7                    }else{
 973   7                      XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~E1LBK);
 974   7                    }
 975   6                    g_ucHdlcBuf[10]=0x00;
 976   6                  }
 977   5                }
 978   4              }
 979   3            }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 17  

 980   2            else if(g_ucHdlcBuf[6] == 0x45){  /* 请求报告J字节等辅助信息 */
 981   3              int addr = 0;
 982   3              g_ucHdlcBuf[10]=0x00;
 983   3              g_ucHdlcBuf[11]=0x00;
 984   3              g_ucHdlcBuf[12]=0x04;
 985   3              g_ucHdlcBuf[13]=0x6e;
 986   3            
 987   3              addr = 14;
 988   3              for(i=0; i<63; i++){
 989   4                m = i/21;
 990   4                n = i%21;
 991   4                g_ucHdlcBuf[addr++] = 0x02; //J2
 992   4                g_ucHdlcBuf[addr++] = i;   //TODO: 确认支路号是从0开始还是从1开始
 993   4                for(j=0;j<16;j++){
 994   5                  readRxJ2(m, j, slot[i], &val, 0);
 995   5                  g_ucHdlcBuf[addr++] = val; //J2 value
 996   5                }         
 997   4              } 
 998   3              g_ucHdlcBuf[10]=0x00;       
 999   3              
1000   3            }
1001   2            break;
1002   2          case 0x20:
1003   2             if(g_ucHdlcBuf[6] == 0x09){  /* 大网管请求报告J字节等辅助信息 */
1004   3              int addr = 0;
1005   3              g_ucHdlcBuf[10]=0x00;
1006   3              g_ucHdlcBuf[11]=0x00;
1007   3              g_ucHdlcBuf[12]=0x04;
1008   3              g_ucHdlcBuf[13]=0x6e;
1009   3            
1010   3              addr = 14;
1011   3              for(i=0; i<63; i++){
1012   4                m = i/21;
1013   4                n = i%21;
1014   4                g_ucHdlcBuf[addr++] = 0x02; //J2
1015   4                g_ucHdlcBuf[addr++] = i;   //TODO: 确认支路号是从0开始还是从1开始
1016   4                for(j=0;j<16;j++){
1017   5                  readRxJ2(m, j, slot[i], &val, 0);
1018   5                  g_ucHdlcBuf[addr++] = val; //J2 value
1019   5                }         
1020   4              }
1021   3              g_ucHdlcBuf[10]=0x00;         
1022   3              
1023   3            }
1024   2          break;
1025   2      
1026   2          case 0x77:                /**透明帧命令**/
1027   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];  // commbuf[14]，commbuf[15]所存放 的 地址
1028   2            g_ucHdlcBuf[10]=0x00;
1029   2            g_ucHdlcBuf[11]=0x00;
1030   2            g_ucHdlcBuf[12]=0x00;
1031   2            g_ucHdlcBuf[13]=0x11;
1032   2            //读16个字节//  addr 地址开始读取16个字节数据//
1033   2            for(i=0;i<16;i++) 
1034   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; 
1035   2            g_ucHdlcBuf[30]=P1;
1036   2            break;                   
1037   2          
1038   2          case 0x88:
1039   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];
1040   2            XBYTE[addr]=g_ucHdlcBuf[16];       //将commbuf[16]存放的数据送入commbuf[14]，//
1041   2            g_ucHdlcBuf[10]=0x00;              //commbuf[15]所存放的WGS21891的地址单元中//
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 18  

1042   2            g_ucHdlcBuf[11]=0x00;
1043   2            g_ucHdlcBuf[12]=0x00;
1044   2            g_ucHdlcBuf[13]=0x10;              //读16个字节//
1045   2            for(i=0;i<16;i++) 
1046   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; //从commbuf[14]，commbuf[15]的地址开始读取16个字节数据//
1047   2            break;
1048   2      
1049   2          
1050   2          case 0X99:
1051   2            while(1)
1052   2            {;}
1053   2            if((g_usRxDataLen==0)||(g_usRxDataLen>63)) 
1054   2              g_ucHdlcBuf[10]=0x80; 
1055   2            else                
1056   2              for(i=0;i<(g_usRxDataLen);i++)
1057   2              {
1058   3                temp=g_ucHdlcBuf[14+i]-1;
1059   3                m=temp/21;
1060   3                n=temp%21;
1061   3                sw1021Chip = SW1021_CHIP_ADDR(m);
1062   3                          
1063   3                g_ucHdlcBuf[17]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
1064   3                g_ucHdlcBuf[18]=0xbb;
1065   3                
1066   3                if(g_ucHdlcBuf[7]==0x01)
1067   3                {
1068   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
1069   4                  if(n<8)
1070   4                    g_ucHdlcBuf[18]=0xff;
1071   4                }
1072   3                else
1073   3                {
1074   4                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
1075   4                }
1076   3                    
1077   3              }
1078   2            g_ucHdlcBuf[10]=0x00;
1079   2            g_ucHdlcBuf[13]=6;
1080   2            g_ucHdlcBuf[14]=0xaa;
1081   2            g_ucHdlcBuf[15]=m;
1082   2            g_ucHdlcBuf[16]=n;
1083   2            g_ucHdlcBuf[19]=XBYTE[sw1021Chip + PORT_TEST_REG(n)];
1084   2            
1085   2            break;
1086   2            
1087   2      
1088   2        }
1089   1      
1090   1      }
1091          
1092          /*****************************************************************
1093          ** 函数名:SELF_CONF
1094          ** 输　入: 无
1095          ** 输　出: 无
1096          ** 功能描述：单盘上电默认配置
1097          ** 全局变量：g_ucConfData[]
1098          ** 调用模块：无
1099          ** 作　者：翁益晖
1100          ** 日　期：2002.5.25
1101          ** 修　改：
1102          ** 日　期：
1103          ** 版  本：1.0
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 19  

1104          ** 注  意：所有告警和性能的初始化需安线路号顺序
1105          ****************************************************************/
1106          void SelfConf()
1107          {
1108   1      
1109   1        unsigned int i,j;
1110   1        char ctt[18];
1111   1        unsigned char ucii;
1112   1        //  first_conf=0;
1113   1        g_ucConfData[22]=BOARDCODE;/*BDINF5*/
1114   1        g_ucConfData[0]=0xfe;
1115   1      
1116   1      
1117   1        sprintf(ctt,BoardSn);
1118   1        for(ucii=0;ucii<15;ucii++) g_ucState[ucii]=ctt[ucii];  /*盘号*/
1119   1      
1120   1        sprintf(ctt,PcbSn);   
1121   1        for(ucii=0;ucii<15;ucii++) g_ucState[15+ucii]=ctt[ucii]; /*板号*/
1122   1      
1123   1        sprintf(ctt,PcbTime);   
1124   1        for(ucii=0;ucii<10;ucii++) g_ucState[30+ucii]=ctt[ucii]; /*制板时间*/
1125   1      
1126   1        for(ucii=0;ucii<18;ucii++) ctt[ucii]=0;    /*版本号buf清零*/
1127   1        //sprintf(ctt,"R170609R1B/01F    "); 
1128   1        //for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
1129   1        sprintf(ctt,BoardSoftVer); 
1130   1        for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
1131   1        sprintf(ctt,__DATE__);   
1132   1        for(ucii=0;ucii<11;ucii++) g_ucState[58+ucii]=ctt[ucii]; /*编程时间*/
1133   1      
1134   1        //g_ucState[69]=0x07;
1135   1        //g_ucState[70]=0xD1;
1136   1        //g_ucState[71]=0x06;
1137   1        //g_ucState[72]=0x01;
1138   1        //g_ucState[73]=0x08;
1139   1        //g_ucState[74]=0x00;
1140   1        //g_ucState[75]=0x00;
1141   1        g_ucState[76]=0x01;
1142   1        //g_ucState[77]=0x01;
1143   1      
1144   1      
1145   1      
1146   1        for(i=0;i<LINENUM;i++)           /*linecode=1..63*/
1147   1          g_ucLineCode[i]=i+1;
1148   1        for(i=0;i<LINENUM;i++)
1149   1        {
1150   2          g_ucLineMask[i]=0;          
1151   2      
1152   2        }
1153   1      
1154   1      
1155   1      
1156   1        /*for(i=0;i<LINENUM;i++)
1157   1        for(j=0;j<PMNUM;j++) linepmmask[i][j]=0;*/         
1158   1      
1159   1      
1160   1        actnumber=63;             
1161   1        almnumber=0;     
1162   1      
1163   1        ulEsLimit=0xff;
1164   1        ulSesLimit=0xff;
1165   1      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 20  

1166   1        g_ucAlmCode[0]=0x03;                        /*PPI_LOS*/
1167   1        g_ucAlmCode[1]=0x27;                        /*TU_LOP*/
1168   1        g_ucAlmCode[2]=0x22;                        /*LP_SLM*/
1169   1        g_ucAlmCode[3]=0x20;                        /*LP_RDI*/
1170   1        g_ucAlmCode[4]=0x24;                        /*LP_UNEQ*/
1171   1        //g_ucAlmCode[8]=0x04;                        /*PPI_AIS*/
1172   1        g_ucAlmCode[5]=0x02;                        /*TU_AIS*/
1173   1      #ifdef NEED_LP_RFI
                g_ucAlmCode[15]=0x0c;                        /*LP_RFI*/
              #endif
1176   1        g_ucAlmCode[7]=0x51;                        /*ES_LIMIT*/
1177   1        //g_ucAlmCode[8]=0x52;      /*SES _LIMIT*/
1178   1        g_ucAlmCode[9]=0x28;                       /*LP_TIM*/
1179   1        g_ucAlmCode[10]=0x4f;                       /*LOOPL*/
1180   1        g_ucAlmCode[11]=0x55;     /*LOOP*/
1181   1        g_ucAlmCode[12]=0x01;                       //2V5电源故障告警//
1182   1        g_ucAlmCode[13]=0x05;                       //5VI1电源故障告警//
1183   1        g_ucAlmCode[14]=0x06;                       //5VI2电源故障告警//
1184   1        g_ucAlmCode[6]=0x07;                 //trafic-onload//
1185   1        g_ucAlmCode[8]=0x08;                /*LP_SD*/
1186   1      
1187   1        g_ucPmCode[0]=0x08;                   /*BBE_LP*/
1188   1        g_ucPmCode[1]=0x02;                   /*ES_LP*/
1189   1        g_ucPmCode[2]=0x03;                   /*SES_LP*/
1190   1        g_ucPmCode[3]=0x07;                   /*REI_LP*/
1191   1        g_ucPmCode[4]=0x0b;                   /*HDB3CV*/
1192   1        //g_ucPmCode[5]=0x06;                 /*UAS_LP*/
1193   1        g_ucPmCode[5]=0x0c;                   /*UAS_LP*/
1194   1        g_ucPmCode[6]=0xa2;                   /*CSES_LP*/
1195   1      
1196   1        g_ucAlmType[0]=0;   /*almtype：0急告；4非急告；8状态量*/
1197   1        g_ucAlmType[1]=0;
1198   1        g_ucAlmType[2]=0;
1199   1        g_ucAlmType[3]=4;
1200   1        g_ucAlmType[4]=4;
1201   1        g_ucAlmType[5]=4;
1202   1        g_ucAlmType[6]=8;
1203   1        g_ucAlmType[7]=4;
1204   1        g_ucAlmType[8]=4;
1205   1        g_ucAlmType[9]=0;      /*LP_TIM*/
1206   1        g_ucAlmType[10]=8;         
1207   1        g_ucAlmType[11]=8;  
1208   1        g_ucAlmType[12]=0;
1209   1        g_ucAlmType[13]=0;
1210   1        g_ucAlmType[14]=0;
1211   1        
1212   1      #ifdef NEED_LP_RFI
                g_ucAlmType[15]=4;
              #endif
1215   1      
1216   1        for(j=0;j<(LINENUM-1);j++)
1217   1        {
1218   2          for(i=0;i<(ALMTYPENUM-3);i++)
1219   2          {
1220   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucLineIndex=j;
1221   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucAlmIndex=i;
1222   3          }
1223   2        }
1224   1      
1225   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucLineIndex=63;
1226   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucAlmIndex=12;
1227   1      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 21  

1228   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucLineIndex=63;
1229   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucAlmIndex=13;
1230   1      
1231   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucLineIndex=63;
1232   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucAlmIndex=14;
1233   1      
1234   1      
1235   1        for(j=0;j<(LINENUM-1);j++)
1236   1        {
1237   2          for(i=0;i<PMTYPENUM;i++)
1238   2          {
1239   3            g_stuPm[j*PMTYPENUM+i].ucLineIndex=j;
1240   3            g_stuPm[j*PMTYPENUM+i].ucPmIndex=i;
1241   3          }
1242   2        }
1243   1      
1244   1        for(i=0;i<UASNUM;i++)
1245   1        {
1246   2          g_liError1s[i].ulDatlong=0;
1247   2          ulSesLmt[i]=700; //若某一秒内误码个数大于等于ulSesLmt[i]时,该秒是严重误码秒//
1248   2        }                  
1249   1      }
1250          
1251          
1252          
1253          /*****************************************************************
1254          ** 函数名:InitioSw1021
1255          ** 输　入: 无
1256          ** 输　出: 无
1257          ** 功能描述：SW1021初始化
1258          ** 全局变量：
1259          ** 调用模块：
1260          ** 作　者：caijun.Li
1261          ** 日　期：2016.3.18
1262          ** 修　改：
1263          ** 日　期：
1264          ** 版  本：1.0
1265          ****************************************************************/
1266          void InitioSw1021()
1267          {
1268   1      
1269   1        unsigned int i,j;
1270   1        unsigned char m,n;
1271   1        first_conf=0;
1272   1      
1273   1        for(i=0; i<CHIPS_ON_BOARD; i++)
1274   1        {
1275   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
1276   2          Delay(1);
1277   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = RST_CANCLE;
1278   2          
1279   2          // TODO: 并行总线时钟选择
1280   2          // SW1021只支持19.44Mbit/s 的传输速率
1281   2          
1282   2          
1283   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时  + V5 期望
             - 0x02
1284   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)] = UPBUS_TIMER | 0x02;  // 上行总线定时
1285   2          
1286   2          XBYTE[SW1021_CHIP_ADDR(i) + SOMESET_REG(A_BUS_BASE)] = BLKBIP_BLOCK;  // BIP-2按块进行校验并计数
1287   2          
1288   2          XBYTE[SW1021_CHIP_ADDR(i) + RDI_RFI_CTRL_REG(A_BUS_BASE)] = MREI_AUTO | AISV_RDIEN | LOPV_RDIEN | LOMV_R
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 22  

             -DIEN | UNEQV_RDIEN | PLMV_RDIEN | RTIMV_RDIEN | RTIUV_RDIEN;
1289   2          
1290   2          // 上下话数据总线均选择偶校验
1291   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)] = UP_DELAY_2;
1292   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)] = UP_DELAY_2;   
1293   2          
1294   2          // 21个端口从A总线上下话, 使用 +- HDB3模式
1295   2          for(j=0; j<21; j++){
1296   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)] = A_UP_DOWN | RnEN;
1297   3            // 关闭线路环回和系统环回
1298   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_TEST_REG(j)] = 0x00;
1299   3            // TODO: 上下话交叉状态选择 ： 不交叉
1300   3            
1301   3            // TODO: TU通道LOP\AIS告警检测设置： EN_TUAIS  使能TU-AIS 中断
1302   3            //                             EN_TULOP  使能TU-LOP 中断
1303   3            //                             
1304   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_E1_ALARM_INTERRPUT_MASK_REG(j)] = E1AISE | E1LOCE; //??
1305   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(A_BUS_BASE,j)] = LOPE | AISE;  
1306   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(B_BUS_BASE,j)] = LOPE | AISE;  
1307   3            //TODO： 读清中断指示
1308   3            
1309   3            //TODO: 不启动随机码测试； 启动误码计数
1310   3            
1311   3            //TODO: 上话V5-TX2 设置 LP-REI
1312   3            XBYTE[SW1021_CHIP_ADDR(i) + TX_V5_REG(A_BUS_BASE,j)] = (0x02 << 1);
1313   3            
1314   3            //TODO： 上下话通道号编码
1315   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1316   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1317   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1318   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1319   3            
1320   3            
1321   3          }
1322   2          // TODO:上下话时钟数据同相
1323   2          XBYTE[SW1021_CHIP_ADDR(i) + E1_CTRL_REG] = TRZSEL | RRZSEL;
1324   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_IF_CLK_REG] = 0x00;
1325   2      
1326   2        }
1327   1        
1328   1        // 填充所有支路的J2字节（初始化清0）
1329   1        for(i=0;i<63;i++)            
1330   1        {
1331   2          m=i/21;
1332   2          n=i%21;
1333   2          for(j=0;j<16;j++)
1334   2          {
1335   3            if(j==0)
1336   3            { // A 
1337   4              writeTxJ2(m, j, slot[i],  0x80, 0);
1338   4              writeExpectJ2(m, j, slot[i],  0x80, 0);
1339   4              // B
1340   4              writeTxJ2(m, j, slot[i],  0x80, 1);
1341   4              writeExpectJ2(m, j, slot[i],  0x80, 1);           
1342   4            }
1343   3            else
1344   3            {
1345   4              // A 
1346   4              writeTxJ2(m, j, slot[i],  0x00, 0);
1347   4              writeExpectJ2(m, j, slot[i],  0x00, 0);
1348   4              // B
1349   4              writeTxJ2(m, j, slot[i],  0x00, 1);
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 23  

1350   4              writeExpectJ2(m, j, slot[i],  0x00, 1); 
1351   4            }
1352   3          }
1353   2        }
1354   1      
1355   1         IO8=1;
1356   1         IO9=1;
1357   1         IO10=1;
1358   1         IO11=1;
1359   1         IO12=1;
1360   1         WRHIO;
1361   1      
1362   1      }
1363          /*****************************************************************
1364          ** 函数名:checkSW1021Init
1365          ** 输　入: 无
1366          ** 输　出: 无
1367          ** 功能描述：检查SW1021初始化成功
1368          ** 全局变量：
1369          ** 调用模块：
1370          ** 作　者：caijun.Li
1371          ** 日　期：2016.3.18
1372          ** 修　改：
1373          ** 日　期：
1374          ** 版  本：1.0
1375          ****************************************************************/
1376          static int checkSW1021Init(void)
1377          {
1378   1        int ret = 0;
1379   1        int i,j;
1380   1        unsigned int reg;
1381   1        for(i=0;i<CHIPS_ON_BOARD;i++)
1382   1        {
1383   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)];
1384   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1385   3            ret = -1;
1386   3            break;
1387   3          }
1388   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)];
1389   2          if( (reg & (UPBUS_TIMER | 0x02)) != (UPBUS_TIMER | 0x02)){
1390   3            ret = -1;
1391   3            break;
1392   3          }
1393   2          
1394   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)];
1395   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1396   3            ret = -1;
1397   3            break;
1398   3          }
1399   2          
1400   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)];
1401   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1402   3            ret = -1;
1403   3            break;
1404   3          }
1405   2          
1406   2          for(j=0; j<21; j++){
1407   3            reg = XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)];
1408   3            if((reg & (A_UP_DOWN | RnEN)) != (A_UP_DOWN | RnEN)){
1409   4              ret = -1;
1410   4              goto quit;
1411   4            }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 24  

1412   3          }
1413   2      
1414   2        }
1415   1      quit:
1416   1        return ret;
1417   1      }
1418          
1419          /*****************************************************************
1420          ** 函数名:MAIN
1421          ** 输　入: 无
1422          ** 输　出: 无
1423          ** 功能描述：主函数
1424          ** 全局变量：g_QuarterFlag
1425          ** 调用模块：SelfConf(),GetData(),ProcHisData(),Debug();
1426          ** 作　者：caijun.Li
1427          ** 日　期：2016.3.18
1428          ** 修　改：
1429          ** 日　期：
1430          ** 版  本：1.0
1431          ****************************************************************/
1432          void main()
1433          {   
1434   1        unsigned char i;  
1435   1        int ret = 0;
1436   1         //Delay(50);
1437   1        
1438   1        SelfConf(); 
1439   1        ret = checkSW1021Init();
1440   1        if(ret != 0)
1441   1          InitioSw1021();
1442   1        
1443   1      
1444   1        
1445   1        // 使能外部中断2
1446   1        EX2 = 1;
1447   1        PX2 = 0;  // 低优先级
1448   1      
1449   1        while (1)
1450   1        {
1451   2          #ifdef SKIP_DEBUG_CHECK
                    #ifdef NEED_LP_RFI        
                        XBYTE[0x7fe5] = 1;
                    #else
                      //  XBYTE[0x7b74] = 1;
                        XBYTE[0x7b77] = 1;
                    #endif
                  #endif
1459   2          
1460   2          //ACT = ~ACT;
1461   2          //RED = ~RED;
1462   2          //YELLOW = ~YELLOW;
1463   2              
1464   2          
1465   2          ret = checkSW1021Init();
1466   2          if(ret != 0){ 
1467   3            SelfConf(); 
1468   3            InitioSw1021();
1469   3            ConfSet();  
1470   3          }
1471   2        
1472   2          GetData();
1473   2          ProcAlmData();  
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    06/15/2016 09:36:35 PAGE 25  

1474   2      
1475   2          if (g_QuarterFlag) 
1476   2          {
1477   3            UasQuarter();
1478   3            for(i=0;i<LINENUM;i++)
1479   3            {
1480   4              g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];
1481   4              g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];
1482   4              g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];
1483   4            }
1484   3            ProcHisData();  //将当前告警和性能数据存为历史数据//
1485   3            g_QuarterFlag=0;
1486   3          }
1487   2          
1488   2          Debug();
1489   2        }
1490   1      }
1491          
*** WARNING C294 IN LINE 1053 OF GF2488-01F1-E1-RST.C: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12475    ----
   CONSTANT SIZE    =    250    ----
   XDATA SIZE       =  22238     105
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
