C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE GF2488_01F1_E1_RST
OBJECT MODULE PLACED IN GF2488-01F1-E1-RST.OBJ
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE GF2488-01F1-E1-RST.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND T
                    -ABS(2)

line level    source

   1          /******************************************************************
   2          ** 文件名：STAND.C
   3          ** Copyright (c) 2002 烽火通信传输产品部BCT软件组
   4          ** 创建人：翁益晖
   5          ** 文件编号：
   6          ** 描　述：标准模版程序
   7          **         
   8          ** 日　期：2002.6.28
   9          ** 修改人：
  10          ** 日　期：
  11          ** 文件编号：
  12          ** 描　述：
  13          **
  14          **
  15          ** 编译器：Keil C51 V5.5 或 MCC68K V4.4
  16          ** 公共库：NewLib9.LIB for Mcs51
  17          **         或 NewLib1.LIB for Mc68302
  18          ** 版  本：1.0
  19          ********************************************************************/
  20          #define UASNUM    63        //要计算误码的线路数63//
  21          #define LINENUM   64        /*告警线路数为64*/
  22          #define ALMNUM      759     /*总共63*ALMTYPENUM+3=759个告警*/
  23          #define PMNUM   441         /*总共63*PMTYPENUM个性能*/
  24          #define ALMTYPENUM      15      /*15种告警类型*/
  25          #define PMTYPENUM       7       /*7种性能类型*/
  26          #define CONFLEN   2560  /*配置数据长度为2560*/
  27          #define STATELEN  338   /*状态数据长度为338*/
  28          #define BOARDCODE 0x96  /*盘代码*/
  29          #define WGS21891A 0xB000
  30          
  31          #define SW1021  0xB000    //TODO：confirm
  32          
  33          #define SW1021_CHIP_ADDR(num)  (SW1021 + 0x1000*(num))
  34          //#define SW1021_CHIP_ADDR(num)  (0xD000)
  35          #define CHIPS_ON_BOARD          3
  36          
  37          
  38          
  39          #include "commvar9.h"
  40          #include "uasE63.h"
  41          
  42          #include "sw1021.h"
  43          
  44          char code SysName[]="GF2488-01F";
  45          char code BoardName[]="E1-63A";
  46          char code BoardSn[]="WKE2.170.609R1B";
  47          char code SoftVer[]="R170609R1B/01F    ";
  48          
  49          char code PcbSn[]="WKE7.822.828R1B";
  50          char code PcbTime[]="2004 05 02";
  51          
  52          char code BoardSoftVer[]="RP0100            ";
  53          
  54          char code SoftDate[]=__DATE__;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 2   

  55          char code SoftTime[]=__TIME__;
  56          
  57          extern int sprintf(char *, const char *, ...);
  58          
  59          #define RSTB IO0
  60          #define TUALMO IO2
  61          #define TUXAB IO5 //TUXAB为主备交叉时钟盘XCU有效指示信号,主用XCU有效时TUXAB=0,备用XCU有效TUXAB=1
  62          #define WP IO6     //E1-63A盘在正常槽位时WP=1,在保护槽位时WP=0//
  63          #define TUSWTI IO7 //本盘almnumber大于一定值时,TUALMO=1,XCU盘收到TUALMO=1时,产生TUSWTI=0//
  64          #define P2V5 IO8
  65          #define P5VI1 IO9
  66          #define P5VI2 IO10
  67          #define DZBI1 IO11
  68          #define DZBI2 IO12
  69          extern unsigned char g_AllClrFlag;
  70          extern unsigned char g_LampEn;
  71          unsigned int ulEsLimit,ulSesLimit;
  72          //unsigned int WGS21891,wgs21891reg0[4],wgs21891reg1[4];
  73          unsigned int sw1021Chip;
  74          unsigned int N1000[63],BIP[63],BIP_2_1S[63],BIP_2_1000S[63];
  75          unsigned char actnumber,almnumber,first_conf;
  76          /*
  77          code unsigned char slot[64]={1,22,43,4,25,46,7,28,49,10,31,52,13,34,55,16,37,58,19,40,61,2,23,44,5,26,
  78              47,8,29,50,11,32,53,14,35,56,17,38,59,20,41,62,3,24,45,6,27,48,9,30,51,
  79              12,33,54,15,36,57,18,39,60,21,42,63,0};
  80              */
  81          
  82          code unsigned char slot[64]={0x00,0x20,0x40,0x01,0x21,0x41,0x02,
  83                               0x22,0x42,0x03,0x23,0x43,0x04,0x24,
  84                               0x44,0x05,0x25,0x45,0x06,0x26,0x46,
  85          
  86                               0x07,0x27,0x47,0x08,0x28,0x48,0x09,
  87                               0x29,0x49,0x0a,0x2a,0x4a,0x0b,0x2b,
  88                               0x4b,0x0c,0x2c,0x4c,0x0d,0x2d,0x4d,
  89          
  90                               0x0e,0x2e,0x4e,0x0f,0x2f,0x4f,0x10,
  91                               0x30,0x50,0x11,0x31,0x51,0x12,0x32,
  92                               0x52,0x13,0x33,0x53,0x14,0x34,0x54,
  93                               0
  94                          };            
  95          
  96              
  97          static void writeTxJ2(char chip, char witchJ2, char Slot, char j2, char busB)
  98          {
  99   1        int copOk = 0;
 100   1        int busBase = A_BUS_BASE;
 101   1        int i = 5;
 102   1        if(busB)
 103   1          busBase = B_BUS_BASE;
 104   1        // write  Tx J2 data
 105   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_DATA_REG(busBase)] = j2;
 106   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_WHICH_REG(busBase)] = witchJ2;
 107   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_SLOT_REG(busBase)] = RW_SEL | Slot;
 108   1        while(!copOk){
 109   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_TX_RAM_STATUS_REG(busBase)] & 0x01;
 110   2          i--;
 111   2          if(i == 0)
 112   2            break;
 113   2          //Delay(1);
 114   2        }
 115   1      }
 116          
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 3   

 117          static void writeExpectJ2(char chip, char witchJ2, char Slot, char j2, char busB)
 118          {
 119   1        int copOk = 0;
 120   1        int busBase = A_BUS_BASE;
 121   1        int i = 5;
 122   1        if(busB) 
 123   1          busBase = B_BUS_BASE;
 124   1        // write  Tx J2 data
 125   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_DATA_REG(busBase)] = j2;
 126   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_J2TYPE_CTRL_REG(busBase)] = EXPECT_J2 |  witchJ2;
 127   1        XBYTE[SW1021_CHIP_ADDR(chip) + J2_RX_CTRL_REG(busBase)] = RW_SEL | Slot;
 128   1        while(!copOk){
 129   2          copOk = XBYTE[SW1021_CHIP_ADDR(chip) + J2_RAM_STATUS_REG(busBase)] & READY;
 130   2          i--;
 131   2          if(i == 0)
 132   2            break;
 133   2          //Delay(1);
 134   2        }
 135   1      }
 136          
 137          /*****************************************************************
 138          ** 函数名:GETDATA
 139          ** 输　入: 无
 140          ** 输　出: 无
 141          ** 功能描述：采集单盘告警和性能
 142          ** 全局变量：无
 143          ** 调用模块：无
 144          ** 作　者：翁益晖
 145          ** 日　期：2002.5.25
 146          ** 修　改：
 147          ** 日　期：
 148          ** 版  本：1.0
 149          ****************************************************************/
 150          void GetData()          
 151          {
 152   1        unsigned char i,m,n,mi,ni,tmp,ADCLK,PPILOS,TULOP,LPSLM,LPTIM,LPTIU,LPRDI,LPRFI,LPUNEQ,TUAIS,PPIAIS,
 153   1        LOOP,LOOPL,tv5;
 154   1        unsigned int  LPFEBE,HDB3;
 155   1        actnumber=0;
 156   1        almnumber=0;
 157   1        sw1021Chip = SW1021;
 158   1        for(i=0;i<(LINENUM-1);i++)
 159   1        {
 160   2          
 161   2          if(g_ucState[78+i]==0)
 162   2          {
 163   3            g_ucLineMask[i]=1;
 164   3            // ADCLK 告警 (A 路下行时钟告警 )
 165   3            ADCLK=XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC; 
 166   3      
 167   3          }
 168   2          else   
 169   2          {
 170   3            m=i/21;
 171   3            n=i%21;
 172   3            mi=i/8;
 173   3            ni=i%8;
 174   3            
 175   3            sw1021Chip = SW1021_CHIP_ADDR(m);
 176   3            
 177   3            if(TULOP||TUAIS)
 178   3              g_ucLofFlag[i]=1;      //有TULOP,TUAIS,PPILOS告警之一时上报UAS
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 4   

 179   3            else
 180   3              g_ucLofFlag[i]=0;
 181   3            
 182   3            actnumber=actnumber+g_ucConfData[64+i];
 183   3            
 184   3            ADCLK = XBYTE[sw1021Chip+E1_IF_STATUS_REG] & ADLOC;
 185   3            tmp = XBYTE[sw1021Chip+PORT_E1_ALARM_REG(n)];
 186   3            PPIAIS = tmp & E1AIS;
 187   3            PPILOS = tmp & E1LOS;
 188   3          
 189   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG2(A_BUS_BASE, n)];
 190   3            TULOP = tmp & LOPI;
 191   3            TUAIS = tmp & AISI;
 192   3            LPSLM = tmp & PLMI;
 193   3            LPTIM = tmp & RTIMI;
 194   3            LPTIU = tmp & RTIUI;
 195   3            LPRDI = tmp & RDII;
 196   3            LPRFI = tmp & RFII;
 197   3            LPUNEQ = tmp & UNEQI;
 198   3            
 199   3            
 200   3            /*
 201   3            tmp = XBYTE[sw1021Chip+TU12_J2_STATUS_REG(A_BUS_BASE, n)];
 202   3            TULOP = tmp & LOPV;
 203   3            TUAIS = tmp & AISV;
 204   3            LPSLM = tmp & PLMV;
 205   3            LPTIM = tmp & RTIMV;
 206   3            LPTIU = tmp & RTIUV;
 207   3            LPRDI = tmp & RDIV;
 208   3            LPRFI = tmp & RFIV;
 209   3            LPUNEQ = tmp & UNEQV;
 210   3            */
 211   3            
 212   3            g_liError1s[i].ulDatlong+=XBYTE[sw1021Chip+BIPERR_COUNTER_REG(A_BUS_BASE, n)];   // BIP错误计数值
 213   3            LPFEBE = XBYTE[sw1021Chip+REI_COUNTER_REG(A_BUS_BASE, n)]; //REI(FEBE)计数值
 214   3            
 215   3            tmp = XBYTE[sw1021Chip + PORT_TEST_REG(n)];
 216   3                  
 217   3            LOOPL =  tmp & E1LBK;
 218   3            LOOP =   tmp & LnLBK;
 219   3            
 220   3            if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 221   3            {
 222   4              g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;
 223   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)].ucState=1;           
 224   4              else                                              //E1输入口有信号时/// 
 225   4              {
 226   5                if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==1)  //如果还存在PPILOS告警//
 227   5                if(WP==1)                        //非保护盘位时//
 228   5                {
 229   6                  // 向第i通道上话方向插短时间的伪随机码
 230   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] = PRBSEN | PRBST;
 231   6                  g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS//
 232   6          
 233   6                  Delay(10);
 234   6                  XBYTE[sw1021Chip + PORT_TEST_REG(n)] = 0x00; //停插伪随机码
 235   6      
 236   6                }
 237   5                else g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;//不告PPILOS////保护盘位时//
 238   5              }
 239   4      
 240   4            }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 5   

 241   3            else
 242   3            {
 243   4              g_stuAlm[i*(ALMTYPENUM-3)].ucState=0;
 244   4              if(PPILOS) g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;               
 245   4              else  g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=1;
 246   4            }              
 247   3            //if(PPIAIS) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;               
 248   3            //else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 249   3            if(TULOP) g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=1;              
 250   3            else g_stuAlm[i*(ALMTYPENUM-3)+1].ucState=0;  
 251   3            if(TUAIS) g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=1;              
 252   3            else g_stuAlm[i*(ALMTYPENUM-3)+5].ucState=0;
 253   3            if(TULOP||TUAIS)
 254   3            {
 255   4              g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 256   4              g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 257   4              g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 258   4              //g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0; 
 259   4              g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0; 
 260   4            }
 261   3            else
 262   3            {
 263   4              if(LPSLM) g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=1;              
 264   4              else g_stuAlm[i*(ALMTYPENUM-3)+2].ucState=0;
 265   4              if(LPRDI) g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=1;              
 266   4              else g_stuAlm[i*(ALMTYPENUM-3)+3].ucState=0;
 267   4              if(LPUNEQ) g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=1;               
 268   4              else g_stuAlm[i*(ALMTYPENUM-3)+4].ucState=0;
 269   4      
 270   4              // if(LPRFI) g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=1;               
 271   4              // else g_stuAlm[i*(ALMTYPENUM-3)+6].ucState=0;       
 272   4              if(LPTIM) g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=1;              
 273   4              else g_stuAlm[i*(ALMTYPENUM-3)+9].ucState=0;  
 274   4            }
 275   3            if(LOOPL) g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=1;               
 276   3            else g_stuAlm[i*(ALMTYPENUM-3)+10].ucState=0;
 277   3            if(LOOP) g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=1;              
 278   3            else g_stuAlm[i*(ALMTYPENUM-3)+11].ucState=0;
 279   3            if(g_stuPm[i*PMTYPENUM+3].Value.usint>=(0xffff-LPFEBE)) g_stuPm[i*PMTYPENUM+3].Value.usint=0xffff;     
             -  
 280   3            else g_stuPm[i*PMTYPENUM+3].Value.usint+=LPFEBE;   //REI(FEBE)性能值                    
 281   3            if(g_stuAlm[i*(ALMTYPENUM-3)].ucState==0)                               //无PPI_LOS告警时
 282   3            {
 283   4               //HDB3编码违例计数值
 284   4              HDB3 = XBYTE[sw1021Chip + HDB3_CV_REG(n)];
 285   4              
 286   4              if(g_stuPm[i*PMTYPENUM+4].Value.usint>=(0xffff-HDB3)) g_stuPm[i*PMTYPENUM+4].Value.usint=0xffff;     
 287   4              else g_stuPm[i*PMTYPENUM+4].Value.usint+=HDB3;      // HDB3性能值         //g_stuPm[i][4]=HDB3CV
 288   4            }           
 289   3      
 290   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState)
 291   3            almnumber=almnumber+1;
 292   3            
 293   3            tv5 = XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)];
 294   3            if(g_stuAlm[i*(ALMTYPENUM-3)+1].ucState||g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3
             -)+4].ucState)
 295   3            { //如果TUAIS,TULOP,LPUNEQ之一为"1" 则向上插VC12=AIS,LPRDI,向下插AIS
 296   4                if((tv5 & RDI_CNF) != RDI_CNF)
 297   4                  XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 | RDI_CNF;
 298   4            }
 299   3            else
 300   3            {
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 6   

 301   4              if((tv5 & RDI_CNF) == RDI_CNF)
 302   4                XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = tv5 & (~RDI_CNF);
 303   4            }
 304   3          }
 305   2        }
 306   1        
 307   1        for(i=0;i<(LINENUM-1);i++)
 308   1        {
 309   2          m=i/21;
 310   2          n=i%21;
 311   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 312   2          // 获取N2 和 K4 值
 313   2          //TODO: get N2
 314   2          //g_ucState[204+2*i]=XBYTE[WGS21891+0x0100+0x10*n+0x0C]; 
 315   2          g_ucState[205+2*i]=XBYTE[sw1021Chip + TX_K4_REG(A_BUS_BASE,n)];
 316   2          
 317   2          
 318   2          mi=i/8;
 319   2          ni=i%8;
 320   2          if((g_ucConfData[200+mi]&(0x01<<ni))==0)
 321   2            g_ucState[330+mi]&=(~(0x01<<ni));
 322   2      
 323   2          else
 324   2            g_ucState[330+mi]|=(0x01<<ni);    
 325   2      
 326   2          //  tv5=XBYTE[WGS21891+0x0100+0x10*n+0x00];
 327   2      
 328   2        }
 329   1      
 330   1         
 331   1      
 332   1        if(TUXAB) g_ucState[77]=0;
 333   1        else g_ucState[77]=1;
 334   1                           
 335   1             
 336   1        if((WP==0) &&(TUSWTI==0))  //保护盘位时,如果没有倒换ACT灯慢闪//     
 337   1        {
 338   2          g_ucState[76]=0;
 339   2          g_LampEn=0;        
 340   2          if(g_stuSysClock.ucSecond%2==0) ACT=ON;
 341   2          else ACT=OFF;
 342   2          for(i=0;i<(LINENUM-1);i++)
 343   2          {
 344   3            g_ucLineMask[i]=1;
 345   3            g_ucState[141+i]=1;
 346   3          }
 347   2        }
 348   1        else if(g_ucState[76]==0)
 349   1        {                           
 350   2          for(i=0;i<(LINENUM-1);i++)
 351   2          {
 352   3            if((g_ucConfData[64+i]==0)||(g_ucConfData[137+i]==01))
 353   3            {    
 354   4              g_ucLineMask[i]=1;
 355   4              g_ucState[141+i]=1;  
 356   4            }   
 357   3            else
 358   3            {
 359   4              g_ucLineMask[i]=0;  
 360   4              g_ucState[141+i]=0;
 361   4            }
 362   3          }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 7   

 363   2          g_ucState[76]=1;     
 364   2          g_LampEn=1;
 365   2          WROUTPORT;           
 366   2        }
 367   1             
 368   1        UasClear();
 369   1      
 370   1      
 371   1        if(g_AllClrFlag)                //清性能
 372   1        {   
 373   2          g_bClearUas=1; 
 374   2          g_AllClrFlag=0;
 375   2        }
 376   1      
 377   1        if(g_SecondFlag)                   //秒标识，1：进入新的一秒
 378   1        {
 379   2          CalUas(ulSesLmt);           //uas计算        
 380   2      
 381   2          for(i=0; i<(LINENUM-1); i++)
 382   2          {
 383   3            g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];         //bbe_lp性能的采集
 384   3            g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];        //es_lp性能的采集
 385   3            g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];       //ses_lp性能的采集
 386   3            if(g_usiEs[i]>=ulEsLimit) 
 387   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=1;    //curalm[i][8]=es_limit
 388   3            else 
 389   3              g_stuAlm[i*(ALMTYPENUM-3)+7].ucState=0;
 390   3            // if(g_usiSes[i]>=ulSesLimit) g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;    //curalm[i][9]=ses_limit
 391   3            // else g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 392   3            g_stuPm[i*PMTYPENUM+5].Value.usint=g_usiUas[i];             //UAS_LP性能的采集
 393   3            g_stuPm[i*PMTYPENUM+6].Value.usint=g_usiCses[i];            //cses_lp性能的采集
 394   3      
 395   3      
 396   3            /******************************************************************************/
 397   3            if(g_stuAlm[i*(ALMTYPENUM-3)+5].ucState||g_stuAlm[i*(ALMTYPENUM-3)+1].ucState)
 398   3            {
 399   4              g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 400   4              BIP[i]=0;
 401   4            }
 402   3            else
 403   3            {
 404   4              BIP_2_1S[i]=BIP[i];
 405   4              BIP_2_1000S[i]+=BIP[i];  
 406   4              BIP[i]=0;
 407   4              switch(g_ucConfData[129])
 408   4              {
 409   5                case 0x04:
 410   5                if(BIP_2_1S[i]>=217) 
 411   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 412   5                else if(BIP_2_1S[i]<=23) 
 413   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 414   5                break;
 415   5      
 416   5                case 0x05:
 417   5                if(BIP_2_1S[i]>=22) 
 418   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 419   5                else if(BIP_2_1S[i]<=3) 
 420   5                  g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 421   5                break;
 422   5      
 423   5                case 0x06:
 424   5      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 8   

 425   5      
 426   5                if((N1000[i]>=10)&&(N1000[i]<100))
 427   5                {
 428   6                  if(BIP_2_1000S[i]>=22) 
 429   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 430   6                  else if(BIP_2_1000S[i]<=3) 
 431   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 432   6                  N1000[i]=0;
 433   6                  BIP_2_1000S[i]=0;
 434   6                }
 435   5                else N1000[i]++;
 436   5      
 437   5                break;
 438   5      
 439   5                case 0x07:
 440   5      
 441   5      
 442   5                if((N1000[i]>=100)&&(N1000[i]<1000))
 443   5                {
 444   6                  if(BIP_2_1000S[i]>=22) 
 445   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 446   6                  else if(BIP_2_1000S[i]<=3) 
 447   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 448   6                  N1000[i]=0;
 449   6                  BIP_2_1000S[i]=0;
 450   6                }
 451   5                else N1000[i]++;
 452   5                break;
 453   5      
 454   5                case 0x08:
 455   5      
 456   5      
 457   5                if(N1000[i]>=1000)
 458   5                {
 459   6                  if(BIP_2_1000S[i]>=22) 
 460   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=1;
 461   6                  else if(BIP_2_1000S[i]<=3) 
 462   6                    g_stuAlm[i*(ALMTYPENUM-3)+8].ucState=0;
 463   6                  N1000[i]=0;
 464   6                  BIP_2_1000S[i]=0;
 465   6                }
 466   5                else 
 467   5                  N1000[i]++;
 468   5                break;
 469   5              }
 470   4            }
 471   3      
 472   3          /********************************************************************************/
 473   3      
 474   3          }
 475   2      
 476   2          g_SecondFlag=0;      //秒标识清?
 477   2      
 478   2        }     
 479   1      
 480   1        //IO8=1;
 481   1        // WRHIO;
 482   1        //RDHIO;    
 483   1        //IO9=1;
 484   1        // WRHIO;
 485   1        //RDHIO;
 486   1        //IO10=1;
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 9   

 487   1        // WRHIO;
 488   1        //RDHIO;
 489   1        //IO11=1;
 490   1        // WRHIO;
 491   1        //RDHIO;
 492   1        //IO12=1;
 493   1        // WRHIO;
 494   1        RDHIO;
 495   1      
 496   1         
 497   1             
 498   1        if(ADCLK||(P2V5==0)||(first_conf==0)) 
 499   1          TUALMO=1; //如果工作支路中全部有告警或2.5V//
 500   1        else 
 501   1          TUALMO=0; //电源有告警或下配置前TUALMO=1,否则TUALMO=0//
 502   1        if((P5VI1==0)&&(DZBI1==0)) 
 503   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=1;
 504   1        else    
 505   1          g_stuAlm[63*(ALMTYPENUM-3)+1].ucState=0;               
 506   1        if((P5VI2==0)&&(DZBI2==0)) 
 507   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=1;
 508   1        else    
 509   1          g_stuAlm[63*(ALMTYPENUM-3)+2].ucState=0;       
 510   1        if(P2V5==0) 
 511   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=1;
 512   1        else    
 513   1          g_stuAlm[63*(ALMTYPENUM-3)+0].ucState=0;                     
 514   1       
 515   1      }
 516          
 517          /*****************************************************************
 518          ** 函数名:USERFUN
 519          ** 输　入: 无
 520          ** 输　出: 无
 521          ** 功能描述：用户实时处理函数，10毫秒被调用一次
 522          ** 全局变量：无
 523          ** 调用模块：无
 524          ** 作　者：翁益晖
 525          ** 日　期：2002.5.25
 526          ** 修　改：
 527          ** 日　期：
 528          ** 版  本：1.0
 529          ****************************************************************/
 530          
 531          void UserFunc() using 1
 532          {
 533   1        return;
 534   1      }
 535          
 536          /*****************************************************************
 537          ** 函数名:CONF_SET
 538          ** 输　入: 无
 539          ** 输　出: 无
 540          ** 功能描述：单盘配置
 541          ** 全局变量：无
 542          ** 调用模块：无
 543          ** 作　者：caijun.Li
 544          ** 日　期：2016.3.19
 545          ** 修　改：
 546          ** 日　期：
 547          ** 版  本：1.0
 548          ****************************************************************/
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 10  

 549          void ConfSet(void)
 550          {
 551   1          /*Process ALMMASK*/
 552   1          /*Process PMMASK*/
 553   1        unsigned char i,j,ilong,m,n,temp;
 554   1      
 555   1        g_ucState[69]=g_ucConfData[5];
 556   1        g_ucState[70]=g_ucConfData[6];
 557   1        g_ucState[71]=g_ucConfData[7];
 558   1        g_ucState[72]=g_ucConfData[8];
 559   1        g_ucState[73]=g_ucConfData[9];
 560   1        g_ucState[74]=g_ucConfData[10];
 561   1        g_ucState[75]=g_ucConfData[11];
 562   1        for(i=0;i<(LINENUM-1);i++){
 563   2          m=i/21;
 564   2          n=i%21;
 565   2          sw1021Chip = SW1021_CHIP_ADDR(m);
 566   2        
 567   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 568   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(A_BUS_BASE,n)] = slot[i];  
 569   2          XBYTE[sw1021Chip + RXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 570   2          XBYTE[sw1021Chip + TXTU12_SLOT_REG(B_BUS_BASE,n)] = slot[i];  
 571   2      
 572   2          if(g_ucConfData[64+i]==0){  // 支路关闭
 573   3            // 上下话强发AIS
 574   3            //XBYTE[sw1021Chip + TX_CTRL_REG(B_BUS_BASE,n)] = AIS_EN; 
 575   3            temp = XBYTE[sw1021Chip + PORT_CFG_REG(n)];
 576   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = temp | TAISEN | RAISEN; 
 577   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = 0x00;
 578   3                  
 579   3            g_ucState[78+i]=0;     
 580   3            g_ucLineMask[i]=1;
 581   3            g_ucState[141+i]=1;
 582   3          }else{  // 支路打开
 583   3            XBYTE[sw1021Chip + PORT_CFG_REG(n)] = A_UP_DOWN | RnEN;
 584   3            XBYTE[sw1021Chip + TX_V5_REG(A_BUS_BASE,n)] = REI_CNF;
 585   3            if(g_ucState[78+i]==0)//刚打开支路开关时插伪随机码
 586   3            {
 587   4              //TODO: 启动误码计数器
 588   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] = PRBSEN | PRBST;
 589   4              Delay(5);
 590   4              XBYTE[sw1021Chip + PORT_TEST_REG(n)] = 0x00;
 591   4              g_ucState[78+i]=1;
 592   4              g_ucLineMask[i]=0; 
 593   4              g_ucState[141+i]=0;
 594   4            }         
 595   3          }
 596   2          XBYTE[sw1021Chip + TX_K4_REG(A_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 597   2          XBYTE[sw1021Chip + TX_K4_REG(B_BUS_BASE,n)]= g_ucConfData[263+4*i+2];               // K4 发 
 598   2          // TODO: N2 发
 599   2          //XBYTE[WGS21891+0x0100+0x10*n+0x01]=g_ucConfData[263+4*i];                 // N2 发
 600   2        
 601   2          // J2 发 和 期望收
 602   2          for(j=0;j<16;j++)
 603   2          {
 604   3            if(j==0) temp=0x80;
 605   3            else temp=0;
 606   3            
 607   3            // A 
 608   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 0);
 609   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 0);
 610   3            // B
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 11  

 611   3            writeTxJ2(m, j, slot[i],  temp|g_ucConfData[515+2*i*16+j], 1);
 612   3            writeExpectJ2(m, j, slot[i],  temp|g_ucConfData[515+16+2*i*16+j], 1);
 613   3          }
 614   2          
 615   2          if(g_ucConfData[137+i]==0)   //confdata[137+i]==0不屏蔽支路i告警/否则屏蔽支路i告警//
 616   2          {
 617   3            g_ucLineMask[i]=0;
 618   3            g_ucState[141+i]=0;
 619   3          }
 620   2          else
 621   2          {
 622   3            g_ucLineMask[i]=1;
 623   3            g_ucState[141+i]=1;
 624   3          }
 625   2        //if(g_ucConfData[200+i]==0)     //confdata[200+i]==1支路i装载/否则不装载//
 626   2        //XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x00;
 627   2        // else  XBYTE[WGS21891+0x0100+0x10*n+0x00]=0x04;
 628   2      
 629   2        }
 630   1      
 631   1      
 632   1      
 633   1        for(j=0;j<ALMTYPENUM;j++) 
 634   1        {
 635   2           
 636   2           for(ilong=29;ilong<(29+ALMTYPENUM);ilong++)
 637   2           {    
 638   3              if(g_ucConfData[ilong]==g_ucAlmCode[j])   //从网管设告警屏蔽//
 639   3              {
 640   4               g_ucAlmMask[j]=1;                              
 641   4               break;     
 642   4              }
 643   3              else
 644   3              g_ucAlmMask[j]=0;
 645   3      
 646   3           }
 647   2        }      
 648   1                          
 649   1        for(j=0;j<PMTYPENUM;j++)  
 650   1        {
 651   2      
 652   2          for(ilong=54;ilong<(54+PMTYPENUM);ilong++)
 653   2          {   
 654   3            if(g_ucConfData[ilong]==g_ucPmCode[j])   //从网管设性能屏蔽//
 655   3            {
 656   4              g_ucPmMask[j]=1;                              
 657   4              break;    
 658   4            }
 659   3            else
 660   3              g_ucPmMask[j]=0;
 661   3          }
 662   2        }        
 663   1      
 664   1        ulEsLimit=256*g_ucConfData[131]+g_ucConfData[132];    //从网管设ulEsLimit门限//
 665   1        ulSesLimit=256*g_ucConfData[134]+g_ucConfData[135];   //从网管设ulSesLimit门限//
 666   1      
 667   1        //if((g_ucConfData[136]==0)&&TUALMO&&WP) TUALMO=0;  //IO2=TUALMO  confdata[108]=盘保护模式不保护
 668   1      
 669   1      
 670   1        // g_ucConfChange=0;                          
 671   1              
 672   1      
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 12  

 673   1        if(first_conf==0) first_conf=1; 
 674   1      }
 675          
 676          
 677          /*****************************************************************
 678          ** 函数名:UserHdlc
 679          ** 输　入: 无
 680          ** 输　出: 无
 681          ** 功能描述：单盘特殊命令处理
 682          ** 全局变量：无
 683          ** 调用模块：无
 684          ** 作　者：caijun.Li
 685          ** 日　期：2016.3.19
 686          ** 修　改：
 687          ** 日　期：
 688          ** 版  本：1.0
 689          ****************************************************************/
 690          void UserHdlc(void)
 691          {
 692   1        unsigned char i,m,n,temp;
 693   1        unsigned int addr;
 694   1      
 695   1        if (g_ucHdlcBuf[CMD_TYPE]==COMM_CATA)
 696   1        {
 697   2          if (g_ucHdlcBuf[CMD_CODE]==RTRV_OCONF)
 698   2          {
 699   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;
 700   3          }
 701   2          else if (g_ucHdlcBuf[CMD_CODE]==SET_OCONF)
 702   2          {
 703   3            g_ucHdlcBuf[CHARACTER1]=CMD_RIGHT;                                               
 704   3          }
 705   2        }
 706   1      
 707   1      
 708   1        switch(g_ucHdlcBuf[5])
 709   1        {
 710   2          case 0x00:    /*SET_LOOP*/
 711   2            if(g_ucHdlcBuf[6]==0x34)
 712   2            { // 设备环回
 713   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 714   3                g_ucHdlcBuf[10]=0x80; 
 715   3              else                
 716   3                for(i=0;i<(g_usRxDataLen);i++)
 717   3                {
 718   4                  temp=g_ucHdlcBuf[14+i]-1;
 719   4                  m=temp/21;
 720   4                  n=temp%21;
 721   4      
 722   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 723   4                  if(g_ucHdlcBuf[7]==0x01){
 724   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= LnLBK;
 725   5                  }else{
 726   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~LnLBK);
 727   5                  }
 728   4                  g_ucHdlcBuf[10]=0x00;
 729   4                }
 730   3            }
 731   2            else if(g_ucHdlcBuf[6]==0x33)       /*SET_LOOPL*/
 732   2            { // 线路环回 
 733   3              if(((g_usRxDataLen)==0)||((g_usRxDataLen)>63)) 
 734   3                g_ucHdlcBuf[10]=0x80; 
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 13  

 735   3              else                  
 736   3                for(i=0;i<(g_usRxDataLen);i++)
 737   3                {
 738   4                  temp=g_ucHdlcBuf[14+i]-1;
 739   4                  m=temp/21;
 740   4                  n=temp%21;
 741   4                  
 742   4                  sw1021Chip = SW1021_CHIP_ADDR(m);
 743   4                  if(g_ucHdlcBuf[7]==0x01){
 744   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] |= E1LBK;
 745   5                  }else{
 746   5                    XBYTE[sw1021Chip + PORT_TEST_REG(n)] &= (~E1LBK);
 747   5                  }
 748   4                  g_ucHdlcBuf[10]=0x00;
 749   4                }
 750   3            }
 751   2      
 752   2            break;
 753   2      
 754   2          case 0x77:                /**透明帧命令**/
 755   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];  // commbuf[14]，commbuf[15]所存放 的 地址
 756   2            g_ucHdlcBuf[10]=0x00;
 757   2            g_ucHdlcBuf[11]=0x00;
 758   2            g_ucHdlcBuf[12]=0x00;
 759   2            g_ucHdlcBuf[13]=0x11;
 760   2            //读16个字节//  addr 地址开始读取16个字节数据//
 761   2            for(i=0;i<16;i++) 
 762   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; 
 763   2            g_ucHdlcBuf[30]=P1;
 764   2            break;                   
 765   2          
 766   2          case 0x88:
 767   2            addr=256*g_ucHdlcBuf[14]+g_ucHdlcBuf[15];
 768   2            XBYTE[addr]=g_ucHdlcBuf[16];       //将commbuf[16]存放的数据送入commbuf[14]，//
 769   2            g_ucHdlcBuf[10]=0x00;              //commbuf[15]所存放的WGS21891的地址单元中//
 770   2            g_ucHdlcBuf[11]=0x00;
 771   2            g_ucHdlcBuf[12]=0x00;
 772   2            g_ucHdlcBuf[13]=0x10;              //读16个字节//
 773   2            for(i=0;i<16;i++) 
 774   2              g_ucHdlcBuf[14+i]=XBYTE[addr+i]; //从commbuf[14]，commbuf[15]的地址开始读取16个字节数据//
 775   2            break;
 776   2      /*
 777   2          case 0X99:
 778   2            while(1)
 779   2            {;} 
 780   2            if((g_usRxDataLen==0)||(g_usRxDataLen>63)) 
 781   2              g_ucHdlcBuf[10]=0x80; 
 782   2            else                
 783   2              for(i=0;i<(g_usRxDataLen);i++)
 784   2              {
 785   2                temp=g_ucHdlcBuf[14+i]-1;
 786   2                m=temp/21;
 787   2                n=temp%21;
 788   2                sw1021Chip = SW1021_CHIP_ADDR(m);
 789   2                
 790   2                g_ucHdlcBuf[17]=XBYTE[WGS21891+0x04];
 791   2                g_ucHdlcBuf[18]=0xbb;
 792   2                if(g_ucHdlcBuf[7]==0x01)
 793   2                {
 794   2                  if(n<8)
 795   2                  {XBYTE[WGS21891+0x04]|=(0x01<<n);g_ucHdlcBuf[18]=0xff;}
 796   2                  else
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 14  

 797   2                  XBYTE[WGS21891+0x05]|=(0x01<<(n-8));
 798   2                }
 799   2                else
 800   2                {
 801   2                  if(n<8)
 802   2                  XBYTE[WGS21891+0x04]&=(~(0x01<<n));
 803   2                  else
 804   2                  XBYTE[WGS21891+0x05]&=(~(0x01<<(n-8)));
 805   2                }
 806   2                
 807   2              }
 808   2            g_ucHdlcBuf[10]=0x00;
 809   2            g_ucHdlcBuf[13]=6;
 810   2            g_ucHdlcBuf[14]=0xaa;
 811   2            g_ucHdlcBuf[15]=m;
 812   2            g_ucHdlcBuf[16]=n;
 813   2            //g_ucHdlcBuf[19]=XBYTE[WGS21891+0x04];
 814   2            break;
 815   2            */
 816   2      
 817   2        }
 818   1      
 819   1      }
 820          
 821          /*****************************************************************
 822          ** 函数名:SELF_CONF
 823          ** 输　入: 无
 824          ** 输　出: 无
 825          ** 功能描述：单盘上电默认配置
 826          ** 全局变量：g_ucConfData[]
 827          ** 调用模块：无
 828          ** 作　者：翁益晖
 829          ** 日　期：2002.5.25
 830          ** 修　改：
 831          ** 日　期：
 832          ** 版  本：1.0
 833          ** 注  意：所有告警和性能的初始化需安线路号顺序
 834          ****************************************************************/
 835          void SelfConf()
 836          {
 837   1      
 838   1        unsigned int i,j;
 839   1        char ctt[18];
 840   1        unsigned char ucii;
 841   1        //  first_conf=0;
 842   1        g_ucConfData[22]=BOARDCODE;/*BDINF5*/
 843   1        g_ucConfData[0]=0xfe;
 844   1      
 845   1      
 846   1        sprintf(ctt,BoardSn);
 847   1        for(ucii=0;ucii<15;ucii++) g_ucState[ucii]=ctt[ucii];  /*盘号*/
 848   1      
 849   1        sprintf(ctt,PcbSn);   
 850   1        for(ucii=0;ucii<15;ucii++) g_ucState[15+ucii]=ctt[ucii]; /*板号*/
 851   1      
 852   1        sprintf(ctt,PcbTime);   
 853   1        for(ucii=0;ucii<10;ucii++) g_ucState[30+ucii]=ctt[ucii]; /*制板时间*/
 854   1      
 855   1        for(ucii=0;ucii<18;ucii++) ctt[ucii]=0;    /*版本号buf清零*/
 856   1        //sprintf(ctt,"R170609R1B/01F    "); 
 857   1        //for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
 858   1        sprintf(ctt,BoardSoftVer); 
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 15  

 859   1        for(ucii=0;ucii<18;ucii++) g_ucState[40+ucii]=ctt[ucii];
 860   1        sprintf(ctt,__DATE__);   
 861   1        for(ucii=0;ucii<11;ucii++) g_ucState[58+ucii]=ctt[ucii]; /*编程时间*/
 862   1      
 863   1        //g_ucState[69]=0x07;
 864   1        //g_ucState[70]=0xD1;
 865   1        //g_ucState[71]=0x06;
 866   1        //g_ucState[72]=0x01;
 867   1        //g_ucState[73]=0x08;
 868   1        //g_ucState[74]=0x00;
 869   1        //g_ucState[75]=0x00;
 870   1        g_ucState[76]=0x01;
 871   1        //g_ucState[77]=0x01;
 872   1      
 873   1      
 874   1      
 875   1      
 876   1      
 877   1      
 878   1        for(i=0;i<LINENUM;i++)           /*linecode=1..63*/
 879   1          g_ucLineCode[i]=i+1;
 880   1        for(i=0;i<LINENUM;i++)
 881   1        {
 882   2          g_ucLineMask[i]=0;          
 883   2      
 884   2        }
 885   1      
 886   1      
 887   1      
 888   1        /*for(i=0;i<LINENUM;i++)
 889   1        for(j=0;j<PMNUM;j++) linepmmask[i][j]=0;*/         
 890   1      
 891   1      
 892   1        actnumber=63;             
 893   1        almnumber=0;     
 894   1      
 895   1        ulEsLimit=0xff;
 896   1        ulSesLimit=0xff;
 897   1      
 898   1        g_ucAlmCode[0]=0x03;                        /*PPI_LOS*/
 899   1        g_ucAlmCode[1]=0x27;                        /*TU_LOP*/
 900   1        g_ucAlmCode[2]=0x22;                        /*LP_SLM*/
 901   1        g_ucAlmCode[3]=0x20;                        /*LP_RDI*/
 902   1        g_ucAlmCode[4]=0x24;                        /*LP_UNEQ*/
 903   1        //g_ucAlmCode[8]=0x04;                        /*PPI_AIS*/
 904   1        g_ucAlmCode[5]=0x02;                        /*TU_AIS*/
 905   1        //g_ucAlmCode[6]=0x0c;                        /*LP_RFI*/
 906   1        g_ucAlmCode[7]=0x51;                        /*ES_LIMIT*/
 907   1        //g_ucAlmCode[8]=0x52;      /*SES _LIMIT*/
 908   1        g_ucAlmCode[9]=0x28;                       /*LP_TIM*/
 909   1        g_ucAlmCode[10]=0x4f;                       /*LOOPL*/
 910   1        g_ucAlmCode[11]=0x55;     /*LOOP*/
 911   1        g_ucAlmCode[12]=0x01;                       //2V5电源故障告警//
 912   1        g_ucAlmCode[13]=0x05;                       //5VI1电源故障告警//
 913   1        g_ucAlmCode[14]=0x06;                       //5VI2电源故障告警//
 914   1        g_ucAlmCode[6]=0x07;                 //trafic-onload//
 915   1        g_ucAlmCode[8]=0x08;                /*LP_SD*/
 916   1      
 917   1        g_ucPmCode[0]=0x08;                   /*BBE_LP*/
 918   1        g_ucPmCode[1]=0x02;                   /*ES_LP*/
 919   1        g_ucPmCode[2]=0x03;                   /*SES_LP*/
 920   1        g_ucPmCode[3]=0x07;                   /*REI_LP*/
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 16  

 921   1        g_ucPmCode[4]=0x0b;                   /*HDB3CV*/
 922   1        //g_ucPmCode[5]=0x06;                 /*UAS_LP*/
 923   1        g_ucPmCode[5]=0x0c;                   /*UAS_LP*/
 924   1        g_ucPmCode[6]=0xa2;                   /*CSES_LP*/
 925   1      
 926   1        g_ucAlmType[0]=0;   /*almtype：0急告；4非急告；8状态量*/
 927   1        g_ucAlmType[1]=0;
 928   1        g_ucAlmType[2]=0;
 929   1        g_ucAlmType[3]=4;
 930   1        g_ucAlmType[4]=4;
 931   1        g_ucAlmType[5]=4;
 932   1        g_ucAlmType[6]=8;
 933   1        g_ucAlmType[7]=4;
 934   1        g_ucAlmType[8]=4;
 935   1        g_ucAlmType[9]=0;      /*LP_TIM*/
 936   1        g_ucAlmType[10]=8;         
 937   1        g_ucAlmType[11]=8;  
 938   1        g_ucAlmType[12]=0;
 939   1        g_ucAlmType[13]=0;
 940   1        g_ucAlmType[14]=0;
 941   1        //g_ucAlmType[15]=0;
 942   1      
 943   1        for(j=0;j<(LINENUM-1);j++)
 944   1        {
 945   2          for(i=0;i<(ALMTYPENUM-3);i++)
 946   2          {
 947   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucLineIndex=j;
 948   3            g_stuAlm[j*(ALMTYPENUM-3)+i].ucAlmIndex=i;
 949   3          }
 950   2        }
 951   1      
 952   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucLineIndex=63;
 953   1        g_stuAlm[63*(ALMTYPENUM-3)+0].ucAlmIndex=12;
 954   1      
 955   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucLineIndex=63;
 956   1        g_stuAlm[63*(ALMTYPENUM-3)+1].ucAlmIndex=13;
 957   1      
 958   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucLineIndex=63;
 959   1        g_stuAlm[63*(ALMTYPENUM-3)+2].ucAlmIndex=14;
 960   1      
 961   1      
 962   1        for(j=0;j<(LINENUM-1);j++)
 963   1        {
 964   2          for(i=0;i<PMTYPENUM;i++)
 965   2          {
 966   3            g_stuPm[j*PMTYPENUM+i].ucLineIndex=j;
 967   3            g_stuPm[j*PMTYPENUM+i].ucPmIndex=i;
 968   3          }
 969   2        }
 970   1      
 971   1        for(i=0;i<UASNUM;i++)
 972   1        {
 973   2          g_liError1s[i].ulDatlong=0;
 974   2          ulSesLmt[i]=700; //若某一秒内误码个数大于等于ulSesLmt[i]时,该秒是严重误码秒//
 975   2        }                  
 976   1      }
 977          
 978          
 979          
 980          /*****************************************************************
 981          ** 函数名:InitioSw1021
 982          ** 输　入: 无
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 17  

 983          ** 输　出: 无
 984          ** 功能描述：SW1021初始化
 985          ** 全局变量：
 986          ** 调用模块：
 987          ** 作　者：caijun.Li
 988          ** 日　期：2016.3.18
 989          ** 修　改：
 990          ** 日　期：
 991          ** 版  本：1.0
 992          ****************************************************************/
 993          void InitioSw1021()
 994          {
 995   1      
 996   1        unsigned int i,j;
 997   1        unsigned char m,n;
 998   1        first_conf=0;
 999   1      
1000   1        for(i=0; i<CHIPS_ON_BOARD; i++)
1001   1        {
1002   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = SRST_E1 | SRST_SDH_A | SRST_SDH_B;
1003   2          Delay(10);
1004   2          XBYTE[SW1021_CHIP_ADDR(i) + SOFTWARE_RST_REG] = RST_CANCLE;
1005   2          
1006   2          // TODO: 并行总线时钟选择
1007   2          // SW1021只支持19.44Mbit/s 的传输速率
1008   2          
1009   2          
1010   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)] = UPBUS_TIMER;  // 上行总线定时
1011   2          XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)] = UPBUS_TIMER;  // 上行总线定时
1012   2          
1013   2          // 上下话数据总线均选择偶校验
1014   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)] = UP_DELAY_2;
1015   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)] = UP_DELAY_2;
1016   2          
1017   2          // 21个端口从A总线上下话, 使用 +- HDB3模式
1018   2          for(j=0; j<21; j++){
1019   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)] = A_UP_DOWN | RnEN;
1020   3            // 关闭线路环回和系统环回
1021   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_TEST_REG(j)] = 0x00;
1022   3            // TODO: 上下话交叉状态选择 ： 不交叉
1023   3            
1024   3            // TODO: TU通道LOP\AIS告警检测设置： EN_TUAIS  使能TU-AIS 中断
1025   3            //                             EN_TULOP  使能TU-LOP 中断
1026   3            //                             
1027   3            XBYTE[SW1021_CHIP_ADDR(i) + PORT_E1_ALARM_INTERRPUT_MASK_REG(j)] = E1AISE | E1LOCE; //??
1028   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(A_BUS_BASE,j)] = LOPE | AISE;  
1029   3            XBYTE[SW1021_CHIP_ADDR(i) + INTERRUPT_ENABLE_REG(B_BUS_BASE,j)] = LOPE | AISE;  
1030   3            //TODO： 读清中断指示
1031   3            
1032   3            //TODO: 不启动随机码测试； 启动误码计数
1033   3            
1034   3            //TODO: 上话V5-TX2 设置 LP-REI
1035   3            XBYTE[SW1021_CHIP_ADDR(i) + TX_V5_REG(A_BUS_BASE,j)] = REI_CNF;
1036   3            
1037   3            //TODO： 上下话通道号编码
1038   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1039   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(A_BUS_BASE,j)] = slot[i*21+j];  
1040   3            XBYTE[SW1021_CHIP_ADDR(i) + RXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1041   3            XBYTE[SW1021_CHIP_ADDR(i) + TXTU12_SLOT_REG(B_BUS_BASE,j)] = slot[i*21+j];  
1042   3            
1043   3            
1044   3          }
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 18  

1045   2          // TODO:上下话时钟数据同相
1046   2          XBYTE[SW1021_CHIP_ADDR(i) + E1_CTRL_REG] = TRZSEL | RRZSEL;
1047   2          XBYTE[SW1021_CHIP_ADDR(i) + SDH_IF_CLK_REG] = 0x00;
1048   2      
1049   2        }
1050   1        
1051   1        // 填充所有支路的J2字节（初始化清0）
1052   1        for(i=0;i<63;i++)            
1053   1        {
1054   2          m=i/21;
1055   2          n=i%21;
1056   2          for(j=0;j<16;j++)
1057   2          {
1058   3            if(j==0)
1059   3            { // A 
1060   4              writeTxJ2(m, j, slot[i],  0x80, 0);
1061   4              writeExpectJ2(m, j, slot[i],  0x80, 0);
1062   4              // B
1063   4              writeTxJ2(m, j, slot[i],  0x80, 1);
1064   4              writeExpectJ2(m, j, slot[i],  0x80, 1);           
1065   4            }
1066   3            else
1067   3            {
1068   4              // A 
1069   4              writeTxJ2(m, j, slot[i],  0x00, 0);
1070   4              writeExpectJ2(m, j, slot[i],  0x00, 0);
1071   4              // B
1072   4              writeTxJ2(m, j, slot[i],  0x00, 1);
1073   4              writeExpectJ2(m, j, slot[i],  0x00, 1); 
1074   4            }
1075   3          }
1076   2        }
1077   1      
1078   1         IO8=1;
1079   1         IO9=1;
1080   1         IO10=1;
1081   1         IO11=1;
1082   1         IO12=1;
1083   1         WRHIO;
1084   1      
1085   1      }
1086          /*****************************************************************
1087          ** 函数名:checkSW1021Init
1088          ** 输　入: 无
1089          ** 输　出: 无
1090          ** 功能描述：检查SW1021初始化成功
1091          ** 全局变量：
1092          ** 调用模块：
1093          ** 作　者：caijun.Li
1094          ** 日　期：2016.3.18
1095          ** 修　改：
1096          ** 日　期：
1097          ** 版  本：1.0
1098          ****************************************************************/
1099          static int checkSW1021Init(void)
1100          {
1101   1        int ret = 0;
1102   1        int i,j;
1103   1        unsigned int reg;
1104   1        for(i=0;i<CHIPS_ON_BOARD;i++)
1105   1        {
1106   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(A_BUS_BASE)];
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 19  

1107   2          if( (reg & UPBUS_TIMER) != UPBUS_TIMER){
1108   3            ret = -1;
1109   3            break;
1110   3          }
1111   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + BUS_CTRL_REG(B_BUS_BASE)];
1112   2          if( (reg & UPBUS_TIMER) != UPBUS_TIMER){
1113   3            ret = -1;
1114   3            break;
1115   3          }
1116   2          
1117   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(A_BUS_BASE)];
1118   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1119   3            ret = -1;
1120   3            break;
1121   3          }
1122   2          
1123   2          reg = XBYTE[SW1021_CHIP_ADDR(i) + SDH_CTRL_REG(B_BUS_BASE)];
1124   2          if( (reg & UP_DELAY_2) != UP_DELAY_2){
1125   3            ret = -1;
1126   3            break;
1127   3          }
1128   2          
1129   2          for(j=0; j<21; j++){
1130   3            reg = XBYTE[SW1021_CHIP_ADDR(i) + PORT_CFG_REG(j)];
1131   3            if((reg & (A_UP_DOWN | RnEN)) != (A_UP_DOWN | RnEN)){
1132   4              ret = -1;
1133   4              goto quit;
1134   4            }
1135   3          }
1136   2      
1137   2        }
1138   1      quit:
1139   1        return ret;
1140   1      }
1141          
1142          /*****************************************************************
1143          ** 函数名:MAIN
1144          ** 输　入: 无
1145          ** 输　出: 无
1146          ** 功能描述：主函数
1147          ** 全局变量：g_QuarterFlag
1148          ** 调用模块：SelfConf(),GetData(),ProcHisData(),Debug();
1149          ** 作　者：caijun.Li
1150          ** 日　期：2016.3.18
1151          ** 修　改：
1152          ** 日　期：
1153          ** 版  本：1.0
1154          ****************************************************************/
1155          void main()
1156          {   
1157   1        unsigned char i;  
1158   1        int ret = 0;
1159   1        //Delay(50);
1160   1      
1161   1        SelfConf(); 
1162   1        
1163   1        ret = checkSW1021Init();
1164   1        if(ret != 0)
1165   1          InitioSw1021();
1166   1      
1167   1        while (1)
1168   1        {
C51 COMPILER V9.54   GF2488_01F1_E1_RST                                                    04/13/2016 14:31:06 PAGE 20  

1169   2      //  TXENABLE
1170   2      
1171   2            
1172   2          XBYTE[0x7b74] = 1;
1173   2          
1174   2          //ACT = ~ACT;
1175   2          //RED = ~RED;
1176   2          //YELLOW = ~YELLOW;
1177   2              
1178   2          
1179   2          ret = checkSW1021Init();
1180   2          if(ret != 0){ 
1181   3            SelfConf(); 
1182   3            InitioSw1021();
1183   3            ConfSet();  
1184   3          }
1185   2        
1186   2          GetData();
1187   2          ProcAlmData();  
1188   2      
1189   2          if (g_QuarterFlag) 
1190   2          {
1191   3            UasQuarter();
1192   3            for(i=0;i<LINENUM;i++)
1193   3            {
1194   4              g_stuPm[i*PMTYPENUM].Value.usint=g_usiBbe[i];
1195   4              g_stuPm[i*PMTYPENUM+1].Value.usint=g_usiEs[i];
1196   4              g_stuPm[i*PMTYPENUM+2].Value.usint=g_usiSes[i];
1197   4            }
1198   3            ProcHisData();  //将当前告警和性能数据存为历史数据//
1199   3            g_QuarterFlag=0;
1200   3          }
1201   2          
1202   2          Debug();
1203   2        }
1204   1      }
1205          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  11048    ----
   CONSTANT SIZE    =    208    ----
   XDATA SIZE       =  22238      88
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
